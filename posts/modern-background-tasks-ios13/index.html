<!doctype html><html prefix="og: http://ogp.me/ns#" lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,user-scalable=no"><meta http-equiv=x-ua-compatible content="ie=edge"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script><link rel=apple-touch-icon sizes=180x180 href=https://www.andyibanez.com/favicons/apple-touch-icon-180x180.png><link rel=icon type=image/png sizes=32x32 href=https://www.andyibanez.com/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.andyibanez.com/favicons/favicon-16x16.png><link rel=manifest href=https://www.andyibanez.com/favicons/site.webmanifest><link rel=mask-icon href=https://www.andyibanez.com/favicons/safari-pinned-tab.svg color=#292148><meta name=msapplication-TileColor content="#292148"><meta name=msapplication-config content="https://www.andyibanez.com/favicons/browserconfig.xml"><meta name=theme-color content="#292148"><link rel=canonical href=https://www.andyibanez.com/posts/modern-background-tasks-ios13/><link rel=alternate hreflang=en href=https://www.andyibanez.com/posts/modern-background-tasks-ios13/ title><meta name=description content="Learn how to implement the new BackgroundTasks framework in iOS 13"><meta name=author content><meta name=theme-color content="#292148"><meta itemprop=name content="Modern Backgrounds Tasks in iOS 13"><meta itemprop=description content="Learn how to implement the new BackgroundTasks framework in iOS 13"><meta itemprop=datePublished content="2019-12-25T07:00:00-04:00"><meta itemprop=dateModified content="2019-12-25T07:00:00-04:00"><meta itemprop=wordCount content="3137"><meta itemprop=keywords content="swift,ios,tvos,ipados,watchos,iOS13,backgroundtasks,wwdc2019"><meta property="og:url" content="https://www.andyibanez.com/posts/modern-background-tasks-ios13/"><meta property="og:site_name" content="Andy Ibanez"><meta property="og:title" content="Modern Backgrounds Tasks in iOS 13"><meta property="og:description" content="Learn how to implement the new BackgroundTasks framework in iOS 13"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-12-25T07:00:00-04:00"><meta property="article:modified_time" content="2019-12-25T07:00:00-04:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Ios"><meta property="article:tag" content="Macos"><meta property="article:tag" content="Tvos"><meta name=twitter:card content="summary"><meta name=twitter:title content="Modern Backgrounds Tasks in iOS 13"><meta name=twitter:description content="Learn how to implement the new BackgroundTasks framework in iOS 13"><meta name=twitter:creator content="@"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","url":"https://www.andyibanez.com/posts/modern-background-tasks-ios13/","headline":"Modern Backgrounds Tasks in iOS 13","description":"Learn how to implement the new BackgroundTasks framework in iOS 13","datePublished":"2019-12-25","keywords":"swift,programming,apple,ios,macos,tvos,watchos,ipados,iOS13,backgroundtasks,wwdc2019","author":{"@type":"Person","name":""}}</script><title>Modern Backgrounds Tasks in iOS 13 - Andy Ibanez</title><link rel=stylesheet href=https://www.andyibanez.com/style.main.min.18f604b90ed15864d7faa967f1ef9eacb99e1c967eff38762ec29b7bf1ab5876.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script></head><body><div class=wrapper><nav><div class=container><div class=language-selector></div></div></nav><header><div class=container><div class=header-group><div class=header-logo-container><a class=header-logo-link href=https://www.andyibanez.com/><img class=header-logo-circle src=https://www.andyibanez.com/img/andy_profile.png alt="Andy Ibanez logo"></a></div><div class=header-title><a href=https://www.andyibanez.com/>Andy Ibanez</a></div></div></div></header><nav><div class=container><div class=main-navigation><a href=/about/>About Me</a><a href=/posts/>Blog</a><a href=/projects/>Projects</a><a href=/tags/>Tags</a><a href=/contact/>Contact</a><a href=/privacy-policy/>Privacy policy</a></div></div></nav><div class=container><div class=search><input type=text id=searchInput placeholder="Type here to search"></div><div class="container search-results-container" hidden=true><div id=searchResults class=search-results></div></div></div><main><div class=container><article><h1 class=title>Modern Backgrounds Tasks in iOS 13</h1><p class=publish>Published on
<time class=post-date datetime=2019-12-25T07:00:00-04:00>December 25, 2019</time></p><p>In the <a href=/posts/background-execution-in-ios/>article from last week</a>, we explored the basic background execution APIs introduced since iOS 7. We explored how we could request additional time for a task to complete after entering the background, how we could defer downloads with URLSession, and how we could use silent push notifications to trigger background tasks.</p><p>The story with background tasks does not end there. iOS 13 introduced more APIs to do better background tasks, and that allow you to do things that weren&rsquo;t possible before. Apple gave us the new shiny <a href=https://developer.apple.com/documentation/backgroundtasks><code>BackgroundTasks</code></a> framework on WWDC2019. This framework gives developers more flexibility and less constraints to execute code while their apps are in the background. Not only that, but the old Background App Refresh APIs have now been deprecated in favor of a new, modern way to perform them for your app. This changes unifies with the new Background Processing tasks which lets you do more work in the background, while a device is charging, and more.</p><p>In this article, we will explore the following APIs, all part of the new <code>BackgroundTasks</code> framework:</p><ol><li>The new BackgroundTasks Framework.</li><li>Background App Refresh Tasks.</li><li>Processing tasks.</li></ol><p>For point 2, we will write a quick example app to show how to adopt <code>BackgroundTasks</code> in your app. If you don&rsquo;t feel like writing such app, it will be included as a download near the end of the article. We won&rsquo;t write an example for processing tasks because the idea is exactly the same, but we will mention some extra properties that task has that can help you create better background tasks.</p><p>This article is based on the <a href=https://developer.apple.com/videos/play/wwdc2019/707>Advances in Background Execution</a> WWDC 2019 talk and in the documentation, but I have taken the liberty to add my own code examples and I have removed content that is not not relevant for the majority of developers (VoIP pushes, etc).</p><h2 id=introducing-backgroundtasks>Introducing BackgroundTasks</h2><p><code>BackgroundTasks</code> is a new framework for scheduling background work. Along with it, we get a new background mode for our apps. And to top if off, the framework is available on most of Apple&rsquo;s platforms except for watchOS: iOS, iPadOS, tvOS, and on Catalyst apps on the Mac.</p><hr>**Note**<p>The app is available for Catalyst apps, but neither the WWDC session or the documentation mention it for macOS apps (AppKit).</p><hr><p>The new background mode is called <code>Background Processing Tasks</code>. And starting on iOS 13, the existing Background App Refresh Task has been refined and received some new improvements.</p><h2 id=the-new-background-mode>The New Background Mode</h2><p>This API is pretty neat, because it can give your app <em>several minutes</em> of runtime, although the constraint of doing so at system-friendly times is still there. This is what allows you to perform deferrable maintenance work, including machine learning tasks such as on-device Core ML training. It also allows you to turn off CPU Monitor for intensive work. This is very interesting, because we can use the full power of the device for as long as it is plugged in. Your app is eligible to run these tasks in the foreground or if your app has been recently used.</p><h2 id=improvements-to-background-app-refresh-task>Improvements to Background App Refresh Task</h2><p>If you used the old background app refresh APIs, be aware that there&rsquo;s new API, but the same policies still apply. You get 30 seconds of runtime, and you can keep your app up-to-date throughout the day.</p><hr>**Note**<p>The WWDC session does mention you get 30 seconds of runtime, but as I discussed in the previous article on Background Execution, don&rsquo;t rely on this number. You can get the real time left from the app delegate.</p><hr><p>The eligibility depends on how your user uses your app, so the system will intelligently decide when to execute these tasks. The system will learn the pattern of your users and adapt to it in order to perform them. If your app is used frequently, your tasks will be performed frequently. On the other hand, if your users don&rsquo;t use your app enough, you get less execution time.</p><p>This new API replaces the old one, so the fetch APIs of <code>UIApplication</code> for background app refresh are deprecated and are not supported on the Mac.</p><hr>**Note**<p>The documentation says that the old APIs are not supported &ldquo;on the Mac&rdquo;, but it&rsquo;s established that these APIs do not work on the Mac to begin with, so I&rsquo;m assuming it&rsquo;s saying that the deprecated APIs are not available for Catalyst apps.</p><hr><h2 id=using-backgroundtasks>Using BackgroundTasks</h2><h3 id=overview-of-the-backgroundtasks-framework>Overview of the BackgroundTasks Framework</h3><p>The main API for using this framework is the <code>BGTaskScheduler</code> . This API constantly monitors the system state such as battery level, background usage, and more, so it chooses the optimal time to run your tasks.</p><p>To use this API, you begin working when your app is on the foreground. You need to create Background task requests. The framework provides an abstract class, <a href=https://developer.apple.com/documentation/backgroundtasks/bgtask><code>BGTask</code></a>, you never use this task directly. Instead, the framework provides two concrete subclasses you can interact with: <a href=https://developer.apple.com/documentation/backgroundtasks/bgprocessingtask><code>BGProcessingTask</code></a>, for long running and maintenance tasks such backup and cleanup, and <a href=https://developer.apple.com/documentation/backgroundtasks/bgapprefreshtask><code>BGAppRefreshTask</code></a> to keep your app up-to-date throughout the day.</p><p>You don&rsquo;t create instances of these classes directly. Instead, you create <code>BGAppRefreshTaskRequest</code>s and <code>BGProcessingTaskRequest</code>s and submit them to <code>BGTaskScheduler</code>. When the scheduler wakes up your app to pass the tasks, you will get their <code>BGAppRefreshTask</code> and <code>BGProcessingTask</code> counterparts.</p><p>You can submit multiple tasks to the scheduler and you can submit both <code>BGAppRefreshTask</code> and <code>BGProcessingTask</code> at the same time. Interestingly enough, it&rsquo;s also possible to submit tasks from an extension. This is useful if, for example, you have a keyboard extension that uses machine learning to learn your users&rsquo; typing patterns.</p><p>The tasks will not start automatically. When <code>BGTaskScheduler</code> sees that the system meets all the conditions required for a specific task, it will wake up your app in the background, and it will handle it the task from the scheduler. If we get a <code>BGAppRefreshTask</code>, we can fetch content, process it, and update our UI. If we get a <code>BGProcessingTask</code>, we can do some cleanup, backups, or other similar tasks. When the task is finished, we need to mark it as completed, so we can allow the app to suspend.</p><p>Depending on how tasks are configured, and on the system conditions, the system may wake your app and pass it more than one task at the time. The system allocates a finite amount of time to execute these tasks. And it&rsquo;s important to note that the allotted time is per <em>launch</em>, not per <em>task</em>, so you should handle all the tasks concurrently at the same time.</p><p>Tasks scheduled by extensions will be handed to the main app. Extensions themselves never handle background tasks, so design your app&rsquo;s data model in a way that the extension data is shared, and not contained within the exension itself.</p><h3 id=adopting-backgroundtasks-in-your-apps>Adopting BackgroundTasks in Your Apps</h3><p>From here on out we will play with the new APIs using a sample project. I generally avoid writing full projects for my articles, but I thought it was necessary to do it this time, as it&rsquo;s the only way to see <code>BackgroundTasks</code> in action. So go ahead and create a new Simple View App project on Xcode.</p><h4 id=initial-setup>Initial Setup</h4><p>Before you can use this new framework, you have a tiny-wee bit of setup work to do.</p><p>First, you need to edit the <code>Signing & Capabilities</code> of your target and you need to add a new Capability for background tasks. Tap the &ldquo;+&rdquo; sign and search for &ldquo;Background Modes&rdquo;</p><p><img src=/img/sigcapsbgmodes.png alt="Adding Background Modes"></p><p>This will add a new section in your app, and you need to tick the ones you are interested in using. For <code>BGAppRefreshTask</code>, enable &ldquo;background fetch&rdquo;, and for <code>BGProcessingTask</code> you need &ldquo;background processing&rdquo;. As you may have guessed, you don&rsquo;t need to use both in an app, and you can pick and choose what you need.</p><p><img src=/img/bgmodes.png alt="Background Modes"></p><p>We are not quite done yet. Now you need to edit your app&rsquo;s <code>Info.plist</code> and add the <code>Permitted background task scheduler identifiers</code> (<code>BGTaskSchedulerPermittedIdentifiers</code>) key and add the identifiers of the tasks you want your app to perform:</p><p><img src=/img/allowedbgids.png alt="Allowed Background Identifiers"></p><p>It&rsquo;s recommended you use reverse DNS Notation, as third party dependencies may add their own identifiers.</p><p>We now have all the necessary setup to start playing with this new framework.</p><h4 id=implementing-backgroundtasks---bgapprefreshtask>Implementing BackgroundTasks - BGAppRefreshTask</h4><p>The examples here uses the <a href=https://pokeapi.co>PokéAPI</a> service. PokéAPI is a free web service that provides information on Pokémon. It can be used by both casual Pokémon fans or hardcore gamers.</p><p>The app will simply display a Pokémon name and its sprite. When we background the app, we will use <code>BGAppRefreshTask</code> to retrieve a new Pokémon with a random ID.</p><p>I will only show you how to use <code>BGAppRefreshTask</code>, but rest assured that what applies to this task type, also applies to <code>BGProcessingTask</code>.</p><hr>**Note**<p>As much as a weeb as I am, I promise I&rsquo;m not a Pokémon fan. I chose this API because it&rsquo;s easy to use and doesn&rsquo;t require any setup.</p><p>(I promise)</p><hr><p>I will show you my code here, so you can build along if you wish. If you don&rsquo;t feel like doing that, I will also provide a download to the finish project near the end of this article.</p><p>First, create a new blank project, and create a view-controller similar to this:</p><p><img src=/img/pokemainvc.png alt="Pokémon View Controller"></p><p>Now we are going to implement a quick manager to get info on a specific Pokémon with its ID. We will also add a function to download images, for the Pokémon Sprites.</p><p><strong>Pokémon.swift</strong></p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>Pokemon</span>: Codable {
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>Species</span>: Codable {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>name</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>Sprites</span>: Codable {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>backDefault</span>: URL?
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>backShiny</span>: URL?
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>frontDefault</span>: URL?
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>frontShiny</span>: URL?
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>enum</span> <span style=color:#f9e2af>CodingKeys</span>: <span style=color:#89dceb>String</span>, CodingKey {
</span></span><span style=display:flex><span>      <span style=color:#cba6f7>case</span> backDefault = <span style=color:#a6e3a1>&#34;back_default&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#cba6f7>case</span> backShiny = <span style=color:#a6e3a1>&#34;back_shiny&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#cba6f7>case</span> frontDefault = <span style=color:#a6e3a1>&#34;front_default&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#cba6f7>case</span> frontShiny = <span style=color:#a6e3a1>&#34;front_shiny&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>species</span>: Species
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>sprites</span>: Sprites
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>PokeManager.swift</strong></p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>PokeManager</span> {
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>static</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>urlSession</span> = URLSession(configuration: .<span style=color:#cba6f7>default</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>static</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>pokemon</span>(id: <span style=color:#89dceb>Int</span>,
</span></span><span style=display:flex><span>                      completionHandler: @escaping (<span style=color:#fab387>_</span> pokemon: Pokemon) -&gt; <span style=color:#89dceb>Void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>pokeUrl</span> = buildPokemonURL(id: id)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>task</span> = urlSession.dataTask(with: pokeUrl) { (data, <span style=color:#fab387>_</span>, <span style=color:#fab387>_</span>) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>      <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>pokemon</span> = <span style=color:#cba6f7>try</span>! JSONDecoder().decode(Pokemon.<span style=color:#fab387>self</span>, from: data!)
</span></span><span style=display:flex><span>      DispatchQueue.main.async {
</span></span><span style=display:flex><span>        completionHandler(pokemon)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    task.resume()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>static</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(url: URL, completionHandler: @escaping (<span style=color:#fab387>_</span> image: UIImage) -&gt; <span style=color:#89dceb>Void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>task</span> = urlSession.dataTask(with: url) { data, <span style=color:#fab387>_</span>, <span style=color:#fab387>_</span> <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>      <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data!)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>      DispatchQueue.main.async {
</span></span><span style=display:flex><span>        completionHandler(image)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    task.resume()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>static</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>buildPokemonURL</span>(id: <span style=color:#89dceb>Int</span>) -&gt; URL {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>urlComponents</span> = URLComponents()
</span></span><span style=display:flex><span>    urlComponents.scheme = <span style=color:#a6e3a1>&#34;https&#34;</span>
</span></span><span style=display:flex><span>    urlComponents.host = <span style=color:#a6e3a1>&#34;pokeapi.co&#34;</span>
</span></span><span style=display:flex><span>    urlComponents.path = <span style=color:#a6e3a1>&#34;/api/v2/pokemon/</span><span style=color:#a6e3a1>\(</span>id<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> urlComponents.url!
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now on the view controller for the view you created above, implement <code>fetchPokemon(id: Int)</code> , and call it on <code>viewDidLoad</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#cba6f7>override</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>viewDidLoad</span>() {
</span></span><span style=display:flex><span>	<span style=color:#fab387>super</span>.viewDidLoad()
</span></span><span style=display:flex><span>	fetchPokemon(id: <span style=color:#fab387>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>fetchPokemon</span>(id: <span style=color:#89dceb>Int</span>) {
</span></span><span style=display:flex><span>	PokeManager.pokemon(id: id) { (pokemon) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>	  <span style=color:#fab387>self</span>.name.text = pokemon.species.name
</span></span><span style=display:flex><span>	  PokeManager.downloadImage(url: pokemon.sprites.backDefault!) { (image) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>	    <span style=color:#fab387>self</span>.image.image = image
</span></span><span style=display:flex><span>	  }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Build and run the project, and you will see a nice Bulbasaur:</p><p><img src=/img/firstpoke.png alt="A Neat Bulbasaur"></p><p>We can now implement the scheduler. When the app is backgrounded, we will grab a random Pokémon ID (between 1 and 151 - because I&rsquo;m old and I don&rsquo;t remember many Pokémon after the first generation), download it, and display it.</p><p>That&rsquo;s it for the view controller for now. We need to edit other parts of the app now.</p><p>In your AppDelegate, import <code>BackgroundTasks</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>import</span> <span style=color:#f9e2af>BackgroundTasks</span>
</span></span></code></pre></div><p>What we need to do now is to register our app to receive <code>BGTask</code>s when the system hands them to the app. You need to call this method once for each identifier specified in <code>‌BGTaskSchedulerPermittedIdentifiers</code> in your <code>Info.plist</code>. You can do this in <code>appliation(didFinishLaunchingWithOptions:)</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>    BGTaskScheduler.shared.register(forTaskWithIdentifier: <span style=color:#a6e3a1>&#34;com.andyibanez.fetchPokemon&#34;</span>,
</span></span><span style=display:flex><span>                                    using: <span style=color:#fab387>nil</span>) { (task) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>      <span style=color:#6c7086;font-style:italic>// ...</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>The first parameter takes the task identifier. The second takes a <code>DispatchQueue?</code>, which you can use to synchronize your task with other threads. If you pass in <code>nil</code>, the system will create a concurrent queue for you.</p><p>I will create a new method in the AppDelegate, and the handler from <code>register</code> will call it to start doing a background work:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>handleAppRefreshTask</span>(task: BGAppRefreshTask) {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>BGTaskScheduler.shared.register(
</span></span><span style=display:flex><span>  forTaskWithIdentifier: <span style=color:#a6e3a1>&#34;com.andyibanez.fetchPokemon&#34;</span>,
</span></span><span style=display:flex><span>  using: <span style=color:#fab387>nil</span>) { (task) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>    <span style=color:#fab387>self</span>.handleAppRefreshTask(task: task <span style=color:#cba6f7>as</span>! BGAppRefreshTask)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The system will give us limited time to execute the task. The first thing we&rsquo;ll do is to cancel all the operations happening in <code>PokeManager</code> when we reach our expiration time:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>handleAppRefreshTask</span>(task: BGAppRefreshTask) {
</span></span><span style=display:flex><span>	task.expirationHandler = {
</span></span><span style=display:flex><span>	  PokeManager.urlSession.invalidateAndCancel()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Later, we will also mark the task as completed. This way we are playing nice by the system&rsquo;s rules, and we will be able to get most background time we request.</p><p>But first, we need to actually schedule a background task. We will schedule the task when the app enters the background.</p><p>In your app delegate:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>scheduleBackgroundPokemonFetch</span>() {
</span></span><span style=display:flex><span>	<span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>pokemonFetchTask</span> = BGAppRefreshTaskRequest(identifier: <span style=color:#a6e3a1>&#34;com.andyibanez.fetchPokemon&#34;</span>)
</span></span><span style=display:flex><span>	pokemonFetchTask.earliestBeginDate = Date(timeIntervalSinceNow: <span style=color:#fab387>60</span>)
</span></span><span style=display:flex><span>	<span style=color:#cba6f7>do</span> {
</span></span><span style=display:flex><span>	  <span style=color:#cba6f7>try</span> BGTaskScheduler.shared.submit(pokemonFetchTask)
</span></span><span style=display:flex><span>	} <span style=color:#cba6f7>catch</span> {
</span></span><span style=display:flex><span>	  <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Unable to submit task: </span><span style=color:#a6e3a1>\(</span>error.localizedDescription<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you schedule tasks when the app is being launched, you should call <code>BGTaskScheduler.shared.submit</code> on a background thread as it is a blocking API. This is not a concern when sending it to the background.</p><p>And then, in your <code>SceneDelegate.swift</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>sceneDidEnterBackground</span>(<span style=color:#fab387>_</span> scene: UIScene) {
</span></span><span style=display:flex><span>	(UIApplication.shared.delegate <span style=color:#cba6f7>as</span>! AppDelegate).scheduleBackgroundPokemonFetch()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr>**Important Note!**<p>In the WWDC talk, the presenter uses <code>applicationDidEnterBackground</code> in the app delegate instead of the Scene Delegate to schedule the background task. <code>applicationDidEnterBackground</code> is the old API for the old lifecycle of apps prior to iOS 13. In iOS 13, I wasn&rsquo;t able to get my app to call that delegate method at all, so I figured I needed to use the scene delegate instead.</p><p>You might also be wondering why we have the task handling code in the App Delegate and not scene delegate. The reason is the methods in SceneDelegate can get called multiple times throughout the lifecycle of the app. This can only happen in iPadOS as it has multi-window support. We want to register the handler for our tasks only one time during the lifetime of our app. You can <em>probably</em> write all your BackgroundTasks code in the SceneDelegate if you have an iPhone-only app, but I can&rsquo;t say I recommend doing that.</p><hr><p>We can specify the <code>earliestBeginDate</code> property of the task. This will let us download the data as soon as possible. In the example above, we are scheduling the task 5 seconds after it is backgrounded. This does not guarantee that the task will start at the specified time, but rather that it won&rsquo;t start any sooner than that. If you use the default <code>nil</code>, there will be no start delay.</p><p>You should not set this property too far into the future. The app may not be called at all if the user never goes back to your app. You should set this limit to one week or less. This recommendation is given in the WWDC talk for this topic.</p><p>We are almost done. Now we need to go back to <code>handleAppRefreshTask</code> and implementing the Pokémon downloading code:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>handleAppRefreshTask</span>(task: BGAppRefreshTask) {
</span></span><span style=display:flex><span>  task.expirationHandler = {
</span></span><span style=display:flex><span>    task.setTaskCompleted(success: <span style=color:#fab387>false</span>)
</span></span><span style=display:flex><span>    PokeManager.urlSession.invalidateAndCancel()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>randomPoke</span> = (<span style=color:#fab387>1.</span>..<span style=color:#fab387>151</span>).randomElement() ?? <span style=color:#fab387>1</span>
</span></span><span style=display:flex><span>  PokeManager.pokemon(id: randomPoke) { (pokemon) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>    NotificationCenter.<span style=color:#cba6f7>default</span>.post(name: .newPokemonFetched,
</span></span><span style=display:flex><span>                                    object: <span style=color:#fab387>self</span>,
</span></span><span style=display:flex><span>                                    userInfo: [<span style=color:#a6e3a1>&#34;pokemon&#34;</span>: pokemon])
</span></span><span style=display:flex><span>    task.setTaskCompleted(success: <span style=color:#fab387>true</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  scheduleBackgroundPokemonFetch()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When you schedule a task, it will only be executed once. If you want to keep executing it throughout the day, you simply need to call <code>scheduleBackgroundPokemonFetch</code> again inside <code>handleAppRefreshTask</code>.</p><p>We are using <code>NotificationCenter</code> to notify the view controller that a new Pokémon has been retrieved and that the UI should be updated accordingly, so create a new <code>Notification.Name</code> for that too:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>extension</span> <span style=color:#f9e2af>Notification</span>.Name {
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>static</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>newPokemonFetched</span> = Notification.Name(<span style=color:#a6e3a1>&#34;com.andyibanez.newPokemonFetched&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, in the view controller, register for this notification and update the UI when received:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>registerForNotifications</span>() {
</span></span><span style=display:flex><span>  NotificationCenter.<span style=color:#cba6f7>default</span>.addObserver(
</span></span><span style=display:flex><span>    forName: .newPokemonFetched,
</span></span><span style=display:flex><span>    object: <span style=color:#fab387>nil</span>,
</span></span><span style=display:flex><span>    queue: <span style=color:#fab387>nil</span>) { (notification) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>      <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;notification received&#34;</span>)
</span></span><span style=display:flex><span>      <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>uInfo</span> = notification.userInfo,
</span></span><span style=display:flex><span>         <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>pokemon</span> = uInfo[<span style=color:#a6e3a1>&#34;pokemon&#34;</span>] <span style=color:#cba6f7>as</span>? Pokemon {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.updateWithPokemon(pokemon)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>updateWithPokemon</span>(<span style=color:#fab387>_</span> pokemon: Pokemon) {
</span></span><span style=display:flex><span>  name.text = pokemon.species.name
</span></span><span style=display:flex><span>  PokeManager.downloadImage(url: pokemon.sprites.backDefault!) { (image) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>    <span style=color:#fab387>self</span>.image.image = image
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#cba6f7>override</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>viewDidLoad</span>() {
</span></span><span style=display:flex><span>	<span style=color:#fab387>super</span>.viewDidLoad()
</span></span><span style=display:flex><span>	registerForNotifications()
</span></span><span style=display:flex><span>	fetchPokemon(id: <span style=color:#fab387>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And done! Now your app can refresh in the background and each time it does it will show a new Pokémon. Exciting!</p><h5 id=testing>Testing</h5><p>Well, this is a bit of a problem, but if you try to run this now, you will come across two problems:</p><ol><li>This does not work on the simulator at all. You need to run the app on a real device.</li><li>You have no control over when the task will run. As we said before, <code>earliestBeginDate</code> will not guarantee the app receives an event at that time. You may leave your phone connected to your computer for hours without receiving an event. So what to do?</li></ol><p>Testing on the simulator is out of the question, but you can force events to happen via the debugger when running the app on a real device.</p><p>Build and run your app and then background it to schedule the task. Bring the app to the foreground again. Then in Xcode, hit the pause button in the debugger.</p><p><img src=/img/xcode-debug-pause.png alt="Pause the App"></p><p>You can then copy and paste the following commands, replacing <code>"TASK_IDENTIFIER"</code> with your task identifier.</p><p>To simulate a receiving an event:</p><pre tabindex=0><code>e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@&#34;TASK_IDENTIFIER&#34;]
</code></pre><p>After you press enter, you will see a new Pokémon on the screen. Keep doing it to see more Pokémon. Let the nostalgia in.</p><p>And to force an early termination of a task:</p><pre tabindex=0><code>e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@&#34;TASK_IDENTIFIER&#34;]
</code></pre><p>These are documented <a href=https://developer.apple.com/documentation/backgroundtasks/starting_and_terminating_tasks_during_development>here</a>. Needless to say you shouldn&rsquo;t try to call those private methods within your app itself.</p><h4 id=sample-project>Sample Project.</h4><p>You can download the sample project for this app <a href=/archives/bgTasks.zip>here</a>.</p><h3 id=bgprocessingtask>BGProcessingTask</h3><p>The usage of this task is exactly the same as the other one. But <code>BGProcessingTaskRequest</code>s have two additional properties that make it good to use for maintenance and background tasks.</p><ul><li><code>requiresNetworkConnectivity</code>: If the task requires internet to work, you can set this property to <code>true</code>.</li><li><code>requiresExternalPower</code>: If the task requires the device to be connected to power to work, you can set this property to <code>true</code>.</li></ul><h1 id=conclusion>Conclusion</h1><p><code>BackgroundTasks</code> is a new framework introduced in iOS 13 to offer developers more ways to execute background work. Background task offers two type of classes:</p><ul><li><code>BGAppRefreshTask</code>: To refresh your app in the background periodically and always have up to date content.</li><li><code>BGProcessingTask</code>: To perform possibly longer operations related to mainenance, backup, and cleanup of the app. We can set tasks of this type to execute when our devices are connected to power and/or have internet connection available.</li></ul><p>The scheduler will decide the best time to wake up your app and hand them the tasks to execute. Be a good citizen and always let the system know when a task has finished running, either successfully or unsuccessfully.</p><hr><p><strong>Short Break Notice</strong></p><p>Despite the fact that the article is ready, I will not be publishing anything on New Years (January 1, 2020). I&rsquo;m taking a short break. For that reason, Jan 1st&rsquo;s article is getting pushed to January 8. Thank you for your understanding!</p></article></div></main><footer><div class=container><div class=footer-navigation><a href=https://github.com/AndyIbanez><span class=inline-svg><svg viewBox="0 0 42 40" id="svg4" width="42" height="40"><path fill="currentColor" d="m14.20936 32.20794c0 .16542-.19024.29776-.4301.29776-.27295.0248-.46319-.10752-.46319-.29776.0-.16542.19024-.29776.4301-.29776.24814-.0248.46319.10752.46319.29776zm-2.57234-.3722c-.0579.16542.10753.35566.35566.40528.21505.0827.46319.0.51282-.16542.0496-.16542-.10753-.35566-.35566-.4301-.21505-.0579-.45492.0248-.51282.19024zm3.65586-.14061c-.23986.0579-.40529.21505-.38047.40528.0248.16543.23986.27295.488.21505.23986-.0579.40528-.21505.38047-.38047-.0248-.15715-.24813-.26468-.488-.23986zM20.73531-.19734273e-6C9.2632-.19734273e-6.48748 8.7095398.48748 20.18166c0 9.17273 5.77328 17.02207 14.01964 19.78464 1.05871.19024 1.43091-.46319 1.43091-1.00081.0-.51282-.0248-3.34156-.0248-5.0785.0.0-5.78982 1.24067-7.00568-2.46481.0.0-.94292-2.40691-2.29939-3.02725.0.0-1.8941-1.29857.13234-1.27376.0.0 2.05952.16542 3.19267 2.13396 1.81139 3.19267 4.84691 2.27457 6.02969 1.72868.19023-1.32339.72786-2.24149 1.32338-2.78739-4.62358-.51281-9.28852-1.18278-9.28852-9.13964.0-2.27458.62861-3.416 1.95199-4.87172-.21505-.53763-.9181-2.7543.21506-5.6161302 1.72867-.53762 5.7071 2.2332202 5.7071 2.2332202 1.65424-.46319 3.43254-.70305 5.1943-.70305 1.76176.0 3.54006.23986 5.1943.70305.0.0 3.97843-2.7791202 5.7071-2.2332202 1.13315 2.8701002.4301 5.0785002.21505 5.6161302 1.32339 1.46399 2.13397 2.60542 2.13397 4.87172.0 7.98168-4.87172 8.61856-9.49531 9.13964.76095.65342 1.4061 1.8941 1.4061 3.83782.0 2.78739-.0248 6.23647-.0248 6.9147.0.53763.38047 1.19105 1.43091 1.00082 8.27117-2.74603 13.87903-10.59537 13.87903-19.7681C41.51252 8.7095398 32.20745-.19734273e-6 20.73533-.19734273e-6zM8.52706 28.52727c-.10752.0827-.0827.27295.0579.4301.13234.13234.32258.19024.4301.0827.10753-.0827.0827-.27295-.0579-.4301-.13233-.13234-.32257-.19024-.4301-.0827zM7.63378 27.8573c-.0579.10753.0248.23987.19023.32258.13234.0827.29777.0579.35566-.0579C8.23757 28.01446 8.15487 27.88212 7.98944 27.7994 7.82401 27.7498 7.69168 27.7746 7.63378 27.8573zm2.67986 2.94454c-.13234.10753-.0827.35566.10752.51281.19024.19024.4301.21505.53763.0827.10752-.10752.0579-.35566-.10753-.51281-.18196-.19024-.4301-.21505-.53762-.0827zM9.37072 29.58598c-.13234.0827-.13234.29776.0.488.13234.19023.35566.27295.46319.19023.13234-.10752.13234-.32257.0-.51281-.1158-.19024-.33085-.27295-.46319-.16542z" id="path2" style="stroke-width:.08271171"/></svg>
</span></a><a href=https://x.com/AndyIbanezK><span class=inline-svg><svg viewBox="0 0 50 40" id="svg4" width="50" height="40"><path fill="currentColor" d="m44.56253 9.96871c.0313.43748.0313.87506.0313 1.31254C44.59383 24.62494 34.43764 40 15.87508 40 10.1563 40 4.84383 38.34368.37506 35.4688c.81253.0937 1.5937.12495 2.4375.12495 4.71867.0 9.06249-1.5937 12.53125-4.31245-4.43751-.0938-8.15627-3.00003-9.43754-7.00006.62505.0937 1.25001.15622 1.90632.15622.90622.0 1.81254-.12505 2.65624-.34369C5.84384 23.15619 2.37498 19.09373 2.37498 14.18748v-.12495c1.3437.75 2.90633 1.21875 4.56246 1.28117-2.71876-1.81253-4.49993-4.90624-4.49993-8.40627.0-1.87497.4999-3.59372 1.37496-5.09373 4.96877 6.125 12.43756 10.12493 20.81248 10.56251-.15622-.75001-.25-1.53118-.25-2.31245C24.37495 4.5312 28.87498.0 34.46871.0c2.90623.0 5.53121 1.21875 7.37501 3.1875 2.28118-.43748 4.46867-1.28127 6.40626-2.43749-.75011 2.3438-2.34381 4.31255-4.43751 5.56246 2.03127-.21864 4.00003-.78126 5.81247-1.56244-1.37477 1.99992-3.09362 3.7811-5.06237 5.21868z" id="path2" style="stroke-width:.09619153"/></svg>
</span></a><a href=https://www.linkedin.com/in/andyibanez/><span class=inline-svg><svg viewBox="0 0 41 40" id="svg4" width="41" height="40"><path fill="currentColor" d="M9.45332 40H1.16028V13.29405H9.45332zM5.30234 9.65111c-2.65185.0-4.80279-2.19648-4.80279-4.84832a4.80279 4.80279.0 019.60558.0c0 2.65184-2.15184 4.84832-4.80279 4.84832zM40.49152 40H32.21633V26.99971c0-3.09828-.0625-7.07159-4.3117-7.07159-4.3117.0-4.97243 3.36615-4.97243 6.84837V40H14.64808V13.29405h7.95375v3.64294h.11608c1.10716-2.09827 3.81169-4.3126 7.8466-4.3126 8.39304.0 9.93594 5.52691 9.93594 12.70564V40z" id="path2" style="stroke-width:.08928771"/></svg>
</span></a><a href=https://www.andyibanez.com/posts/index.xml><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m11.435816 34.282008c0 3.15793-2.5599899 5.71793-5.7179299 5.71793s-5.717840022654-2.56-5.717840022654-5.71793c0-3.15794 2.559990022654-5.71793 5.717930022654-5.71793s5.7178399 2.56008 5.7178399 5.71793zm15.68388 4.21873C26.373806 24.697208 15.317496 13.626978 1.4992361 12.880288.68361608 12.836188.46077346e-4 13.491538.46077346e-4 14.308318v4.29186c0 .75134.579460002654 1.38142 1.329190022654 1.43017 9.9849699.65036 17.9886099 8.63408 18.6402999 18.6403.0488.74973.67893 1.3292 1.43018 1.3292h4.29186c.81687 9e-5 1.47223-.68348 1.42812-1.49911zm12.87933.0257C39.249566 17.649718 22.452206.754048 1.4735261.00092799867.66727608-.027972.46077346e-4.623338.46077346e-4 1.430038v4.29177c0 .77008.610270002654 1.39687 1.379730022654 1.42848 17.0694999.6999 30.7701699 14.40316 31.4699899 31.46999.0315.76946.6583 1.37972 1.42848 1.37972h4.29177c.8066-8e-5 1.45794-.66731 1.42901-1.47356z" id="path2" style="stroke-width:.08928544"/></svg>
</span></a><a href=https://www.andyibanez.com/contact><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m39.99999 36.249999c0 2.0711-1.6789 3.75-3.74999 3.75H3.75c-2.07109.0-3.74999-1.6789-3.74999-3.75v-20.56843a3.7499996 3.7499996.0 011.43648-2.95125c1.94633-1.5257 3.55476-2.7628904 12.82812-9.4930404C15.57906 2.2789186 18.18727-.02709136 20 .00024864227 21.81234-.02745136 24.42156 2.2793086 25.73539 3.2371986c9.27242 6.72945 10.88304 7.9683604 12.82812 9.4931204a3.7499996 3.7499996.0 011.43648 2.95125zm-5.13015-15.35976c-.20024-.29125-.60156-.35898-.88586-.14898-1.78476 1.3182-4.33297 3.18008-8.24859 6.02179-1.31445.95828-3.92266 3.26414-5.73539 3.23672-1.81336.0269-4.41867-2.2768-5.73539-3.23672-3.91515-2.8414-6.46359-4.70343-8.24859-6.02179-.2843-.21-.68562-.14227-.88586.14898l-.70875 1.03094a.62484368.62484368.0 00.14367.8568c1.78805 1.32023 4.33235 3.1789 8.2268 6.00531 1.5839 1.15476 4.41593 3.73539 7.20812 3.71664 2.79094.0189 5.62195-2.56024 7.20804-3.71664 3.89453-2.82649 6.43891-4.68516 8.2268-6.00531a.62484368.62484368.0 00.14367-.8568z" id="path2" style="stroke-width:.07812498"/></svg></span></a></div></div><p class=made-with-love><a href=https://github.com/humrochagf/colordrop><b>Colordrop</b>
</a><span>theme | Made </span><span>by</span>
<a href=https://humberto.io/><b>Humberto Rocha</b></a></p></footer></div><script src=/copy/copy.js></script><script src=/search/elasticlunr.min.js></script><script src=/search/search.js></script><script>loadSearch("https://www.andyibanez.com/index.json")</script></body></html>