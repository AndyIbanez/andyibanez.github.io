<!doctype html><html prefix="og: http://ogp.me/ns#" lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,user-scalable=no"><meta http-equiv=x-ua-compatible content="ie=edge"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script><link rel=icon type=image/png href=https://www.andyibanez.com/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://www.andyibanez.com/img/favicon-16x16.png sizes=16x16><link rel=canonical href=https://www.andyibanez.com/posts/understanding-actors-in-the-new-concurrency-model-in-swift/><link rel=alternate hreflang=en href=https://www.andyibanez.com/posts/understanding-actors-in-the-new-concurrency-model-in-swift/ title><meta name=description content="Learn how to use actors in Swift to isolate mutable state and make concurrency safer."><meta name=author content><meta name=theme-color content="#292148"><meta itemprop=name content="Understanding Actors in the New Concurrency Model in Swift"><meta itemprop=description content="Learn how to use actors in Swift to isolate mutable state and make concurrency safer."><meta itemprop=datePublished content="2021-08-04T07:00:00-04:00"><meta itemprop=dateModified content="2021-08-04T07:00:00-04:00"><meta itemprop=wordCount content="3225"><meta itemprop=keywords content="swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading"><meta property="og:url" content="https://www.andyibanez.com/posts/understanding-actors-in-the-new-concurrency-model-in-swift/"><meta property="og:site_name" content="Andy Ibanez"><meta property="og:title" content="Understanding Actors in the New Concurrency Model in Swift"><meta property="og:description" content="Learn how to use actors in Swift to isolate mutable state and make concurrency safer."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-08-04T07:00:00-04:00"><meta property="article:modified_time" content="2021-08-04T07:00:00-04:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding Actors in the New Concurrency Model in Swift"><meta name=twitter:description content="Learn how to use actors in Swift to isolate mutable state and make concurrency safer."><meta name=twitter:creator content="@"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","url":"https://www.andyibanez.com/posts/understanding-actors-in-the-new-concurrency-model-in-swift/","headline":"Understanding Actors in the New Concurrency Model in Swift","description":"Learn how to use actors in Swift to isolate mutable state and make concurrency safer.","datePublished":"2021-08-04","keywords":"swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading","author":{"@type":"Person","name":""}}</script><title>Understanding Actors in the New Concurrency Model in Swift - Andy Ibanez</title><link rel=stylesheet href=https://www.andyibanez.com/style.main.min.18f604b90ed15864d7faa967f1ef9eacb99e1c967eff38762ec29b7bf1ab5876.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script></head><body><div class=wrapper><nav><div class=container><div class=language-selector></div></div></nav><header><div class=container><div class=header-group><div class=header-logo-container><a class=header-logo-link href=https://www.andyibanez.com/><img class=header-logo-circle src=https://www.andyibanez.com/img/andy_profile.png alt="Andy Ibanez logo"></a></div><div class=header-title><a href=https://www.andyibanez.com/>Andy Ibanez</a></div></div></div></header><nav><div class=container><div class=main-navigation><a href=/about/>About Me</a><a href=/posts/>Blog</a><a href=/projects/>Projects</a><a href=/tags/>Tags</a><a href=/contact/>Contact</a><a href=/privacy-policy/>Privacy policy</a></div></div></nav><div class=container><div class=search><input type=text id=searchInput placeholder="Type here to search"></div><div class="container search-results-container" hidden=true><div id=searchResults class=search-results></div></div></div><main><div class=container><article><h1 class=title>Understanding Actors in the New Concurrency Model in Swift</h1><p class=publish>Published on
<time class=post-date datetime=2021-08-04T07:00:00-04:00>August 4, 2021</time></p><p><em>This article is part of my <a href=https://www.andyibanez.com/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift Article Series</a>.</em></p><h6 id=table-of-contents>Table of Contents</h6><ol><li><a href=/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift: Introduction</a></li><li><a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a></li><li><a href=/posts/converting-closure-based-code-into-async-await-in-swift/>Converting closure-based code into async/await in Swift</a></li><li><a href=https://www.andyibanez.com/posts/structured-concurrency-in-swift-using-async-let/>Structured Concurrency in Swift: Using async let</a></li><li><a href=https://www.andyibanez.com/posts/structured-concurrency-with-group-tasks-in-swift/>Structured Concurrency With Task Groups in Swift</a></li><li><a href=https://www.andyibanez.com/posts/introduction-to-unstructured-concurrency-in-swift/>Introduction to Unstructured Concurrency in Swift</a></li><li><a href=https://www.andyibanez.com/posts/unstructured-concurrency-with-detached-tasks-in-swift/>Unstructured Concurrency With Detached Tasks in Swift</a></li><li><strong>Understanding Actors in the New Concurrency Model in Swift</strong></li><li><a href=/posts/mainactor-and-global-actors-in-swift>@MainActor and Global Actors in Swift</a></li><li><a href=posts/sharing-data-across-tasks-tasklocal-new-swift-concurrency-model>Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model</a></li><li><a href=/posts/using-asyncsequence-in-swift/>Using AsyncSequence in Swift</a></li><li><a href=/posts/modern-swift-concurrency-summary-cheatsheet-thanks/>Modern Swift Concurrency Summary, Cheatsheet, and Thanks</a></li></ol><hr><p>When we are working with concurrency, the most common problem developers face are data races. Whether it is a task updating a value at the same time another task is reading it or two tasks writing a value so that it it has an invalid value, data races are probably the main pain point of concurrency. Data races are very easy create, and hard to debug. There are entire books dedicated to the problem of data races and established patterns to avoid them.</p><p>Data races happen when there&rsquo;s shared mutable state. If you are only working with <code>let</code> variables that are never mutated, you are unlikely to encounter them. Unfortunately, even the most trivial of programs does have mutable state at some point, so racking your brain to make everything immutable is not going to yield results. In general, preferring to use <code>let</code> as much as possible and using value semantics (like <code>struct</code>s) is going to help a lot when dealing with data races.</p><p>Shared mutable state requires synchronization. In the most basic - and hardest - form, you can make use of locks (a concept that guarantees mutable state will only be modified by one process at a time) and other primitives. In the past few years, many Apple Platform developers have used serial dispatch queues, which are higher level concepts for dealing with concurrency. Going this route requires you to write all that code.</p><p>Luckily, with Swift 5.5 and the new concurrency APIs introduced at WWDC2021, Swift now has a much easier way to deal with mutable state, ensuring that only one process at a time modifies a value. Of course, this has the same implications as the other new concurrency APIs we have seen so far in this series. It iss easy to use, but may be limiting if you need more control. The good news is that the actors API is going to be enough for the vast majority of developers.</p><h1 id=introducing-actors>Introducing actors</h1><p>Actors provide synchronization for mutable state automatically, and they isolate their state from the rest of the program. This means that nobody can modify the shared state unless they go through the actor itself. Because the actor is isolated and you need to talk to it to modify values, the actor ensures that access to its state is mutually exclusive. Only one process will be able to modify its state at a time. Behind the scenes, actors will take care of the manual synchronization for you, and it will &ldquo;queue up&rdquo; processes as they attempt to modify it so they only do so one at a time.</p><h2 id=implementation-details>Implementation details</h2><p><code>actors</code> in Swift are implemented as <code>actor</code> types. Similar to how you define <code>class</code>es, <code>enum</code>s, and <code>struct</code>s, you declare an actor by using the <code>actor</code> keyword. Actors are reference types, meaning that their behaviors are more similar to <code>class</code>es than <code>struct</code>s. Which makes complete sense if you think about it, as actors are all about hiding shared <em>mutable</em> state that other types may need to access. The main differences between <code>actor</code>s and <code>class</code>es is that actors implement all the synchronization mechanisms behind the scenes, their data is isolated from the rest of the program, and <code>actor</code>s cannot inherit or be inherited from, although they can conform to protocols and be extended.</p><p>Thanks to the fact that actors are integrated deeply into the Swift compiler, Swift will do a lot to protect you against code that may run haywire due to its concurrency needs.</p><p>Consider the following example:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>Counter</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>count</span> = <span style=color:#fab387>0</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>increment</span>() -&gt; <span style=color:#89dceb>Int</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>count</span> <span style=color:#89dceb;font-weight:700>+=</span> <span style=color:#fab387>1</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> <span style=color:#89dceb>count</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>ViewController</span>: UIViewController {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>tasks</span> = [Task&lt;<span style=color:#89dceb>Void</span>, Never&gt;]()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>override</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>viewDidLoad</span>() {
</span></span><span style=display:flex><span>        <span style=color:#fab387>super</span>.viewDidLoad()
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>counter</span> = Counter()
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        tasks <span style=color:#89dceb;font-weight:700>+=</span> [
</span></span><span style=display:flex><span>            Task.detached {
</span></span><span style=display:flex><span>                <span style=color:#89dceb>print</span>(counter.increment())
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        tasks <span style=color:#89dceb;font-weight:700>+=</span> [
</span></span><span style=display:flex><span>            Task.detached {
</span></span><span style=display:flex><span>                <span style=color:#89dceb>print</span>(counter.increment())
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>(Apple uses a similar example in the <a href=https://developer.apple.com/videos/play/wwdc2021/10133/>Protect mutable state with Swift actors</a> WWDC2021 session)</em></p><p><em>Also, I originally intended to provide a sample Playground with these examples, but I couldn&rsquo;t get it to work as of Xcode 13 Beta 4, so I will provide a standard iOS project instead at the end of this article)</em></p><p>In this example, you are attempting to increment the counter variable inside <a href>detached tasks</a>. There is no locking mechanism or any synchronization that ensures that the code will work as you expect it to work. The system could increment to 0 both times, and the values that get printed can be drastically different on each turn.</p><p>We can fix it and ensure that the output is always &ldquo;1, 2&rdquo; by making <code>Counter</code> an <code>actor</code> instead of a class.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>actor Counter {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>count</span> = <span style=color:#fab387>0</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>increment</span>() -&gt; <span style=color:#89dceb>Int</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>count</span> <span style=color:#89dceb;font-weight:700>+=</span> <span style=color:#fab387>1</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> <span style=color:#89dceb>count</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Simply making this change will not be enough. Trying to compile and run it will give you this error in both places where we try to print:</p><pre tabindex=0><code>Expression is &#39;async&#39; but is not marked with &#39;await&#39;
</code></pre><p>This is beautiful, and it really shows you how deeply concurrency is implemented at the compiler level to save you from writing buggy concurrent code. It can save you from having to spend hours, days, months, or even years, learning to write concurrent code safely yourself. I absolutely love the compiler integration, because it also shows you that all the concepts we have explored throughout this series converge. The compiler is helping us make sense of everything we learned so far.</p><p>To fix that error, simply add <code>await</code> when you call <code>increment()</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#89dceb>print</span>(await counter.increment())
</span></span></code></pre></div><p>All of an <code>actor</code>&rsquo;s public interface are automatic made async for its consumers. This allows us to safely interact with actors, because using the <code>await</code> keyword will suspend execution until the code is notified that it can go into the actor next and do its job.</p><p><em>(This is a good point to stop and think if you actually understand <code>async/await</code>, which are the most basic building blocks for the new concurrency system in Swift. If you think you need a refresher, you can read the <a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a> article of this series.)</em></p><p>Do note that this has some implications when attempting to access the properties (in this case, <code>count</code>) directly. First, you can do read-only access, but it has to be done through asynchronous contexts. This therefore, will not work:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#89dceb>print</span>(counter.<span style=color:#89dceb>count</span>)
</span></span></code></pre></div><p>It will make the compiler yell at you with:</p><pre tabindex=0><code>Actor-isolated property &#39;count&#39; can only be referenced from inside the actor
</code></pre><p>This is because, just like methods, properties expose their getters as <code>async</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>async {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>count</span> = await counter.<span style=color:#89dceb>count</span>
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;count is </span><span style=color:#a6e3a1>\(</span><span style=color:#89dceb>count</span><span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, remember when we said nobody can modify the shared state in an actor without going through the actor itself? This means that the actor has to expose methods that would modify its values. You cannot modify properties of an actor directly.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>counter.<span style=color:#89dceb>count</span> = <span style=color:#fab387>3</span>
</span></span></code></pre></div><pre tabindex=0><code>Actor-isolated property &#39;count&#39; can only be mutated from inside the actor
</code></pre><h2 id=inside-the-actor>Inside the actor</h2><p>The actor will expose asynchronous code to external callers, helpfully marking everything relevant as <code>async</code>. But within the actor itself, all calls are synchronous. This will help you write more natural code within the actor as you won&rsquo;t have to worry about weird execution orders.</p><p>You can observe this yourself, add the following method to <code>Counter</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>reset</span>() {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>while</span> <span style=color:#89dceb>count</span> <span style=color:#89dceb;font-weight:700>&gt;</span> <span style=color:#fab387>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>count</span> <span style=color:#89dceb;font-weight:700>-=</span> <span style=color:#fab387>1</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Done resetting&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then, create a new function, <code>foo</code>, and typing <code>reset</code> within it. You will see that the autocomplete suggestions will suggest you autofill with <code>reset()</code>.</p><p><img src=/img/actors_foo.png alt="Calling reset() within the actor"></p><p>Whereas, if you call <code>reset</code> externally, you will see that the <code>reset()</code> method has <code>async</code> on its signature.</p><p><img src=/img/actors_reset_async.png alt="Calling reset() outside the actor">.</p><p>You can see that anything called within the actor is synchronous (as you can tell due to the lack of the <code>async</code> keyword), but calling the very same methods externally are <code>async</code>. Synchronous code on the actor <em>always</em> runs to completion without being interrupted. You will notice you cannot await on the actor&rsquo;s properties or methods, although nothing prevents the actor from calling async methods from other actors or other places.</p><h1 id=actor-reentrancy>Actor reentrancy</h1><p>While actors isolate their own state from others, they rarely work alone. They are likely to interact with other actors or with the rest of your codebase in general.</p><p>This can cause unexpected behavior. Consider the following example:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>enum</span> <span style=color:#f9e2af>ImageDownloadError</span>: Error {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>case</span> badImage
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(url: URL) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageRequest</span> = URLRequest(url: url)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (data, imageResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: imageRequest)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data), (imageResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>throw</span> ImageDownloadError.badImage
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>actor ImageDownloader {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>cache</span>: [URL: UIImage] = [:]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>image</span>(from url: URL) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = cache[url] {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = <span style=color:#cba6f7>try</span> await downloadImage(url: url)
</span></span><span style=display:flex><span>        cache[url] = image
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(url: URL) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageRequest</span> = URLRequest(url: url)
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> (data, imageResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: imageRequest)
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data), (imageResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>throw</span> ImageDownloadError.badImage
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>(This code is similar to Apple&rsquo;s ImageDownloader code from their <a href=https://developer.apple.com/videos/play/wwdc2021/10133/>Protect mutable state with Swift actors</a> WWDC2021 session, but I have created a sample you can run.</em></p><p>We have an image downloader that caches images so as to not download them again. The <code>if let</code> will check if an image is cached and return it if possible. Otherwise the code will download an image, cache it after the download, and return the newly downloaded image. But what happens if we enter here twice?</p><p>Consider the following code that uses the <code>ImageDownloader</code> actor from above:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#cba6f7>override</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>viewDidLoad</span>() {
</span></span><span style=display:flex><span>    <span style=color:#fab387>super</span>.viewDidLoad()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Task.detached {
</span></span><span style=display:flex><span>        await <span style=color:#fab387>self</span>.downloadImages()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImages</span>() async {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>downloader</span> = ImageDownloader()
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageURL</span> = URL(string:  <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part3/3.png&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>downloadedImage</span> = downloader.image(from: imageURL)
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>sameDownloadedImage</span> = downloader.image(from: imageURL)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>images</span> = [UIImage?]()
</span></span><span style=display:flex><span>    images <span style=color:#89dceb;font-weight:700>+=</span> [<span style=color:#cba6f7>try</span>? await downloadedImage]
</span></span><span style=display:flex><span>    images <span style=color:#89dceb;font-weight:700>+=</span> [<span style=color:#cba6f7>try</span>? await sameDownloadedImage]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Important Note:</strong> As of Xcode 13 Beta 4 (and all the way down to Beta 3), there is a bug that causes your code to deadlock when entering an actor twice from the same <code>Task</code> via <code>async let</code>. Apple is aware of this issue, and it will hopefully be fixed in a later beta. Until this bug is fixed, the workaround is to use <code>Task.detached</code> instead of just <code>Task</code> when using more than one <code>async let</code> binding at the same time. By the time a later Beta comes out, the GM, or the final release comes out, the bug may be fixed. Please keep that in mind as ultimately, normal <code>Task</code>s and <code>Task.detached</code> calls have different uses.</p><p>We are entering the actor via two different <code>async let</code> calls. The first call (<code>downloadedImage</code>) will enter the actor and it will execute until it finds the <code>await</code> call on <code>downloadImages</code>. It will suspend, and the second call, <code>sameDownloadedImage</code> will begin executing. Note that <code>downloadedImage</code> reached the await, and since it suspended, it hasn&rsquo;t had any time to download the image yet. And because the image is not in the cache, <code>sameDownloadedImage</code> will also download the image instead of retrieving it from memory. If you are <em>really unlucky</em>, the server may have updated the image behind the same URL, so <code>downloadedImage</code> and <code>sameDownloadedImage</code> may download different things!</p><p>The problem is we are assuming the program state <em>after</em> the await call. It&rsquo;s like we are telling the program &ldquo;Hey, you will download the image, cache it, and anyone else who access it, will grab the cached version&rdquo;. But in reality, it&rsquo;s impossible to make this guarantee with this code, because there may be different calls attempting to access the actor at the same time, and thus we have this bug that hits the network twice for the same image.</p><p>To work around this, we can make our actor keep the state of each download, and access that state first-thing before our actor tries to download an image:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>actor ImageDownloader {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>enum</span> <span style=color:#f9e2af>ImageStatus</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>case</span> downloading(<span style=color:#fab387>_</span> task: Task&lt;UIImage, Error&gt;)
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>case</span> downloaded(<span style=color:#fab387>_</span> image: UIImage)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>cache</span>: [URL: ImageStatus] = [:]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>image</span>(from url: URL) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageStatus</span> = cache[url] {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>switch</span> imageStatus {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>case</span> .downloading(<span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>task</span>):
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> await task.value
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>case</span> .downloaded(<span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span>):
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>task</span> = Task {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>try</span> await downloadImage(url: url)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        cache[url] = .downloading(task)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>do</span> {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = <span style=color:#cba6f7>try</span> await task.value
</span></span><span style=display:flex><span>            cache[url] = .downloaded(image)
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>        } <span style=color:#cba6f7>catch</span> {
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// If an error occurs, we will evict the URL from the cache</span>
</span></span><span style=display:flex><span>            <span style=color:#6c7086;font-style:italic>// and rethrow the original error.</span>
</span></span><span style=display:flex><span>            cache.removeValue(forKey: url)
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>throw</span> error
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(url: URL) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageRequest</span> = URLRequest(url: url)
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> (data, imageResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: imageRequest)
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data), (imageResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>throw</span> ImageDownloadError.badImage
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>This code is similar to the code provided by Apple in the <a href=https://developer.apple.com/wwdc21/10133>Protect mutable state with Swift actors</a> WWDC2021 session.</em></p><p>This looks like a mouthful, but it&rsquo;s very straightforward (and straightforwardness is the power of the new concurrency APIs!). We start by declaring an enum that will hold the state for the current URL. When a URL is downloaded for the first time, we will add this URL to the cache with a <code>.downloading</code> status. If any other call is made to the actor with the same URL at the same time, it will see the image is in the cache, so rather than downloading the image again, it will directly <code>await</code> on it. Calls made in a farther future will likely see an already downloaded image, so they will return immediately. When the image finishes downloading for the first (and) last time. the image is cached with a <code>.downloaded</code> status.</p><p>Actor reentrancy prevents deadlocks and guarantees forward progress, but it is necessary that you check your assumptions so as to prevent any other bugs that are not necessarily related to concurrency, such as downloading the same image more than once. Here&rsquo;s a few points to make sure you play with the actor reentrancy concept well:</p><ul><li>Make mutations in synchronous code. You can see that we mutate our cache in the same task, and we are not attempting to update it anywhere else.</li><li>Know that state can change at any point after you hit an <code>await</code>. You may need to manually check for some state to determine how it has changed so you can respond to it if necessary.</li></ul><h1 id=actor-isolation>Actor isolation</h1><p>Actors are all about isolation. Their main purpose is to isolate their state from others, so they can manage access to their own properties, ensuring that multiple writes are performed at the same time, which could leave your program in an unexpected state.</p><p>Immutable properties can be accessed at any time.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>actor DollMaker {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>id</span>: <span style=color:#89dceb>Int</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>dolls</span>: [Doll] = []
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>init</span>(id: <span style=color:#89dceb>Int</span>) {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.id = id
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>extension</span> <span style=color:#f9e2af>DollMaker</span>: <span style=color:#89dceb>Equatable</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>static</span> <span style=color:#f38ba8>func</span> ==(<span style=color:#fab387>_</span> lhs: DollMaker, rhs: DollMaker) -&gt; <span style=color:#89dceb>Bool</span> {
</span></span><span style=display:flex><span>        lhs.id == rhs.id
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the code above, the <code>==</code> operator compares two types, and it is a <code>static</code> method. <code>static</code> means that this method is &ldquo;outside&rdquo; of the actor (there&rsquo;s no <code>self</code> instance). Combine that with the fact we only access immutable state within the method, and the compiler knows this is a safe thing to do.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>extension</span> <span style=color:#f9e2af>DollMaker</span>: <span style=color:#89dceb>Hashable</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>hash</span>(into hasher: <span style=color:#cba6f7>inout</span> Hasher) {
</span></span><span style=display:flex><span>        hasher.combine(id)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>On the other hand, this is getting into murky waters. While we also only reference the <code>id</code> field, this method is an instance method. It is supposed to be <code>async</code> to be isolated. Luckily, in this case, we can explicitly mark the method as <code>nonisolated</code> to let the compiler know this is not isolated. The compiler will treat this method as being &ldquo;outside&rdquo; the actor, and move on, as long as you only access immutable properties inside of it. If the hasher was using the <code>dolls</code> property instead of <code>id</code>, this wouldn&rsquo;t work as <code>dolls</code> is mutable.</p><h1 id=the-sendable-type>The Sendable Type</h1><p>The concurrency model also introduces <code>Sendable</code> types. <code>Sendable</code> types are those that can be shared concurrently safely. The following are some examples of types that are <code>Sendable</code>:</p><ul><li>Value types (such as structs)</li><li>Actor types</li></ul><p>Classes can be <code>Sendable</code> but only if they are immutable or if they provide their own synchronization within themselves. <code>Sendable</code> classes are exceptional.</p><p>It is recommended that your concurrent code communicates using <code>Sendable</code> types. At some point, Swift will be able to check, at compile time, if you are sharing non <code>Sendable</code> types across functions, but this doesn&rsquo;t appear to be the case as of Xcode 13, Beta 4.</p><h2 id=the-sendable-protocol>The Sendable Protocol</h2><p>You probably guessed it, but the way we make types <code>Sendable</code> is by making our types conform to the <code>Sendable</code> protocol. Just by specifying the conformance, the Swift compiler will do a lot of work for us.</p><p>Consider the following example:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>Videogame</span>: Sendable {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>title</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>VideogameMaker</span>: Sendable {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>name</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>games</span>: [Videogame]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This will compile without an issue, because <code>VideogameMaker</code> is sendable, and so is <code>Videogame</code>.</p><p>For structs, you can avoid conforming to <code>Sendable</code>, and it will still work:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>Videogame</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>title</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>VideogameMaker</span>: Sendable {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>name</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>games</span>: [Videogame]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But this is not the case with classes.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>Videogame</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>title</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>init</span>(title: <span style=color:#89dceb>String</span>) {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.title = title
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>VideogameMaker</span>: Sendable {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>name</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>games</span>: [Videogame]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You will get an error like this:</p><pre tabindex=0><code>Stored property &#39;games&#39; of &#39;Sendable&#39;-conforming struct &#39;VideogameMaker&#39; has non-sendable type &#39;[Videogame]&#39;
</code></pre><h2 id=sendable-and-generics>Sendable and generics</h2><p>A Generic type can be <code>Sendable</code> only if its all properties are <code>Sendable</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>Pair</span>&lt;T, U&gt; {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>first</span>: T
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>second</span>: T
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>extension</span> <span style=color:#f9e2af>Pair</span>: Sendable <span style=color:#cba6f7>where</span> T: Sendable, U: Sendable {}
</span></span></code></pre></div><h2 id=sendable-functions>Sendable functions</h2><p>For functions that can be passed across actors, they can be made marked as <code>@Sendable</code>.</p><p>When it comes to closures, marking them as <code>@Sendable</code> impose some restrictions. They cannot capture mutable variables from their surrounding scope, everything they capture must be <code>Sendable</code>, and finally, they cannot be both asynchronous and actor isolated.</p><h1 id=conclusion>Conclusion</h1><p>A sample project for the image download can be downloaded from <a href=/archives/Actors.zip>here</a>.</p><p>In this article we explored what actors are and how to use them. We learned that an actor isolates its own state and all write access to its properties must be done through the actor itself. By isolating their own state, actors provide concurrency safety.</p><p>We also learned about <code>Sendable</code> types and how they are crucial to the new concurrency system in Swift. Sendable types help provide compile-time checks to write concurrent code. As they provide static checking, it&rsquo;s very hard to write incorrect code that breaks the concurrency model or introduces concurrency bugs.</p></article></div></main><footer><div class=container><div class=footer-navigation><a href=https://github.com/AndyIbanez><span class=inline-svg><svg viewBox="0 0 42 40" id="svg4" width="42" height="40"><path fill="currentColor" d="m14.20936 32.20794c0 .16542-.19024.29776-.4301.29776-.27295.0248-.46319-.10752-.46319-.29776.0-.16542.19024-.29776.4301-.29776.24814-.0248.46319.10752.46319.29776zm-2.57234-.3722c-.0579.16542.10753.35566.35566.40528.21505.0827.46319.0.51282-.16542.0496-.16542-.10753-.35566-.35566-.4301-.21505-.0579-.45492.0248-.51282.19024zm3.65586-.14061c-.23986.0579-.40529.21505-.38047.40528.0248.16543.23986.27295.488.21505.23986-.0579.40528-.21505.38047-.38047-.0248-.15715-.24813-.26468-.488-.23986zM20.73531-.19734273e-6C9.2632-.19734273e-6.48748 8.7095398.48748 20.18166c0 9.17273 5.77328 17.02207 14.01964 19.78464 1.05871.19024 1.43091-.46319 1.43091-1.00081.0-.51282-.0248-3.34156-.0248-5.0785.0.0-5.78982 1.24067-7.00568-2.46481.0.0-.94292-2.40691-2.29939-3.02725.0.0-1.8941-1.29857.13234-1.27376.0.0 2.05952.16542 3.19267 2.13396 1.81139 3.19267 4.84691 2.27457 6.02969 1.72868.19023-1.32339.72786-2.24149 1.32338-2.78739-4.62358-.51281-9.28852-1.18278-9.28852-9.13964.0-2.27458.62861-3.416 1.95199-4.87172-.21505-.53763-.9181-2.7543.21506-5.6161302 1.72867-.53762 5.7071 2.2332202 5.7071 2.2332202 1.65424-.46319 3.43254-.70305 5.1943-.70305 1.76176.0 3.54006.23986 5.1943.70305.0.0 3.97843-2.7791202 5.7071-2.2332202 1.13315 2.8701002.4301 5.0785002.21505 5.6161302 1.32339 1.46399 2.13397 2.60542 2.13397 4.87172.0 7.98168-4.87172 8.61856-9.49531 9.13964.76095.65342 1.4061 1.8941 1.4061 3.83782.0 2.78739-.0248 6.23647-.0248 6.9147.0.53763.38047 1.19105 1.43091 1.00082 8.27117-2.74603 13.87903-10.59537 13.87903-19.7681C41.51252 8.7095398 32.20745-.19734273e-6 20.73533-.19734273e-6zM8.52706 28.52727c-.10752.0827-.0827.27295.0579.4301.13234.13234.32258.19024.4301.0827.10753-.0827.0827-.27295-.0579-.4301-.13233-.13234-.32257-.19024-.4301-.0827zM7.63378 27.8573c-.0579.10753.0248.23987.19023.32258.13234.0827.29777.0579.35566-.0579C8.23757 28.01446 8.15487 27.88212 7.98944 27.7994 7.82401 27.7498 7.69168 27.7746 7.63378 27.8573zm2.67986 2.94454c-.13234.10753-.0827.35566.10752.51281.19024.19024.4301.21505.53763.0827.10752-.10752.0579-.35566-.10753-.51281-.18196-.19024-.4301-.21505-.53762-.0827zM9.37072 29.58598c-.13234.0827-.13234.29776.0.488.13234.19023.35566.27295.46319.19023.13234-.10752.13234-.32257.0-.51281-.1158-.19024-.33085-.27295-.46319-.16542z" id="path2" style="stroke-width:.08271171"/></svg>
</span></a><a href=https://x.com/AndyIbanezK><span class=inline-svg><svg viewBox="0 0 50 40" id="svg4" width="50" height="40"><path fill="currentColor" d="m44.56253 9.96871c.0313.43748.0313.87506.0313 1.31254C44.59383 24.62494 34.43764 40 15.87508 40 10.1563 40 4.84383 38.34368.37506 35.4688c.81253.0937 1.5937.12495 2.4375.12495 4.71867.0 9.06249-1.5937 12.53125-4.31245-4.43751-.0938-8.15627-3.00003-9.43754-7.00006.62505.0937 1.25001.15622 1.90632.15622.90622.0 1.81254-.12505 2.65624-.34369C5.84384 23.15619 2.37498 19.09373 2.37498 14.18748v-.12495c1.3437.75 2.90633 1.21875 4.56246 1.28117-2.71876-1.81253-4.49993-4.90624-4.49993-8.40627.0-1.87497.4999-3.59372 1.37496-5.09373 4.96877 6.125 12.43756 10.12493 20.81248 10.56251-.15622-.75001-.25-1.53118-.25-2.31245C24.37495 4.5312 28.87498.0 34.46871.0c2.90623.0 5.53121 1.21875 7.37501 3.1875 2.28118-.43748 4.46867-1.28127 6.40626-2.43749-.75011 2.3438-2.34381 4.31255-4.43751 5.56246 2.03127-.21864 4.00003-.78126 5.81247-1.56244-1.37477 1.99992-3.09362 3.7811-5.06237 5.21868z" id="path2" style="stroke-width:.09619153"/></svg>
</span></a><a href=https://www.linkedin.com/in/andyibanez/><span class=inline-svg><svg viewBox="0 0 41 40" id="svg4" width="41" height="40"><path fill="currentColor" d="M9.45332 40H1.16028V13.29405H9.45332zM5.30234 9.65111c-2.65185.0-4.80279-2.19648-4.80279-4.84832a4.80279 4.80279.0 019.60558.0c0 2.65184-2.15184 4.84832-4.80279 4.84832zM40.49152 40H32.21633V26.99971c0-3.09828-.0625-7.07159-4.3117-7.07159-4.3117.0-4.97243 3.36615-4.97243 6.84837V40H14.64808V13.29405h7.95375v3.64294h.11608c1.10716-2.09827 3.81169-4.3126 7.8466-4.3126 8.39304.0 9.93594 5.52691 9.93594 12.70564V40z" id="path2" style="stroke-width:.08928771"/></svg>
</span></a><a href=https://www.andyibanez.com/blog/index.xml><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m11.435816 34.282008c0 3.15793-2.5599899 5.71793-5.7179299 5.71793s-5.717840022654-2.56-5.717840022654-5.71793c0-3.15794 2.559990022654-5.71793 5.717930022654-5.71793s5.7178399 2.56008 5.7178399 5.71793zm15.68388 4.21873C26.373806 24.697208 15.317496 13.626978 1.4992361 12.880288.68361608 12.836188.46077346e-4 13.491538.46077346e-4 14.308318v4.29186c0 .75134.579460002654 1.38142 1.329190022654 1.43017 9.9849699.65036 17.9886099 8.63408 18.6402999 18.6403.0488.74973.67893 1.3292 1.43018 1.3292h4.29186c.81687 9e-5 1.47223-.68348 1.42812-1.49911zm12.87933.0257C39.249566 17.649718 22.452206.754048 1.4735261.00092799867.66727608-.027972.46077346e-4.623338.46077346e-4 1.430038v4.29177c0 .77008.610270002654 1.39687 1.379730022654 1.42848 17.0694999.6999 30.7701699 14.40316 31.4699899 31.46999.0315.76946.6583 1.37972 1.42848 1.37972h4.29177c.8066-8e-5 1.45794-.66731 1.42901-1.47356z" id="path2" style="stroke-width:.08928544"/></svg>
</span></a><a href=https://www.andyibanez.com/curriculum/><span class=inline-svg><svg viewBox="0 0 15680 20480" id="svg4" width="35" height="40"><path fill="currentColor" d="M11655.83 12824.48 7840.0001 16640.464 4024.17 12824.48c-2859.863 123.906-5143.7701 2463.775-5143.7701 5352.003v384.005c0 1059.853 859.96601 1919.512 1919.92167 1919.512H14879.678c1059.956.0 1919.922-859.659 1919.922-1919.512v-384.005c0-2888.228-2283.906-5228.097-5143.77-5352.003zM-575.64445 3193.1279l256.0032 59.9048v2335.7732c-279.9651 167.9381-479.9548 459.7818-479.9548 812.0422.0 335.8762 183.9639 615.9437 443.96075 787.9778l-623.9822 2491.9352c-67.9944 275.9716 84.02025 559.6229 303.9782 559.6229H996.31762c219.95798.0 371.97268-283.6513 303.97828-559.6229L676.31362 7188.8259c259.99685-172.0341 443.96078-452.1016 443.96078-787.9778.0-352.2604-199.98973-644.1041-479.95483-812.0422V3484.9716l2639.90503 635.9119c-344.0171 688.1366-559.9814 1456.1463-559.9814 2279.9646.0 2827.8113 2291.8942 5119.5519 5119.7569 5119.5519 2827.8619.0 5119.7569-2291.7406 5119.7569-5119.5519.0-823.8183-211.971-1591.828-559.982-2279.9646l3851.824-927.7556c727.971-176.1302 727.971-1083.9175.0-1260.0477L8635.9653 92.929226c-519.9937-123.905551-1067.943-123.905551-1587.9367.0L-575.64445 1928.9841c-723.92585 176.1302-723.92585 1088.0136.0 1264.1438z" id="path2" style="stroke-width:39.99821472"/></svg>
</span></a><a href=https://www.andyibanez.com/contact-me><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m39.99999 36.249999c0 2.0711-1.6789 3.75-3.74999 3.75H3.75c-2.07109.0-3.74999-1.6789-3.74999-3.75v-20.56843a3.7499996 3.7499996.0 011.43648-2.95125c1.94633-1.5257 3.55476-2.7628904 12.82812-9.4930404C15.57906 2.2789186 18.18727-.02709136 20 .00024864227 21.81234-.02745136 24.42156 2.2793086 25.73539 3.2371986c9.27242 6.72945 10.88304 7.9683604 12.82812 9.4931204a3.7499996 3.7499996.0 011.43648 2.95125zm-5.13015-15.35976c-.20024-.29125-.60156-.35898-.88586-.14898-1.78476 1.3182-4.33297 3.18008-8.24859 6.02179-1.31445.95828-3.92266 3.26414-5.73539 3.23672-1.81336.0269-4.41867-2.2768-5.73539-3.23672-3.91515-2.8414-6.46359-4.70343-8.24859-6.02179-.2843-.21-.68562-.14227-.88586.14898l-.70875 1.03094a.62484368.62484368.0 00.14367.8568c1.78805 1.32023 4.33235 3.1789 8.2268 6.00531 1.5839 1.15476 4.41593 3.73539 7.20812 3.71664 2.79094.0189 5.62195-2.56024 7.20804-3.71664 3.89453-2.82649 6.43891-4.68516 8.2268-6.00531a.62484368.62484368.0 00.14367-.8568z" id="path2" style="stroke-width:.07812498"/></svg></span></a></div></div><p class=made-with-love><a href=https://github.com/humrochagf/colordrop><b>Colordrop</b>
</a><span>theme | Made </span><span>by</span>
<a href=https://humberto.io/><b>Humberto Rocha</b></a></p></footer></div><script src=/copy/copy.js></script><script src=/search/elasticlunr.min.js></script><script src=/search/search.js></script><script>loadSearch()</script></body></html>