<!doctype html><html prefix="og: http://ogp.me/ns#" lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,user-scalable=no"><meta http-equiv=x-ua-compatible content="ie=edge"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script><link rel=apple-touch-icon sizes=180x180 href=https://www.andyibanez.com/favicons/apple-touch-icon-180x180.png><link rel=icon type=image/png sizes=32x32 href=https://www.andyibanez.com/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.andyibanez.com/favicons/favicon-16x16.png><link rel=manifest href=https://www.andyibanez.com/favicons/site.webmanifest><link rel=mask-icon href=https://www.andyibanez.com/favicons/safari-pinned-tab.svg color=#292148><meta name=msapplication-TileColor content="#292148"><meta name=msapplication-config content="https://www.andyibanez.com/favicons/browserconfig.xml"><meta name=theme-color content="#292148"><link rel=canonical href=https://www.andyibanez.com/posts/structured-concurrency-in-swift-using-async-let/><link rel=alternate hreflang=en href=https://www.andyibanez.com/posts/structured-concurrency-in-swift-using-async-let/ title><meta name=description content="Get started using structured concurrency in Swift using async let tasks."><meta name=author content><meta name=theme-color content="#292148"><meta itemprop=name content="Structured Concurrency in Swift: Using async let"><meta itemprop=description content="Get started using structured concurrency in Swift using async let tasks."><meta itemprop=datePublished content="2021-06-30T07:00:00-04:00"><meta itemprop=dateModified content="2021-06-30T07:00:00-04:00"><meta itemprop=wordCount content="2685"><meta itemprop=keywords content="swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading"><meta property="og:url" content="https://www.andyibanez.com/posts/structured-concurrency-in-swift-using-async-let/"><meta property="og:site_name" content="Andy Ibanez"><meta property="og:title" content="Structured Concurrency in Swift: Using async let"><meta property="og:description" content="Get started using structured concurrency in Swift using async let tasks."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-30T07:00:00-04:00"><meta property="article:modified_time" content="2021-06-30T07:00:00-04:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta name=twitter:card content="summary"><meta name=twitter:title content="Structured Concurrency in Swift: Using async let"><meta name=twitter:description content="Get started using structured concurrency in Swift using async let tasks."><meta name=twitter:creator content="@"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","url":"https://www.andyibanez.com/posts/structured-concurrency-in-swift-using-async-let/","headline":"Structured Concurrency in Swift: Using async let","description":"Get started using structured concurrency in Swift using async let tasks.","datePublished":"2021-06-30","keywords":"swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading","author":{"@type":"Person","name":""}}</script><title>Structured Concurrency in Swift: Using async let - Andy Ibanez</title><link rel=stylesheet href=https://www.andyibanez.com/style.main.min.18f604b90ed15864d7faa967f1ef9eacb99e1c967eff38762ec29b7bf1ab5876.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script></head><body><div class=wrapper><nav><div class=container><div class=language-selector></div></div></nav><header><div class=container><div class=header-group><div class=header-logo-container><a class=header-logo-link href=https://www.andyibanez.com/><img class=header-logo-circle src=https://www.andyibanez.com/img/andy_profile.png alt="Andy Ibanez logo"></a></div><div class=header-title><a href=https://www.andyibanez.com/>Andy Ibanez</a></div></div></div></header><nav><div class=container><div class=main-navigation><a href=/about/>About Me</a><a href=/posts/>Blog</a><a href=/projects/>Projects</a><a href=/tags/>Tags</a><a href=/contact/>Contact</a><a href=/privacy-policy/>Privacy policy</a></div></div></nav><div class=container><div class=search><input type=text id=searchInput placeholder="Type here to search"></div><div class="container search-results-container" hidden=true><div id=searchResults class=search-results></div></div></div><main><div class=container><article><h1 class=title>Structured Concurrency in Swift: Using async let</h1><p class=publish>Published on
<time class=post-date datetime=2021-06-30T07:00:00-04:00>June 30, 2021</time></p><p><em>This article is part of my <a href=/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift</a> article series.</em></p><p><em>This article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.</em></p><h6 id=table-of-contents>Table of Contents</h6><ol><li><a href=/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift: Introduction</a></li><li><a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a></li><li><a href=/posts/converting-closure-based-code-into-async-await-in-swift/>Converting closure-based code into async/await in Swift</a></li><li><strong>Structured Concurrency in Swift: Using async let</strong></li><li><a href=/posts/structured-concurrency-with-group-tasks-in-swift/>Structured Concurrency With Task Groups in Swift</a></li><li><a href=/posts/introduction-to-unstructured-concurrency-in-swift/>Introduction to Unstructured Concurrency in Swift</a></li><li><a href=/posts/unstructured-concurrency-with-detached-tasks-in-swift/>Unstructured Concurrency With Detached Tasks in Swift</a></li><li><a href=/posts/understanding-actors-in-the-new-concurrency-model-in-swift/>Understanding Actors in the New Concurrency Model in Swift</a></li><li><a href=/posts/mainactor-and-global-actors-in-swift/>@MainActor and Global Actors in Swift</a></li><li><a href=posts/sharing-data-across-tasks-tasklocal-new-swift-concurrency-model>Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model</a></li><li><a href=/posts/using-asyncsequence-in-swift/>Using AsyncSequence in Swift</a></li><li><a href=/posts/modern-swift-concurrency-summary-cheatsheet-thanks/>Modern Swift Concurrency Summary, Cheatsheet, and Thanks</a></li></ol><hr><p><em>Understanding async/await is a pre-requisite to read this article. If you aren&rsquo;t familiar with that concept, feel free to read the first part of this article series: <a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a>.</em></p><p><code>async/await</code> are the most important concepts when it comes to the new concurrency system in Swift. Understanding async/await will open you the doors to perform multiple tasks in parallel with a clean syntax and straightforward code.</p><p>There are actually <a href=https://www.andyibanez.com/posts/multithreading-options-on-apple-platforms/>multiple ways to do this</a>, but the way Apple has given us at WWDC2021 with Swift 5.5 is the safest one to use, and unless you have highly specific needs, probably the one you will use almost exclusively.</p><h1 id=introducing-structured-concurrency>Introducing Structured Concurrency.</h1><p>In previous articles, we have discussed how callback-based code can be messy to manage when used in concurrent contexts. For that reason, Apple gave us <code>async/await</code>, which is a set of keywords that can help us write concurrent code while keeping a linear flow in our code. This code can be read from top to bottom. However, in <a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a>, we noted that by just using async/await it doesn&rsquo;t mean that we will perform more than one task at once (the tasks we call may do so internally, though). We will now begin executing some code in parallel, and we will start with the concept of <em>Structured Concurrency</em>.</p><p>The ideas behind structured concurrency are based on the same ideas as structured programming. We write structured code the vast majority of the time, so you never think about it. Structured code can be read from top to bottom, following a linear flow, in a way that outputs are predictable and code is executed in the exact given order. When using variables, they have a well-defined lifetime within the block they are declared in. In callback-based concurrency, you fire off tasks in different threads or contexts as your main thread keeps executing, creating the potential to alter the output of your program every time it&rsquo;s run. If you are writing Objective-C, you need to treat your variables as <code>__block</code> in order to modify them within a block. This creates a labyrinth of code where everything can happen in any order in order to give you the result you want.</p><p>Now, consider the following functions:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = <span style=color:#cba6f7>try</span> await downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span> await downloadMetadata(<span style=color:#cba6f7>for</span>: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> DetailedImage(image: image, metadata: metadata)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.png&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageRequest</span> = URLRequest(url: imageUrl)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (data, imageResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: imageRequest)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data), (imageResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>throw</span> ImageDownloadError.badImage
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadMetadata</span>(<span style=color:#cba6f7>for</span> id: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; ImageMetadata {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>id<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.json&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataRequest</span> = URLRequest(url: metadataUrl)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (data, metadataResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: metadataRequest)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> (metadataResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>throw</span> ImageDownloadError.invalidMetadata
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> JSONDecoder().decode(ImageMetadata.<span style=color:#fab387>self</span>, from: data)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>ImageMetadata</span>: Codable {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>name</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>firstAppearance</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>year</span>: <span style=color:#89dceb>Int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>DetailedImage</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span>: UIImage
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span>: ImageMetadata
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>enum</span> <span style=color:#f9e2af>ImageDownloadError</span>: Error {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>case</span> badImage
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>case</span> invalidMetadata
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>downloadImageAndMetadata</code> is a function that will download an image alongside its metadata, all wrapped in a <code>DetailedImage</code> object. To perform the download, it will call a <code>downloadImage</code> function which will download the image itself, and a <code>downloadMetadata</code> function which will download the metadata. Let&rsquo;s inspect <code>downloadImageAndMetadata</code> a little bit deeper.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = <span style=color:#cba6f7>try</span> await downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span> await downloadMetadata(<span style=color:#cba6f7>for</span>: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> DetailedImage(image: image, metadata: metadata)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The downloads take place sequentially, which is exactly what you want most of the time. The function will download the image first, and the metadata later, one at a time. This is great in many cases, but there are times when the tasks don&rsquo;t have any dependencies with each other and it&rsquo;s therefore possible to execute them concurrently.</p><p>In this example, the image download and metadata download are two independent tasks, so we can give the function a little push to download both at the same time and therefore finish earlier.</p><p>Before we move on, think about how you would do this with closure-based code. First, you would need to launch two <code>URLSession</code> data tasks, each with its own completion handler. But then what? How will the tasks coordinate the completion for this task? What happens if the image downloads first? What happens if the metadata finishes first? How are we gonna &ldquo;lock&rdquo; and guarantee access and that the final completion handler is called?</p><p>In truth, doing this task with pure closure-based code (and even with delegate-based code), it becomes pretty messy real quick. And we are just talking about a measly <em>two</em> tasks at once!</p><p>In Swift, we have two ways to work with structured concurrency:</p><ul><li><code>async let</code></li><li>Task groups</li></ul><p>This article will be limited to <code>async let</code>, but we will cover Task groups in a future article.</p><h2 id=understanding-tasks>Understanding tasks</h2><p>Tasks are the underlying mechanism in which Swift executes your code in parallel. Each task provides a new async context in which it can execute concurrently, alongside other tasks. They will run in parallel automatically as long as it is safe and efficient to do so.</p><p>Our <code>downloadImageAndMetadata</code> function does not actually create any tasks. Both downloads are <code>await</code>ed and this is why they don&rsquo;t run in parallel. We will solve this.</p><p>These new concurrency features are deeply integrated into Swift, so as you go along writing concurrent code, the compiler will be there to stop you from introducing common concurrency bugs. I imagine this will be frustrating for new programmers as they will be reported as compiler errors, but in reality, Swift is doing its best to protect you and your code from doing anything crazy. After all, concurrency is a very hard problem to solve. If you have read a book on operating systems you have probably seen that there&rsquo;s multiple patterns developers can make use of in order to write safe concurrent code. But writing this code manually is hard, error prone, and depending on the context, hard to test. Having these checks at compile time is a great security feature.</p><p>Marking a function as <code>async</code> does not mean a new task will be created - if anything, by default, when the compiler sees a function marked as <code>async</code>, it expects it to be <code>await</code>ed on each call. Creating tasks is not an automatic process. We can inform the compiler that we want to run concurrent code, but it will be up to it to honor your request. Tasks are always created explicitly.</p><p>Structured concurrency is about a balance between simplicity and flexibility. You will be able to do a lot - if not all - of your concurrency work under these constraints, but always remember that if you need even more flexibility, you will find a lower level API that gives you the control you need, but with less safety. Check out my <a href=https://www.andyibanez.com/posts/multithreading-options-on-apple-platforms/>Multithreading Options on Apple Platforms</a> article to see an overview of the alternatives.</p><h2 id=introducing-async-let>Introducing async let</h2><p>Using <code>async let</code>, also called a <em>concurrent binding</em>, will launch a task in parallel.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>result</span> = <span style=color:#6c7086;font-style:italic>//... an async function call (without await)</span>
</span></span></code></pre></div><p>When Swift finds an <code>async let</code>, the function to the right side of the equals will begin executing concurrently. That is, where an <code>await</code> call would suspend execution of your program there, an <code>async let</code> will launch the task but it will continue executing the code underneath it until its value is needed.</p><p>Consider the following example:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageConcurrentlyWhilePrinting</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;One lint prints&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;We will begin downloading now&#34;</span>)
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Another line prints until we have the image&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Keep on printing&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> await image
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You will notice that all the <code>print</code> statements are executed basically instantly. This is because <code>async let</code> has launched <code>downloadImage</code> as another task. The two <code>print</code> statements prior to the <code>async let</code> call will be executed as you would expect. The other print statements will print just as quickly because <code>downloadImage</code> is not an <code>await</code>ed call. By the time we reach <code>return try await image</code>, we are telling our program to suspend on the return statement until the image is done downloading (or if an error is thrown).</p><p>Because this is one of the mechanisms that will allow us to execute code concurrently, you can have multiple <code>async let</code> calls at any given point, and the system will execute them concurrently if possible.</p><p>We can now rewrite our <code>downloadImageAndMetadata</code> function to download both the image and the metadata at the same time.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = downloadMetadata(<span style=color:#cba6f7>for</span>: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> DetailedImage(image: await image, metadata: await metadata)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Note</strong>: <em>The session most of this article is based on, <a href=https://developer.apple.com/videos/play/wwdc2021/10134/>Explore structured concurrency in Swift</a>, uses a similar example to this, but you can run and play with this one.</em></p><p>By appending <code>async</code> before <code>let</code> and moving the <code>await</code> keyword to the place where we expect values to exist, we have successfully downloaded multiple things at once, using a structured flow. That&rsquo;s really neat!</p><p>And that&rsquo;s it. That&rsquo;s how you can execute code concurrently with the new async/await APIs. This article is not over yet, though. Before we are done, we need to explore a very important concept: The Task Tree.</p><h3 id=the-task-tree>The Task Tree</h3><p>Structured Concurrency makes use of a concept called <strong>The Task Tree</strong>. The task tree is a hierarchy that our structured concurrency code runs on. The task tree influences attributes of our tasks such as cancellation, priority, and local variables. When we jump from one async function to another, the same task is used to execute the new call.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = downloadMetadata(<span style=color:#cba6f7>for</span>: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> DetailedImage(image: await image, metadata: await metadata)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When we call <code>downloadImageAndMetadata</code>, it will inherit all the attributes from the parent task. Each call to <code>async let</code> will create a new task - this task is the <em>child task</em> of the task the current function is running on.</p><p><img src=/img/async_let_diagram.png alt="async let diagram"></p><p>Our <code>downloadImageAndMetadata</code> function can potentially span two child tasks: One for the image, and one for the metadata, and all this code will (again potentially) be running at the same time.</p><p><code>downloadImageAndMetadata</code> will inherit the attributes of whatever task it&rsquo;s running on, and <code>downloadImage</code> and <code>downloadMetadata</code> will in turn inherit the properties from <code>downloadImageAndMetadata</code>.</p><p>It&rsquo;s important to note that tasks are not children of the <em>functions</em> they are running on, although their lifetimes may be tied to them.</p><p>The task tree enforces a very important rule: <strong>A parent task can only finish its work as long as all the children have finished their work.</strong></p><p>You can see this enforcement because the <code>await</code> calls won&rsquo;t let the execution continue until they are given the green light to continue. Both <code>downloadImage</code> and <code>downloadMetadata</code> may throw an error or return a value, but in either case, they finish their work before the code that requires them can continue executing.</p><p>The normal case for <code>downloadImageAndMetadata</code> is that <code>downloadImage</code> and <code>downloadMetadata</code> will both finish successfully. But what happens if one of them throws an error and the other finishes without a hitch?</p><p>The great thing is that you can see, intuitively, and thanks to the fact that the code is <em>structured</em> and runs from top to bottom, that whenever one of them throws an error, <code>downloadImageAndMetadata</code> will throw the same error. But what happens to the actual execution of the other task? That is, suppose <code>downloadMetadata</code> fails and <code>downloadImage</code> is downloading a big image. What happens to the image download?</p><p>When a task fails, Swift will mark the remaining child tasks as <code>cancelled</code>. In this example, since <code>downloadMetadata</code> failed, <code>downloadImage</code> will be marked as cancelled. Marking a task as <code>cancelled</code> does not actually mean that the task is cancelled. Instead, it simply notifies the task that its results are no longer needed. All the child tasks and their descendants will be cancelled when their parent is cancelled.</p><p>But when do the tasks actually stop their execution? This is a neat property of structured tasks: cancellation is cooperative. Tasks do not stop immediately. Instead, they will do it as soon as they see it is appropriate. If you have network calls going, it may be inappropriate to just stop them the moment they get the cancel notification.</p><p>Tasks have to check for cancellation explicitly. You can check for cancellation from anywhere. This makes it your responsibility to design your code with cancellation in mind, especially if you have tasks that can take a very long time to complete.</p><p>There are two ways to check for cancellation. First, you can call <code>try Task.checkCancellation()</code> when your functions are marked as <code>throws</code>. And second, there is a <code>Task.isCancelled</code> which returns a boolean when your tasks are not running inside <code>throw</code>ing contexts.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>try</span> Task.checkCancellation()
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part3/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.png&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageRequest</span> = URLRequest(url: imageUrl)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (data, imageResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: imageRequest)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data), (imageResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>throw</span> ImageDownloadError.badImage
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadMetadata</span>(<span style=color:#cba6f7>for</span> id: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; ImageMetadata {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>try</span> Task.checkCancellation()
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part3/</span><span style=color:#a6e3a1>\(</span>id<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.json&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataRequest</span> = URLRequest(url: metadataUrl)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (data, metadataResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: metadataRequest)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> (metadataResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>throw</span> ImageDownloadError.invalidMetadata
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> JSONDecoder().decode(ImageMetadata.<span style=color:#fab387>self</span>, from: data)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = downloadMetadata(<span style=color:#cba6f7>for</span>: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> DetailedImage(image: await image, metadata: await metadata)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// NEW FUNCTION</span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadMultipleImagesWithMetadata</span>(images: <span style=color:#89dceb>Int</span>...) async <span style=color:#cba6f7>throws</span> -&gt; [DetailedImage]{
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>imagesMetadata</span>: [DetailedImage] = []
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>for</span> image <span style=color:#cba6f7>in</span> images {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>print</span>(image)
</span></span><span style=display:flex><span>        async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImageAndMetadata(imageNumber: image)
</span></span><span style=display:flex><span>        imagesMetadata <span style=color:#89dceb;font-weight:700>+=</span>  [<span style=color:#cba6f7>try</span> await image]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> imagesMetadata
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the example above, we have added a cancellation check at the beginning of <code>downloadImage</code> and <code>downloadMetadata</code>. We have also added a function that will try to download multiple images (although not concurrently - we will learn how perform a variable number of concurrent tasks when we talk about Task Groups). If <em>any</em> image or <em>metadata</em> download fails, the children tasks will be notified of the cancellation, and if they have a chance to cancel - i.e. if they haven&rsquo;t started downloading their images or metadata - they will stop their execution.</p><h1 id=summary>Summary</h1><p>We have finally started exploring the world of actual concurrent execution using the new async/await APIs. You learned what structured concurrency is, and a way to implement it with <code>async let</code>. You also learned about the task tree and how cancellation is cooperative and how it works.</p><p>You may have noticed that our newest function, <code>downloadMultipleImagesWithMetadata</code>, will not download all three images at the same time, because it is necessary to <code>await</code> the result before we can append it to the array. We will learn how to execute a variable number of concurrent tasks when we begin talking about Task Groups.</p><p>In the meantime, take your time to analyze the contents of this article, and as usual, here is <a href=/archives/AsyncAwaitConcurrent.zip>the sample project</a> you can play around with to better understand the concepts of this article.</p></article></div></main><footer><div class=container><div class=footer-navigation><a href=https://github.com/AndyIbanez><span class=inline-svg><svg viewBox="0 0 42 40" id="svg4" width="42" height="40"><path fill="currentColor" d="m14.20936 32.20794c0 .16542-.19024.29776-.4301.29776-.27295.0248-.46319-.10752-.46319-.29776.0-.16542.19024-.29776.4301-.29776.24814-.0248.46319.10752.46319.29776zm-2.57234-.3722c-.0579.16542.10753.35566.35566.40528.21505.0827.46319.0.51282-.16542.0496-.16542-.10753-.35566-.35566-.4301-.21505-.0579-.45492.0248-.51282.19024zm3.65586-.14061c-.23986.0579-.40529.21505-.38047.40528.0248.16543.23986.27295.488.21505.23986-.0579.40528-.21505.38047-.38047-.0248-.15715-.24813-.26468-.488-.23986zM20.73531-.19734273e-6C9.2632-.19734273e-6.48748 8.7095398.48748 20.18166c0 9.17273 5.77328 17.02207 14.01964 19.78464 1.05871.19024 1.43091-.46319 1.43091-1.00081.0-.51282-.0248-3.34156-.0248-5.0785.0.0-5.78982 1.24067-7.00568-2.46481.0.0-.94292-2.40691-2.29939-3.02725.0.0-1.8941-1.29857.13234-1.27376.0.0 2.05952.16542 3.19267 2.13396 1.81139 3.19267 4.84691 2.27457 6.02969 1.72868.19023-1.32339.72786-2.24149 1.32338-2.78739-4.62358-.51281-9.28852-1.18278-9.28852-9.13964.0-2.27458.62861-3.416 1.95199-4.87172-.21505-.53763-.9181-2.7543.21506-5.6161302 1.72867-.53762 5.7071 2.2332202 5.7071 2.2332202 1.65424-.46319 3.43254-.70305 5.1943-.70305 1.76176.0 3.54006.23986 5.1943.70305.0.0 3.97843-2.7791202 5.7071-2.2332202 1.13315 2.8701002.4301 5.0785002.21505 5.6161302 1.32339 1.46399 2.13397 2.60542 2.13397 4.87172.0 7.98168-4.87172 8.61856-9.49531 9.13964.76095.65342 1.4061 1.8941 1.4061 3.83782.0 2.78739-.0248 6.23647-.0248 6.9147.0.53763.38047 1.19105 1.43091 1.00082 8.27117-2.74603 13.87903-10.59537 13.87903-19.7681C41.51252 8.7095398 32.20745-.19734273e-6 20.73533-.19734273e-6zM8.52706 28.52727c-.10752.0827-.0827.27295.0579.4301.13234.13234.32258.19024.4301.0827.10753-.0827.0827-.27295-.0579-.4301-.13233-.13234-.32257-.19024-.4301-.0827zM7.63378 27.8573c-.0579.10753.0248.23987.19023.32258.13234.0827.29777.0579.35566-.0579C8.23757 28.01446 8.15487 27.88212 7.98944 27.7994 7.82401 27.7498 7.69168 27.7746 7.63378 27.8573zm2.67986 2.94454c-.13234.10753-.0827.35566.10752.51281.19024.19024.4301.21505.53763.0827.10752-.10752.0579-.35566-.10753-.51281-.18196-.19024-.4301-.21505-.53762-.0827zM9.37072 29.58598c-.13234.0827-.13234.29776.0.488.13234.19023.35566.27295.46319.19023.13234-.10752.13234-.32257.0-.51281-.1158-.19024-.33085-.27295-.46319-.16542z" id="path2" style="stroke-width:.08271171"/></svg>
</span></a><a href=https://x.com/AndyIbanezK><span class=inline-svg><svg viewBox="0 0 50 40" id="svg4" width="50" height="40"><path fill="currentColor" d="m44.56253 9.96871c.0313.43748.0313.87506.0313 1.31254C44.59383 24.62494 34.43764 40 15.87508 40 10.1563 40 4.84383 38.34368.37506 35.4688c.81253.0937 1.5937.12495 2.4375.12495 4.71867.0 9.06249-1.5937 12.53125-4.31245-4.43751-.0938-8.15627-3.00003-9.43754-7.00006.62505.0937 1.25001.15622 1.90632.15622.90622.0 1.81254-.12505 2.65624-.34369C5.84384 23.15619 2.37498 19.09373 2.37498 14.18748v-.12495c1.3437.75 2.90633 1.21875 4.56246 1.28117-2.71876-1.81253-4.49993-4.90624-4.49993-8.40627.0-1.87497.4999-3.59372 1.37496-5.09373 4.96877 6.125 12.43756 10.12493 20.81248 10.56251-.15622-.75001-.25-1.53118-.25-2.31245C24.37495 4.5312 28.87498.0 34.46871.0c2.90623.0 5.53121 1.21875 7.37501 3.1875 2.28118-.43748 4.46867-1.28127 6.40626-2.43749-.75011 2.3438-2.34381 4.31255-4.43751 5.56246 2.03127-.21864 4.00003-.78126 5.81247-1.56244-1.37477 1.99992-3.09362 3.7811-5.06237 5.21868z" id="path2" style="stroke-width:.09619153"/></svg>
</span></a><a href=https://www.linkedin.com/in/andyibanez/><span class=inline-svg><svg viewBox="0 0 41 40" id="svg4" width="41" height="40"><path fill="currentColor" d="M9.45332 40H1.16028V13.29405H9.45332zM5.30234 9.65111c-2.65185.0-4.80279-2.19648-4.80279-4.84832a4.80279 4.80279.0 019.60558.0c0 2.65184-2.15184 4.84832-4.80279 4.84832zM40.49152 40H32.21633V26.99971c0-3.09828-.0625-7.07159-4.3117-7.07159-4.3117.0-4.97243 3.36615-4.97243 6.84837V40H14.64808V13.29405h7.95375v3.64294h.11608c1.10716-2.09827 3.81169-4.3126 7.8466-4.3126 8.39304.0 9.93594 5.52691 9.93594 12.70564V40z" id="path2" style="stroke-width:.08928771"/></svg>
</span></a><a href=https://www.andyibanez.com/posts/index.xml><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m11.435816 34.282008c0 3.15793-2.5599899 5.71793-5.7179299 5.71793s-5.717840022654-2.56-5.717840022654-5.71793c0-3.15794 2.559990022654-5.71793 5.717930022654-5.71793s5.7178399 2.56008 5.7178399 5.71793zm15.68388 4.21873C26.373806 24.697208 15.317496 13.626978 1.4992361 12.880288.68361608 12.836188.46077346e-4 13.491538.46077346e-4 14.308318v4.29186c0 .75134.579460002654 1.38142 1.329190022654 1.43017 9.9849699.65036 17.9886099 8.63408 18.6402999 18.6403.0488.74973.67893 1.3292 1.43018 1.3292h4.29186c.81687 9e-5 1.47223-.68348 1.42812-1.49911zm12.87933.0257C39.249566 17.649718 22.452206.754048 1.4735261.00092799867.66727608-.027972.46077346e-4.623338.46077346e-4 1.430038v4.29177c0 .77008.610270002654 1.39687 1.379730022654 1.42848 17.0694999.6999 30.7701699 14.40316 31.4699899 31.46999.0315.76946.6583 1.37972 1.42848 1.37972h4.29177c.8066-8e-5 1.45794-.66731 1.42901-1.47356z" id="path2" style="stroke-width:.08928544"/></svg>
</span></a><a href=https://www.andyibanez.com/contact><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m39.99999 36.249999c0 2.0711-1.6789 3.75-3.74999 3.75H3.75c-2.07109.0-3.74999-1.6789-3.74999-3.75v-20.56843a3.7499996 3.7499996.0 011.43648-2.95125c1.94633-1.5257 3.55476-2.7628904 12.82812-9.4930404C15.57906 2.2789186 18.18727-.02709136 20 .00024864227 21.81234-.02745136 24.42156 2.2793086 25.73539 3.2371986c9.27242 6.72945 10.88304 7.9683604 12.82812 9.4931204a3.7499996 3.7499996.0 011.43648 2.95125zm-5.13015-15.35976c-.20024-.29125-.60156-.35898-.88586-.14898-1.78476 1.3182-4.33297 3.18008-8.24859 6.02179-1.31445.95828-3.92266 3.26414-5.73539 3.23672-1.81336.0269-4.41867-2.2768-5.73539-3.23672-3.91515-2.8414-6.46359-4.70343-8.24859-6.02179-.2843-.21-.68562-.14227-.88586.14898l-.70875 1.03094a.62484368.62484368.0 00.14367.8568c1.78805 1.32023 4.33235 3.1789 8.2268 6.00531 1.5839 1.15476 4.41593 3.73539 7.20812 3.71664 2.79094.0189 5.62195-2.56024 7.20804-3.71664 3.89453-2.82649 6.43891-4.68516 8.2268-6.00531a.62484368.62484368.0 00.14367-.8568z" id="path2" style="stroke-width:.07812498"/></svg></span></a></div></div><p class=made-with-love><a href=https://github.com/humrochagf/colordrop><b>Colordrop</b>
</a><span>theme | Made </span><span>by</span>
<a href=https://humberto.io/><b>Humberto Rocha</b></a></p></footer></div><script src=/copy/copy.js></script><script src=/search/elasticlunr.min.js></script><script src=/search/search.js></script><script>loadSearch("https://www.andyibanez.com/index.json")</script></body></html>