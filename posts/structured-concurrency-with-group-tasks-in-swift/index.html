<!doctype html><html prefix="og: http://ogp.me/ns#" lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,user-scalable=no"><meta http-equiv=x-ua-compatible content="ie=edge"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script><link rel=icon type=image/png href=https://www.andyibanez.com/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://www.andyibanez.com/img/favicon-16x16.png sizes=16x16><link rel=canonical href=https://www.andyibanez.com/posts/structured-concurrency-with-group-tasks-in-swift/><link rel=alternate hreflang=en href=https://www.andyibanez.com/posts/structured-concurrency-with-group-tasks-in-swift/ title><meta name=description content="Learn about executing a dynamic amount of concurrency in Swift using Task Groups."><meta name=author content><meta name=theme-color content="#292148"><meta itemprop=name content="Structured Concurrency With Task Groups in Swift"><meta itemprop=description content="Learn about executing a dynamic amount of concurrency in Swift using Task Groups."><meta itemprop=datePublished content="2021-07-07T07:00:00-04:00"><meta itemprop=dateModified content="2021-07-07T07:00:00-04:00"><meta itemprop=wordCount content="1517"><meta itemprop=keywords content="swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading"><meta property="og:url" content="https://www.andyibanez.com/posts/structured-concurrency-with-group-tasks-in-swift/"><meta property="og:site_name" content="Andy Ibanez"><meta property="og:title" content="Structured Concurrency With Task Groups in Swift"><meta property="og:description" content="Learn about executing a dynamic amount of concurrency in Swift using Task Groups."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-07T07:00:00-04:00"><meta property="article:modified_time" content="2021-07-07T07:00:00-04:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta name=twitter:card content="summary"><meta name=twitter:title content="Structured Concurrency With Task Groups in Swift"><meta name=twitter:description content="Learn about executing a dynamic amount of concurrency in Swift using Task Groups."><meta name=twitter:creator content="@"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","url":"https://www.andyibanez.com/posts/structured-concurrency-with-group-tasks-in-swift/","headline":"Structured Concurrency With Task Groups in Swift","description":"Learn about executing a dynamic amount of concurrency in Swift using Task Groups.","datePublished":"2021-07-07","keywords":"swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading","author":{"@type":"Person","name":""}}</script><title>Structured Concurrency With Task Groups in Swift - Andy Ibanez</title><link rel=stylesheet href=https://www.andyibanez.com/style.main.min.18f604b90ed15864d7faa967f1ef9eacb99e1c967eff38762ec29b7bf1ab5876.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script></head><body><div class=wrapper><nav><div class=container><div class=language-selector></div></div></nav><header><div class=container><div class=header-group><div class=header-logo-container><a class=header-logo-link href=https://www.andyibanez.com/><img class=header-logo-circle src=https://www.andyibanez.com/img/andy_profile.png alt="Andy Ibanez logo"></a></div><div class=header-title><a href=https://www.andyibanez.com/>Andy Ibanez</a></div></div></div></header><nav><div class=container><div class=main-navigation><a href=/about/>About Me</a><a href=/posts/>Blog</a><a href=/projects/>Projects</a><a href=/tags/>Tags</a><a href=/contact/>Contact</a><a href=/privacy-policy/>Privacy policy</a></div></div></nav><div class=container><div class=search><input type=text id=searchInput placeholder="Type here to search"></div><div class="container search-results-container" hidden=true><div id=searchResults class=search-results></div></div></div><main><div class=container><article><h1 class=title>Structured Concurrency With Task Groups in Swift</h1><p class=publish>Published on
<time class=post-date datetime=2021-07-07T07:00:00-04:00>July 7, 2021</time></p><p><em>This article is part of my <a href=https://www.andyibanez.com/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift Article Series</a>.</em></p><p><em>This article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.</em></p><h6 id=table-of-contents>Table of Contents</h6><ol><li><a href=/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift: Introduction</a></li><li><a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a></li><li><a href=/posts/converting-closure-based-code-into-async-await-in-swift/>Converting closure-based code into async/await in Swift</a></li><li><a href=https://www.andyibanez.com/posts/structured-concurrency-in-swift-using-async-let/>Structured Concurrency in Swift: Using async let</a></li><li><strong>Structured Concurrency With Task Groups in Swift</strong></li><li><a href=/posts/introduction-to-unstructured-concurrency-in-swift/>Introduction to Unstructured Concurrency in Swift</a></li><li><a href=/posts/unstructured-concurrency-with-detached-tasks-in-swift/>Unstructured Concurrency With Detached Tasks in Swift</a></li><li><a href=/posts/understanding-actors-in-the-new-concurrency-model-in-swift/>Understanding Actors in the New Concurrency Model in Swift</a></li><li><a href=/posts/mainactor-and-global-actors-in-swift/>@MainActor and Global Actors in Swift</a></li><li><a href=posts/sharing-data-across-tasks-tasklocal-new-swift-concurrency-model>Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model</a></li><li><a href=/posts/using-asyncsequence-in-swift/>Using AsyncSequence in Swift</a></li></ol><hr><p><em>Understanding Structured Concurrency and <code>async let</code> is a pre-requisite to read this article. If you aren&rsquo;t familiar with that concept, feel free to read the third part of this article series: <a href>Beginning Concurrency in Swift: Structured Concurrency and async-let</a>.</em></p><p>Task Groups are the second form of structured concurrency in Swift. When we explored <code>async let</code>, we noticed one particular restriction: We cannot run a variable number of tasks at the same time, because when we try to do so, say in a loop, we need to <code>await</code> the results. This won&rsquo;t allow us to, for example, download multiple pictures at once, because we are restricted to waiting on each download.</p><p>To perform a variable number of tasks, Swift gives us Task Groups.</p><h1 id=task-groups>Task Groups</h1><p>Task Groups offer more flexibility than <code>async let</code> without giving up the simplicity of structured concurrency.</p><p>A <code>Task Group</code> is a form of structured concurrency designed to provide a dynamic amount of concurrency. With it, we can launch multiple tasks, launch them in a <em>group</em>, and have them execute all at the same time.</p><p>We have two ways to launch task groups:</p><ul><li>By calling <code>withThrowingTaskGroup</code></li><li>By calling <code>withTaskGroup</code></li></ul><p>Like we have seen multiple times through this article series, you have a variant for tasks that may throw errors and one for tasks that won&rsquo;t. Tasks added to a group cannot outlive the scope of the block in which the group is defined. When child tasks are added to a group, they begin executing immediately and in any order, so take care to design your code in such a way that there&rsquo;s no dependencies in your child tasks. When the group goes out of scope, the completion of all the tasks within it will be implicitly <code>await</code>ed.</p><p>Structured concurrency allow us to create <code>async let</code> tasks within groups, and the other way around too - to launch task groups within <code>async let</code> calls.</p><p>If you try to modify a variable within a task group, like this:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadMultipleImagesWithMetadata</span>(images: <span style=color:#89dceb>Int</span>...) async <span style=color:#cba6f7>throws</span> -&gt; [DetailedImage]{
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>imagesMetadata</span>: [DetailedImage] = []
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>try</span> await withThrowingTaskGroup(of: <span style=color:#89dceb>Void</span>.<span style=color:#fab387>self</span>, body: { group <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>for</span> image <span style=color:#cba6f7>in</span> images {
</span></span><span style=display:flex><span>            group.async {
</span></span><span style=display:flex><span>                async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImageAndMetadata(imageNumber: image)
</span></span><span style=display:flex><span>                imagesMetadata <span style=color:#89dceb;font-weight:700>+=</span>  [<span style=color:#cba6f7>try</span> await image]
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> imagesMetadata
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>This code is a variant of the one written in <a href>Beginning Concurrency in Swift: Structured Concurrency and async-let</a>. This example is based on the <a href=https://developer.apple.com/videos/play/wwdc2021/10134/>Explore structured concurrency in Swift</a> WWDC2021 talk.</em></p><p>The compiler will notice that <code>imagesMetadata</code> can potentially be accessed unsafely by multiple tasks at the same time. This would lead to data corruption as multiple variables try to write to it at the same time. Luckily, thanks to the fact that the new concurrency APIs are deeply integrated into Swift itself, the compiler can do some checks statically and prevent you from introducing such data races.</p><p>If you try to compile that, the compiler will yield the following error:</p><blockquote><p>Mutation of captured var &lsquo;imagesMetadata&rsquo; in concurrently-executing code</p></blockquote><p>So, how exactly can Swift perform these checks?</p><h2 id=the-sendable-closure-type>The @Sendable closure type</h2><p>To introduce data race safety, Swift implements the concept of a <strong>@Sendable closure</strong>.</p><p>Whenever you create a Task, the body is a <code>@Sendable</code> closure, and this closure has the following properties:</p><ul><li>Cannot capture mutable variables.</li><li>You should only capture value types, actors, classes, or other objects that implement their own synchronization. We will explore actors in a future article.</li></ul><p>With this knowledge in mind, we can fix our Task Group above. When you create a Task Group with either <code>withThrowingTaskGroup</code> or <code>withTaskGroup</code>, the task group takes as a parameter the return type your concurrent tasks will create.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadMultipleImagesWithMetadata</span>(images: <span style=color:#89dceb>Int</span>...) async <span style=color:#cba6f7>throws</span> -&gt; [DetailedImage]{
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>try</span> await withThrowingTaskGroup(of: DetailedImage.<span style=color:#fab387>self</span>, body: { group <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>for</span> image <span style=color:#cba6f7>in</span> images {
</span></span><span style=display:flex><span>            group.async {
</span></span><span style=display:flex><span>                async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImageAndMetadata(imageNumber: image)
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> await image
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The implementation of our method is not complete yet, but going step by step, it has received a few important modifications:</p><ul><li>The <code>of</code> parameter of <code>withThrowingTaskGroup</code> now specifies that it takes <code>DetailedImage</code>s.</li><li>Instead of appending to an array, <code>group.async</code> will now return an <code>await</code>ed <code>DetailedImage</code> on each run of the loop.</li></ul><p>Essentially, we are &ldquo;filling the group&rdquo; with <code>DetailedImage</code>s that we will eventually return - unless an error occurs. If an error occurs, the child tasks will be cancelled, and the tasks will need to be stopped. Recall from <a href>Beginning Concurrency in Swift: Structured Concurrency and async-let</a> that you are responsible for keeping cancellation in mind when designing your code, but luckily it&rsquo;s a one-line call in the case of structured concurrency.</p><p>Our <code>group</code> variable is of type <code>ThrowingTaskGroup&lt;DetailedImage, Error></code>. And surprise, this is a collection! You can iterate over it or apply functional programming to it such as <code>filter</code>, <code>map</code>, and <code>reduce</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadMultipleImagesWithMetadata</span>(images: <span style=color:#89dceb>Int</span>...) async <span style=color:#cba6f7>throws</span> -&gt; [DetailedImage]{
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>imagesMetadata</span>: [DetailedImage] = []
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>try</span> await withThrowingTaskGroup(of: DetailedImage.<span style=color:#fab387>self</span>, body: { group <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>for</span> image <span style=color:#cba6f7>in</span> images {
</span></span><span style=display:flex><span>            group.async {
</span></span><span style=display:flex><span>                async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImageAndMetadata(imageNumber: image)
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> await image
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>for</span> <span style=color:#cba6f7>try</span> await image <span style=color:#cba6f7>in</span> group {
</span></span><span style=display:flex><span>            imagesMetadata <span style=color:#89dceb;font-weight:700>+=</span> [image]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> imagesMetadata
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>for try await</code> part may throw you for a loop (no pun intended). But alongside all the new concurrency APIs introduced in Swift 5.5, we have a new <code>AsyncSequence</code> type. This protocol is implemented by types that will receive values over time. In our <code>downloadMultipleImagesWithMetadata</code> function, we use <code>group.async</code> to launch a dynamic number of <code>DetailedImage</code> downloads. As the downloads end, they will be delivered to our <code>for in</code> loop, one image at a time, making it safe to modify variables within it, and more.</p><p>Note that the <code>await</code> in the for loop behaves the same way as any other <code>await</code> call. Execution will suspend when reaching that point, and when a new image is delivered, execution will continue. This is important to keep in mind because if you have anything underneath the <code>for-in</code> loop, it will not be executed until all the elements in the group have been sent through it. If you want to download three images, the three images may download concurrently at the same time, but the for loop will only give you one at a time. If you download a considerable number of images, they will all have to be downloaded before executing anything underneath <code>for-in</code>. This also means that shall an error be thrown, your <code>for-in</code> will stop executing (or it may not even execute if the first download fails).</p><p>We will explore <code>AsyncSequence</code> in depth in a future article.</p><p>When we are dealing with Task Groups, we actually have a bit more flexibility. We can for example launch a task asynchronously with a given priority:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>group.async(priority: .userInitiated) {
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Where <code>priority</code> is of type <a href="https://developer.apple.com/documentation/swift/task/priority?changes=__6_8"><code>Task.Priority</code></a>. This gives you more flexible control when dealing with cancellation, as it even has a <code>asyncUnlessCancelled</code> method that can optionally take in the priority as well.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>group.asyncUnlessCancelled(priority: <span style=color:#fab387>nil</span>) {
</span></span><span style=display:flex><span>   <span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, you can also call <code>cancellAll()</code> in a group. Cancelation will propagate down the tree.</p><p>Note that there&rsquo;s a tiny difference when compared to <code>async let</code>. When the group goes out of scope through a normal exit, cancellation of the tasks is not implicit. They will just be awaited instead. This is to give your other tasks time to finish and to express the <a href=https://en.wikipedia.org/wiki/Fork%E2%80%93join_model>Fork-Join Model</a>, which is essentially &ldquo;divide and conquer&rdquo; - in our case, downloading multiple images in as many child tasks as possible.</p><h1 id=summary>Summary</h1><p>In this article, you learned the other way to do structured concurrency in Swift by using Task Groups. Task groups allow us to execute dynamic concurrency, such as when needing to download multiple images in a loop. We briefly mentioned <code>AsyncSequence</code> and how it&rsquo;s used with Task Groups to deliver results over time.</p><p>As is tradition with this series, <a href=/archives/AsyncAwaitGroupTask.zip>here&rsquo;s</a> a small example project you can download. While the UI is the same one as the first few projects, you will have a compilable version of <code>downloadMultipleImagesWithMetadata</code> that you can play with and experiment.</p><p>With this article, we have finished exploring the two methods to do structured concurrency in Swift:</p><ul><li>When you need basic concurrency support, use <code>async let</code>.</li><li>When you have a dynamic amount of concurrent tasks to perform, use a Task Group.</li></ul><p>In the next article, we will begin exploring unstructured concurrency. It sounds intimidating, but Swift makes it possible to work with as easily as with structured concurrency.</p></article></div></main><footer><div class=container><div class=footer-navigation><a href=https://github.com/AndyIbanez><span class=inline-svg><svg viewBox="0 0 42 40" id="svg4" width="42" height="40"><path fill="currentColor" d="m14.20936 32.20794c0 .16542-.19024.29776-.4301.29776-.27295.0248-.46319-.10752-.46319-.29776.0-.16542.19024-.29776.4301-.29776.24814-.0248.46319.10752.46319.29776zm-2.57234-.3722c-.0579.16542.10753.35566.35566.40528.21505.0827.46319.0.51282-.16542.0496-.16542-.10753-.35566-.35566-.4301-.21505-.0579-.45492.0248-.51282.19024zm3.65586-.14061c-.23986.0579-.40529.21505-.38047.40528.0248.16543.23986.27295.488.21505.23986-.0579.40528-.21505.38047-.38047-.0248-.15715-.24813-.26468-.488-.23986zM20.73531-.19734273e-6C9.2632-.19734273e-6.48748 8.7095398.48748 20.18166c0 9.17273 5.77328 17.02207 14.01964 19.78464 1.05871.19024 1.43091-.46319 1.43091-1.00081.0-.51282-.0248-3.34156-.0248-5.0785.0.0-5.78982 1.24067-7.00568-2.46481.0.0-.94292-2.40691-2.29939-3.02725.0.0-1.8941-1.29857.13234-1.27376.0.0 2.05952.16542 3.19267 2.13396 1.81139 3.19267 4.84691 2.27457 6.02969 1.72868.19023-1.32339.72786-2.24149 1.32338-2.78739-4.62358-.51281-9.28852-1.18278-9.28852-9.13964.0-2.27458.62861-3.416 1.95199-4.87172-.21505-.53763-.9181-2.7543.21506-5.6161302 1.72867-.53762 5.7071 2.2332202 5.7071 2.2332202 1.65424-.46319 3.43254-.70305 5.1943-.70305 1.76176.0 3.54006.23986 5.1943.70305.0.0 3.97843-2.7791202 5.7071-2.2332202 1.13315 2.8701002.4301 5.0785002.21505 5.6161302 1.32339 1.46399 2.13397 2.60542 2.13397 4.87172.0 7.98168-4.87172 8.61856-9.49531 9.13964.76095.65342 1.4061 1.8941 1.4061 3.83782.0 2.78739-.0248 6.23647-.0248 6.9147.0.53763.38047 1.19105 1.43091 1.00082 8.27117-2.74603 13.87903-10.59537 13.87903-19.7681C41.51252 8.7095398 32.20745-.19734273e-6 20.73533-.19734273e-6zM8.52706 28.52727c-.10752.0827-.0827.27295.0579.4301.13234.13234.32258.19024.4301.0827.10753-.0827.0827-.27295-.0579-.4301-.13233-.13234-.32257-.19024-.4301-.0827zM7.63378 27.8573c-.0579.10753.0248.23987.19023.32258.13234.0827.29777.0579.35566-.0579C8.23757 28.01446 8.15487 27.88212 7.98944 27.7994 7.82401 27.7498 7.69168 27.7746 7.63378 27.8573zm2.67986 2.94454c-.13234.10753-.0827.35566.10752.51281.19024.19024.4301.21505.53763.0827.10752-.10752.0579-.35566-.10753-.51281-.18196-.19024-.4301-.21505-.53762-.0827zM9.37072 29.58598c-.13234.0827-.13234.29776.0.488.13234.19023.35566.27295.46319.19023.13234-.10752.13234-.32257.0-.51281-.1158-.19024-.33085-.27295-.46319-.16542z" id="path2" style="stroke-width:.08271171"/></svg>
</span></a><a href=https://x.com/AndyIbanezK><span class=inline-svg><svg viewBox="0 0 50 40" id="svg4" width="50" height="40"><path fill="currentColor" d="m44.56253 9.96871c.0313.43748.0313.87506.0313 1.31254C44.59383 24.62494 34.43764 40 15.87508 40 10.1563 40 4.84383 38.34368.37506 35.4688c.81253.0937 1.5937.12495 2.4375.12495 4.71867.0 9.06249-1.5937 12.53125-4.31245-4.43751-.0938-8.15627-3.00003-9.43754-7.00006.62505.0937 1.25001.15622 1.90632.15622.90622.0 1.81254-.12505 2.65624-.34369C5.84384 23.15619 2.37498 19.09373 2.37498 14.18748v-.12495c1.3437.75 2.90633 1.21875 4.56246 1.28117-2.71876-1.81253-4.49993-4.90624-4.49993-8.40627.0-1.87497.4999-3.59372 1.37496-5.09373 4.96877 6.125 12.43756 10.12493 20.81248 10.56251-.15622-.75001-.25-1.53118-.25-2.31245C24.37495 4.5312 28.87498.0 34.46871.0c2.90623.0 5.53121 1.21875 7.37501 3.1875 2.28118-.43748 4.46867-1.28127 6.40626-2.43749-.75011 2.3438-2.34381 4.31255-4.43751 5.56246 2.03127-.21864 4.00003-.78126 5.81247-1.56244-1.37477 1.99992-3.09362 3.7811-5.06237 5.21868z" id="path2" style="stroke-width:.09619153"/></svg>
</span></a><a href=https://www.linkedin.com/in/andyibanez/><span class=inline-svg><svg viewBox="0 0 41 40" id="svg4" width="41" height="40"><path fill="currentColor" d="M9.45332 40H1.16028V13.29405H9.45332zM5.30234 9.65111c-2.65185.0-4.80279-2.19648-4.80279-4.84832a4.80279 4.80279.0 019.60558.0c0 2.65184-2.15184 4.84832-4.80279 4.84832zM40.49152 40H32.21633V26.99971c0-3.09828-.0625-7.07159-4.3117-7.07159-4.3117.0-4.97243 3.36615-4.97243 6.84837V40H14.64808V13.29405h7.95375v3.64294h.11608c1.10716-2.09827 3.81169-4.3126 7.8466-4.3126 8.39304.0 9.93594 5.52691 9.93594 12.70564V40z" id="path2" style="stroke-width:.08928771"/></svg>
</span></a><a href=https://www.andyibanez.com/blog/index.xml><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m11.435816 34.282008c0 3.15793-2.5599899 5.71793-5.7179299 5.71793s-5.717840022654-2.56-5.717840022654-5.71793c0-3.15794 2.559990022654-5.71793 5.717930022654-5.71793s5.7178399 2.56008 5.7178399 5.71793zm15.68388 4.21873C26.373806 24.697208 15.317496 13.626978 1.4992361 12.880288.68361608 12.836188.46077346e-4 13.491538.46077346e-4 14.308318v4.29186c0 .75134.579460002654 1.38142 1.329190022654 1.43017 9.9849699.65036 17.9886099 8.63408 18.6402999 18.6403.0488.74973.67893 1.3292 1.43018 1.3292h4.29186c.81687 9e-5 1.47223-.68348 1.42812-1.49911zm12.87933.0257C39.249566 17.649718 22.452206.754048 1.4735261.00092799867.66727608-.027972.46077346e-4.623338.46077346e-4 1.430038v4.29177c0 .77008.610270002654 1.39687 1.379730022654 1.42848 17.0694999.6999 30.7701699 14.40316 31.4699899 31.46999.0315.76946.6583 1.37972 1.42848 1.37972h4.29177c.8066-8e-5 1.45794-.66731 1.42901-1.47356z" id="path2" style="stroke-width:.08928544"/></svg>
</span></a><a href=https://www.andyibanez.com/curriculum/><span class=inline-svg><svg viewBox="0 0 15680 20480" id="svg4" width="35" height="40"><path fill="currentColor" d="M11655.83 12824.48 7840.0001 16640.464 4024.17 12824.48c-2859.863 123.906-5143.7701 2463.775-5143.7701 5352.003v384.005c0 1059.853 859.96601 1919.512 1919.92167 1919.512H14879.678c1059.956.0 1919.922-859.659 1919.922-1919.512v-384.005c0-2888.228-2283.906-5228.097-5143.77-5352.003zM-575.64445 3193.1279l256.0032 59.9048v2335.7732c-279.9651 167.9381-479.9548 459.7818-479.9548 812.0422.0 335.8762 183.9639 615.9437 443.96075 787.9778l-623.9822 2491.9352c-67.9944 275.9716 84.02025 559.6229 303.9782 559.6229H996.31762c219.95798.0 371.97268-283.6513 303.97828-559.6229L676.31362 7188.8259c259.99685-172.0341 443.96078-452.1016 443.96078-787.9778.0-352.2604-199.98973-644.1041-479.95483-812.0422V3484.9716l2639.90503 635.9119c-344.0171 688.1366-559.9814 1456.1463-559.9814 2279.9646.0 2827.8113 2291.8942 5119.5519 5119.7569 5119.5519 2827.8619.0 5119.7569-2291.7406 5119.7569-5119.5519.0-823.8183-211.971-1591.828-559.982-2279.9646l3851.824-927.7556c727.971-176.1302 727.971-1083.9175.0-1260.0477L8635.9653 92.929226c-519.9937-123.905551-1067.943-123.905551-1587.9367.0L-575.64445 1928.9841c-723.92585 176.1302-723.92585 1088.0136.0 1264.1438z" id="path2" style="stroke-width:39.99821472"/></svg>
</span></a><a href=https://www.andyibanez.com/contact-me><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m39.99999 36.249999c0 2.0711-1.6789 3.75-3.74999 3.75H3.75c-2.07109.0-3.74999-1.6789-3.74999-3.75v-20.56843a3.7499996 3.7499996.0 011.43648-2.95125c1.94633-1.5257 3.55476-2.7628904 12.82812-9.4930404C15.57906 2.2789186 18.18727-.02709136 20 .00024864227 21.81234-.02745136 24.42156 2.2793086 25.73539 3.2371986c9.27242 6.72945 10.88304 7.9683604 12.82812 9.4931204a3.7499996 3.7499996.0 011.43648 2.95125zm-5.13015-15.35976c-.20024-.29125-.60156-.35898-.88586-.14898-1.78476 1.3182-4.33297 3.18008-8.24859 6.02179-1.31445.95828-3.92266 3.26414-5.73539 3.23672-1.81336.0269-4.41867-2.2768-5.73539-3.23672-3.91515-2.8414-6.46359-4.70343-8.24859-6.02179-.2843-.21-.68562-.14227-.88586.14898l-.70875 1.03094a.62484368.62484368.0 00.14367.8568c1.78805 1.32023 4.33235 3.1789 8.2268 6.00531 1.5839 1.15476 4.41593 3.73539 7.20812 3.71664 2.79094.0189 5.62195-2.56024 7.20804-3.71664 3.89453-2.82649 6.43891-4.68516 8.2268-6.00531a.62484368.62484368.0 00.14367-.8568z" id="path2" style="stroke-width:.07812498"/></svg></span></a></div></div><p class=made-with-love><a href=https://github.com/humrochagf/colordrop><b>Colordrop</b>
</a><span>theme | Made </span><span>by</span>
<a href=https://humberto.io/><b>Humberto Rocha</b></a></p></footer></div><script src=/copy/copy.js></script><script src=/search/elasticlunr.min.js></script><script src=/search/search.js></script><script>loadSearch()</script></body></html>