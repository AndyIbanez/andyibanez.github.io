<!doctype html><html prefix="og: http://ogp.me/ns#" lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,user-scalable=no"><meta http-equiv=x-ua-compatible content="ie=edge"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script><link rel=apple-touch-icon sizes=180x180 href=https://www.andyibanez.com/favicons/apple-touch-icon-180x180.png><link rel=icon type=image/png sizes=32x32 href=https://www.andyibanez.com/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.andyibanez.com/favicons/favicon-16x16.png><link rel=manifest href=https://www.andyibanez.com/favicons/site.webmanifest><link rel=mask-icon href=https://www.andyibanez.com/favicons/safari-pinned-tab.svg color=#292148><meta name=msapplication-TileColor content="#292148"><meta name=msapplication-config content="https://www.andyibanez.com/favicons/browserconfig.xml"><meta name=theme-color content="#292148"><link rel=canonical href=https://www.andyibanez.com/posts/modern-swift-concurrency-summary-cheatsheet-thanks/><link rel=alternate hreflang=en href=https://www.andyibanez.com/posts/modern-swift-concurrency-summary-cheatsheet-thanks/ title><meta name=description content="A summary of all the articles written about the modern Swift Concurrency System introduced at WWDC2021."><meta name=author content><meta name=theme-color content="#292148"><meta itemprop=name content="Modern Swift Concurrency Summary, Cheatsheet, and Thanks"><meta itemprop=description content="A summary of all the articles written about the modern Swift Concurrency System introduced at WWDC2021."><meta itemprop=datePublished content="2021-09-08T07:00:00-04:00"><meta itemprop=dateModified content="2021-09-08T07:00:00-04:00"><meta itemprop=wordCount content="2931"><meta itemprop=keywords content="swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading"><meta property="og:url" content="https://www.andyibanez.com/posts/modern-swift-concurrency-summary-cheatsheet-thanks/"><meta property="og:site_name" content="Andy Ibanez"><meta property="og:title" content="Modern Swift Concurrency Summary, Cheatsheet, and Thanks"><meta property="og:description" content="A summary of all the articles written about the modern Swift Concurrency System introduced at WWDC2021."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-08T07:00:00-04:00"><meta property="article:modified_time" content="2021-09-08T07:00:00-04:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta name=twitter:card content="summary"><meta name=twitter:title content="Modern Swift Concurrency Summary, Cheatsheet, and Thanks"><meta name=twitter:description content="A summary of all the articles written about the modern Swift Concurrency System introduced at WWDC2021."><meta name=twitter:creator content="@"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","url":"https://www.andyibanez.com/posts/modern-swift-concurrency-summary-cheatsheet-thanks/","headline":"Modern Swift Concurrency Summary, Cheatsheet, and Thanks","description":"A summary of all the articles written about the modern Swift Concurrency System introduced at WWDC2021.","datePublished":"2021-09-08","keywords":"swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading","author":{"@type":"Person","name":""}}</script><title>Modern Swift Concurrency Summary, Cheatsheet, and Thanks - Andy Ibanez</title><link rel=stylesheet href=https://www.andyibanez.com/style.main.min.18f604b90ed15864d7faa967f1ef9eacb99e1c967eff38762ec29b7bf1ab5876.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script></head><body><div class=wrapper><nav><div class=container><div class=language-selector></div></div></nav><header><div class=container><div class=header-group><div class=header-logo-container><a class=header-logo-link href=https://www.andyibanez.com/><img class=header-logo-circle src=https://www.andyibanez.com/img/andy_profile.png alt="Andy Ibanez logo"></a></div><div class=header-title><a href=https://www.andyibanez.com/>Andy Ibanez</a></div></div></div></header><nav><div class=container><div class=main-navigation><a href=/about/>About Me</a><a href=/posts/>Blog</a><a href=/projects/>Projects</a><a href=/tags/>Tags</a><a href=/contact/>Contact</a><a href=/privacy-policy/>Privacy policy</a></div></div></nav><div class=container><div class=search><input type=text id=searchInput placeholder="Type here to search"></div><div class="container search-results-container" hidden=true><div id=searchResults class=search-results></div></div></div><main><div class=container><article><h1 class=title>Modern Swift Concurrency Summary, Cheatsheet, and Thanks</h1><p class=publish>Published on
<time class=post-date datetime=2021-09-08T07:00:00-04:00>September 8, 2021</time></p><h6 id=table-of-contents>Table of Contents</h6><ol><li><a href=/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift: Introduction</a></li><li><a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a></li><li><a href=/posts/converting-closure-based-code-into-async-await-in-swift/>Converting closure-based code into async/await in Swift</a></li><li><a href=https://www.andyibanez.com/posts/structured-concurrency-in-swift-using-async-let/>Structured Concurrency in Swift: Using async let</a></li><li><a href=/posts/structured-concurrency-with-group-tasks-in-swift/>Structured Concurrency With Group Tasks in Swift</a></li><li><a href=/posts/introduction-to-unstructured-concurrency-in-swift/>Introduction to Unstructured Concurrency in Swift</a></li><li><a href=/posts/unstructured-concurrency-with-detached-tasks-in-swift/>Unstructured Concurrency With Detached Tasks in Swift</a></li><li><a href=/posts/understanding-actors-in-the-new-concurrency-model-in-swift/>Understanding Actors in the New Concurrency Model in Swift</a></li><li><a href=/posts/mainactor-and-global-actors-in-swift/>@MainActor and Global Actors in Swift</a></li><li><a href=posts/sharing-data-across-tasks-tasklocal-new-swift-concurrency-model>Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model</a></li><li><a href=/posts/using-asyncsequence-in-swift/>Using AsyncSequence in Swift</a></li><li><strong>Modern Swift Concurrency Summary, Cheatsheet, and Thanks</strong></li></ol><hr><p>Since WWDC21, we have talked, extensively, about all the new concurrency features introduced in Swift 5.5. We covered <em>a lot</em> of topics, so I decided to finish off this series writing a summary article were we cover the most important topics of each article. Links will be given to the relevant articles when necessary in case this summary is not enough.</p><h1 id=asyncawait>async/await</h1><ul><li><code>async</code> and <code>await</code> are the most fundamental keywords of the new concurrency system.</li><li>When you learn to program, you are used to writing code that executes linearly (called procedural programming). Your code executes its lines in the order you give them.</li><li>When dealing with concurrent tasks, prior to async/await, Apple gave us callback/closure-based concurrency, in which we are notified via a closure when the task is done, or delegate-based concurrency in the case of older concurrent code. Callback and delegate based concurrency can alter the order in which our program runs. If we have a set of linear instructions, we can be notified as that linear code executes and receive new data from a different thread. This makes it possible to deal with concurrency, but it can become hard to understand as time goes by.</li><li>async/await allow us to write linear concurrent code that executes from top to bottom. To work with this, functions that can be called asynchronously should be marked as <code>async</code> in the function signature.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadData</span>() async <span style=color:#cba6f7>throws</span> -&gt; CustomData { 
</span></span><span style=display:flex><span>	<span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>When we call a function marked as <code>async</code>, it needs to be prepended with the word <code>await</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>processData</span>() async <span style=color:#cba6f7>throws</span> -&gt; CustomData {
</span></span><span style=display:flex><span>   <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>newData</span> = <span style=color:#cba6f7>try</span> await downloadData()
</span></span><span style=display:flex><span>   <span style=color:#cba6f7>return</span> newData
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>When execution of our code reaches the <code>await</code> keyword, execution of our code may be suspended <strong>suspended</strong>, and the thread our code is running on is free to do other work. This other work is assigned by the system. Because our code is suspended, the lines below the <code>await</code> will not be executed until the <code>async</code> task is done running.</li><li>If our code was suspended, at some point, the <code>async</code> task will be done running. The system will come back to our code and continue executing our code. That means everything under the <code>await</code> call will resume execution.</li><li><code>async/await</code> allow us to keep a procedural flow that runs from top to bottom thanks to thread suspension.</li><li>Anything below an <code>await</code> call is called a <em>continuation</em>. This is relevant to know if you want to convert delegate or closure based concurrent code into async/await.</li><li>It&rsquo;s important to note that a continuation may not be executed in the same thread that was suspended. If you need to update your UI, you should run that code in the @MainActor.</li><li><code>async</code> code needs to run in <code>async</code> contexts. This means functions marked as <code>async</code>, or if you create such context yourself with <code>Task {}</code>.</li></ul><p>To learn about async/await, checkout the <a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a> article.</p><h1 id=converting-delegate-and-closure-based-code-into-asyncawait>Converting Delegate and Closure Based Code into async/await.</h1><ul><li>The compiler can already do this for you for free without any effort - if you start typing a method that you expect it to have a closure, you may find the compiler has already created an <code>async</code> version of it for you for free.</li><li>You can create such conversions yourself.</li><li>To create such conversions, you create manual <em>continuations</em>. Recall a continuation is everything that happens after an <code>await</code> call.</li><li>To create these conversions yourself, you can use the <code>withCheckedContinuation</code> or <code>withCheckedThrowingContinuation</code> functions. Use them to wrap your closure-based calls, or store references to the continuations in order to call them later as part of delegate-based calls.</li><li>These methods will provide you with the continuation you need to call explicitly when your concurrent tasks are done. You can call them passing in the &ldquo;returned&rdquo; value, or throwing an error (in the case of <code>withCheckedThrowingContinuation</code>.</li><li>You are required to call a continuation exactly once. Don&rsquo;t forget to call it. Do call it once and no more.</li><li>The following code hows how to convert closure-based concurrency into async/await.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> await withCheckedThrowingContinuation({
</span></span><span style=display:flex><span>        (continuation: CheckedContinuation&lt;DetailedImage, Error&gt;) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>        downloadImageAndMetadata(imageNumber: imageNumber) { image, error <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = image {
</span></span><span style=display:flex><span>                continuation.resume(returning: image)
</span></span><span style=display:flex><span>            } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>                continuation.resume(throwing: error!)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Converting delegate-based calls into async/await is slightly more involved, but not impossible. You need to store the continuation provided by the <code>withChecked*Continuation</code> call and call it whenever it is appropriate.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>ContactPicker</span>: NSObject, CNContactPickerDelegate {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>typealias</span> ContactCheckedContinuation = CheckedContinuation&lt;CNContact, Never&gt; <span style=color:#6c7086;font-style:italic>// 1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#cba6f7>unowned</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>viewController</span>: UIViewController
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>contactContinuation</span>: ContactCheckedContinuation? <span style=color:#6c7086;font-style:italic>// 2</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>picker</span>: CNContactPickerViewController
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>init</span>(viewController: UIViewController) {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.viewController = viewController
</span></span><span style=display:flex><span>        picker = CNContactPickerViewController()
</span></span><span style=display:flex><span>        <span style=color:#fab387>super</span>.<span style=color:#f38ba8>init</span>()
</span></span><span style=display:flex><span>        picker.delegate = <span style=color:#fab387>self</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>pickContact</span>() async -&gt; CNContact { <span style=color:#6c7086;font-style:italic>// 3</span>
</span></span><span style=display:flex><span>        viewController.present(picker, animated: <span style=color:#fab387>true</span>)
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> await withCheckedContinuation({ (continuation: ContactCheckedContinuation) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>            <span style=color:#fab387>self</span>.contactContinuation = continuation
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>contactPicker</span>(<span style=color:#fab387>_</span> picker: CNContactPickerViewController, didSelect contact: CNContact) {
</span></span><span style=display:flex><span>        contactContinuation?.resume(returning: contact) <span style=color:#6c7086;font-style:italic>// 4</span>
</span></span><span style=display:flex><span>        contactContinuation = <span style=color:#fab387>nil</span>
</span></span><span style=display:flex><span>        picker.dismiss(animated: <span style=color:#fab387>true</span>, completion: <span style=color:#fab387>nil</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>You are not limited to converting delegate-based concurrency. Even delegate-based call that does everything in the same thread can benefit from this (but do consider if your effort will be worth it and it won&rsquo;t be over-engineering.</li></ul><p>To learn more about converting existing closure or delegate based code into <code>async/await</code>, check out the <a href=https://www.andyibanez.com/posts/converting-closure-based-code-into-async-await-in-swift/>Converting closure-based code into async/await in Swift</a> article.</p><h1 id=structured-concurrency>Structured Concurrency</h1><ul><li>Having multiple <code>await</code> calls in a row does not mean that concurrency is taking place. The code below is not concurrent, although the <code>await</code> calls are independent so they could very well be.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = <span style=color:#cba6f7>try</span> await downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span> await downloadMetadata(<span style=color:#cba6f7>for</span>: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> DetailedImage(image: image, metadata: metadata)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Structured concurrency allows us to write concurrent code that can also be read from top to bottom. We can launch multiple tasks in parallel easily.</li><li>There&rsquo;s two types of structured concurrency: <code>async let</code> calls and Task Groups.</li></ul><h2 id=async-let-concurrency>async let concurrency</h2><ul><li>Calls that can be <code>await</code>ed can also be executed concurrently.</li><li>To do so, simply add the <code>async</code> keyword in your variable definition before the <code>let</code> or <code>var</code>, and remove the <code>await</code> call.</li><li>Then simply <code>await</code> for the variable at the point that you need it.</li><li>The following code is the same code as above, but it now performs both <code>async</code> tasks concurrently.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = downloadMetadata(<span style=color:#cba6f7>for</span>: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> DetailedImage(image: await image, metadata: await metadata)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Despite the fact that <code>image</code> and <code>metadata</code> are async values, the code is still very easy to read, because we await for their values before we return from the function.</li><li><code>async let</code> is perfect when you know the exact number of concurrent tasks you need to perform. In the example above, we know we have two: <code>downloadImage</code> and <code>downloadMetadata</code>.</li></ul><p>To learn more about structured concurrency with <code>async let</code>, read the <a href=https://www.andyibanez.com/posts/structured-concurrency-in-swift-using-async-let/>Structured Concurrency in Swit: Using async let</a> article.</p><h2 id=group-tasks>Group Tasks</h2><ul><li>Use group tasks when the amount of concurrency is not known before hand. Like fetching a variable number of URLs from a web service, which you later want to download concurrently.</li><li>To launch them, use the <code>withThrowingTaskGroup</code> or <code>withTaskGroup</code> methods.</li><li>In the example above, we create a Task Group to download a variable number of images.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadMultipleImagesWithMetadata</span>(images: <span style=color:#89dceb>Int</span>...) async <span style=color:#cba6f7>throws</span> -&gt; [DetailedImage]{
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>imagesMetadata</span>: [DetailedImage] = []
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>try</span> await withThrowingTaskGroup(of: DetailedImage.<span style=color:#fab387>self</span>, body: { group <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>for</span> image <span style=color:#cba6f7>in</span> images {
</span></span><span style=display:flex><span>            group.async {
</span></span><span style=display:flex><span>                async <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = downloadImageAndMetadata(imageNumber: image)
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> await image
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>for</span> <span style=color:#cba6f7>try</span> await image <span style=color:#cba6f7>in</span> group {
</span></span><span style=display:flex><span>            imagesMetadata <span style=color:#89dceb;font-weight:700>+=</span> [image]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> imagesMetadata
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>the <code>group</code> variable will have our data as it is downloaded. It&rsquo;s an <code>AsyncSequence</code>, so you can iterate over it, or apply functions such as <code>filter</code>, <code>map</code>, <code>reduce</code>.</li><li>You can specify the priority of the group, making this structured concurrency method a bit more flexible than <code>async let</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>group.async(priority: .userInitiated) {
</span></span><span style=display:flex><span>   <span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>We can be ready for cancellation with <code>asyncUnlessCancelled</code>.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>group.asyncUnlessCancelled(priority: <span style=color:#fab387>nil</span>) {
</span></span><span style=display:flex><span>   <span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=sendable-types>Sendable Types</h3><ul><li>Sendable types are the types that work well with concurrency. The compiler won&rsquo;t complain if you use these in concurrent contexts. There are <code>@Sendable</code> closures that only work with <code>Sendable</code> types (a protocol).</li><li><code>@Sendable</code> closures cannot capture mutating variables.</li><li>You should only capture value types, actors, classes, or other objects that implement their own synchronization.</li></ul><p>To learn more about Group Tasks and/or Sendable types, read the <a href=https://www.andyibanez.com/posts/structured-concurrency-with-group-tasks-in-swift/>Structured Concurrency With Task Groups in Swift</a> and <a href=https://www.andyibanez.com/posts/understanding-actors-in-the-new-concurrency-model-in-swift/>Understanding Actors in the New Concurrency Model in Swift</a> articles.</p><h2 id=the-task-tree>The Task Tree</h2><p>An important concept of structured concurrency (for both <code>async let</code> and Task Groups) is the Task Tree.</p><ul><li><code>async</code> functions can spawn other <code>async</code> tasks. These spawned tasks are the <em>children</em> of the task that launched them.</li><li>Children tasks inherit info from their parents, such as priority, local variables, and cancellation.</li><li>It is said that a Parent task can only finish their work when their children have also finished their work.</li><li>Cancellation of a task is governed by the task tree and it is cooperative. When a task is cancelled - either manually via a <code>cancel</code> or <code>cancellAll</code> call, or when they throw an error -, the tasks in the tree are not cancelled instantly. Instead, the task is marked as <code>cancelled</code>, but they continue doing their work until they see it is appropriate to be cancelled. When a parent task is marked as cancelled, its children tasks are marked as <code>cancelled</code> as well.</li><li>To check the cancellation status of a task and determine if you need to stop working, you can use the <code>Task.checkCancellation()</code> method for tasks that may throw errors, or <code>Task.isCancelled</code> for tasks that don&rsquo;t throw.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>try</span> Task.checkCancellation() <span style=color:#6c7086;font-style:italic>// &lt;- If we are cancelled, this throws.</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part3/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.png&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageRequest</span> = URLRequest(url: imageUrl)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (data, imageResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: imageRequest)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data), (imageResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>throw</span> ImageDownloadError.badImage
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To learn more about the Task Tree, check out the <a href=https://www.andyibanez.com/posts/structured-concurrency-in-swift-using-async-let/>Structured Concurrency in Swit: Using async let</a> article.</p><h1 id=unstructured-concurrency>Unstructured Concurrency</h1><p>Unstructured concurrency is useful when you don&rsquo;t have such a procedural flow for your tasks, but they can still help you greatly reduce the amount of unusual execution flows. Unstructured concurrency also gives you more control over structured concurrency.</p><p>There&rsquo;s two ways to do unstructured concurrency: <code>Task</code> calls and detached tasks with <code>Task.detached</code>.</p><h2 id=task>Task</h2><ul><li>When you use <code>Task {}</code>, you are actually launching a concurrent task. This is how the &ldquo;bridge&rdquo; between the async and sync worlds is done.</li><li>You can store them in variables so you can manually cancel them when necessary.</li><li>You can also start them with a specific priority.</li></ul><p>To learn more about Unstructured Concurrency with tasks, check out the <a href=https://www.andyibanez.com/posts/introduction-to-unstructured-concurrency-in-swift/>Introduction to Unstructured Concurrency in Swift</a> article.</p><h2 id=detached-tasks>Detached tasks</h2><ul><li>Launched with <code>Task.detached {}</code>.</li><li>Unlike the other kinds of tasks, they do not inherit anything from their parent tasks. Not even the priority.</li><li>They are independent from the context they are launched in.</li></ul><p>To learn more about Detached Tasks, check out the <a href=https://www.andyibanez.com/posts/unstructured-concurrency-with-detached-tasks-in-swift/>Unstructured Concurrency With Detached Tasks in Swift</a> article.</p><h1 id=actors>Actors</h1><ul><li>Actors are reference types that isolate their state from the rest of the program. This is a perfect mechanism to prevent data races in your program.</li><li>They provide their own internal synchronization for when they are accessed. This prevents data races.</li><li>You cannot modify an actor state directly. Every call that modifies the actor needs to go through the actor itself.</li><li>All the methods the actor provides are exposed through <code>await</code> calls even when you don&rsquo;t explicitly mark them as such.</li><li>Properties are method that don&rsquo;t need to be or can&rsquo;t be isolated can be marked as <code>nonisolated</code>.</li><li>You should take care to design for actor reentrancy (entering the actor multiple times). Because its state changes, you may need to do some considerations. For example, an actor that downloads and caches images may download and cache the same image twice if entered in quick succession.</li></ul><p><a href=https://www.andyibanez.com/posts/understanding-actors-in-the-new-concurrency-model-in-swift/>Understanding Actors in the New Concurrency Model in Swift</a></p><h1 id=mainactor-and-global-actors>@MainActor and Global Actors</h1><ul><li>We can define global actors across different files and types. Marking a class as running on a specific actor ensures that all code will be run in the same thread.</li><li>You declare global actors with the <code>@globalActor</code> attribute, and then you use that actor by referencing its name prepending a <code>@</code>. In the example above, we create an actor called <code>MediaActor</code> and we create a variable called <code>videogames</code> that runs on this actor.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>@globalActor
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>MediaActor</span> {
</span></span><span style=display:flex><span>  actor ActorType { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#f38ba8>static</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>shared</span>: ActorType = ActorType()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>Videogame</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>id</span> = UUID()
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>name</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>releaseYear</span>: <span style=color:#89dceb>Int</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>developer</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@MediaActor <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>videogames</span>: [Videogame] = []
</span></span></code></pre></div><ul><li>The <code>@MainActor</code> is a special global actor provided by Swift that runs on the main thread. We can mark view controllers, view models, and other code that we want to force to run on the main thread as <code>@MainActor</code>. Marking a class with an actor means that all its properties and methods will be run on that same actor. In the example below, we add the <code>@MainActor</code> attribute to a view controller, ensure all its code runs on the main thread.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>@MainActor
</span></span><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>GameLibraryViewController</span>: UIViewController {
</span></span><span style=display:flex><span>	<span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>	nonisolated <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>fetchVideogameTypes</span>() -&gt; [VideogameType] { ... }
</span></span><span style=display:flex><span>	<span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s possible to override the actor of specific methods.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>@MainActor
</span></span><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>GameLibraryViewController</span>: UIViewController {
</span></span><span style=display:flex><span>   @MediaActor <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>doThisInAnotherActor</span>() {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://www.andyibanez.com/posts/mainactor-and-global-actors-in-swift/>@MainActor and Global Actors in Swift</a></p><h1 id=sharing-data-across-tasks-with-tasklocal>Sharing Data Across Tasks with @TaskLocal</h1><ul><li>The <code>@TaskLocal</code> property wrapper can be used to share data across local tasks.</li><li>The tasks should be part of the same tree - detached tasks launched within some task will not inherit them.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>ViewController</span>: UIViewController {
</span></span><span style=display:flex><span>    @TaskLocal <span style=color:#f38ba8>static</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>currentVideogame</span>: Videogame?
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Only static properties can have this property wrapper.</li><li>To write values to them, we need to bind them values.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#cba6f7>override</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>viewDidLoad</span>() {
</span></span><span style=display:flex><span>    <span style=color:#fab387>super</span>.viewDidLoad()
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Do any additional setup after loading the view.</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>vg</span> = Videogame(title: <span style=color:#a6e3a1>&#34;The Legend of Zelda: Ocarina of Time&#34;</span>, year: <span style=color:#fab387>1998</span>)
</span></span><span style=display:flex><span>    <span style=color:#fab387>Self</span>.<span style=color:#f38ba8>$</span>currentVideogame.withValue(vg) {
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// we cam launch some async tasks here that make use of the LocalValue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Reading them is an <code>await</code>ed call.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>expensiveVidegameOperation</span>() async {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>vg</span> = await ViewController.currentVideogame {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;We are processing </span><span style=color:#a6e3a1>\(</span>vg.title<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://www.andyibanez.com/posts/sharing-data-across-tasks-tasklocal-new-swift-concurrency-model/>Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model</a></p><h1 id=asyncsequence-and-asyncstream>AsyncSequence and AsyncStream</h1><ul><li><code>AsyncSequence</code> allows us to receive values over time, <code>await</code>ing them in a loop, or even applying functions such as <code>filter</code>, <code>map</code>, <code>reduce</code> to them.</li></ul><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>loadVideogames</span>() async {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>url</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part11/videogames.csv&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>videogames</span> =
</span></span><span style=display:flex><span>        url
</span></span><span style=display:flex><span>        .lines
</span></span><span style=display:flex><span>        .<span style=color:#89dceb>filter</span> { <span style=color:#f5e0dc>$0</span>.<span style=color:#89dceb>contains</span>(<span style=color:#a6e3a1>&#34;|&#34;</span>) }
</span></span><span style=display:flex><span>        .<span style=color:#89dceb>map</span> { Videogame(rawLine: <span style=color:#f5e0dc>$0</span>) }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>do</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>for</span> <span style=color:#cba6f7>try</span> await videogame <span style=color:#cba6f7>in</span> videogames {
</span></span><span style=display:flex><span>            <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;</span><span style=color:#a6e3a1>\(</span>videogame.title<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1> (</span><span style=color:#a6e3a1>\(</span>videogame.year ?? <span style=color:#fab387>0</span><span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>)&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#cba6f7>catch</span> {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Worth noting that the sequence will not &ldquo;start&rdquo; until we put it in a loop. Applying higher order functions simply limits what will be received in the <code>await for</code> loop.</li><li>Multiple APIs have been updated to support this in WWDC21, including the <code>NSNotificationCenter</code> APIs.</li><li>The <code>AsyncStream</code> object can be used to take a stream of values from somewhere and convert it into something that can be used in a <code>for await</code> loop.</li><li>For example, if you receive GPS updates in real time in a delegate, you can wrap all that up and receive the new coordinates in a loop instead.</li></ul><p><a href=https://www.andyibanez.com/posts/using-asyncsequence-in-swift/>Using AsyncSequence in Swift</a></p><h1 id=credits-and-thanks>Credits and Thanks</h1><p>The articles in this series have quickly become one of my most visited pages on my website since I relaunched it in 2019. Because of that, I have also received a lot feedback from members in the community.</p><p>I want to take a minute to thank everyone who has written me regarding typos or weird phrasing in some sentences. I have taken a lot of care into improving the articles with all your opinions and comments. You have all helped me increase the quality of these articles a lot.</p><p>I have received a lot of emails, and it&rsquo;s really, really hard to name all of you due to the sheer amount of people who wrote to me. So, thank you all so much for helping me improve the quality of my blog. I am also sorry if I could not reply to everyone - I got a lot of email and sometimes I lost track of who I had replied to.</p><p>There is one person in particular I want to mention by name, because he has spent a lot of time going through all the articles in the series and sending very detailed emails with observations and improvements. This person&rsquo;s emails were actually very long, and whenever I received an email from him, I spent a long time working through the fixes. That said, every second I spent working on his recommendations paid off, and this article series is probably one of the things I&rsquo;m very proud of. This person is <a href=https://twitter.com/dennisbirch2>Dennis Birch</a>. Big thanks to Dennis for helping this article series become one of my favorites.</p></article></div></main><footer><div class=container><div class=footer-navigation><a href=https://github.com/AndyIbanez><span class=inline-svg><svg viewBox="0 0 42 40" id="svg4" width="42" height="40"><path fill="currentColor" d="m14.20936 32.20794c0 .16542-.19024.29776-.4301.29776-.27295.0248-.46319-.10752-.46319-.29776.0-.16542.19024-.29776.4301-.29776.24814-.0248.46319.10752.46319.29776zm-2.57234-.3722c-.0579.16542.10753.35566.35566.40528.21505.0827.46319.0.51282-.16542.0496-.16542-.10753-.35566-.35566-.4301-.21505-.0579-.45492.0248-.51282.19024zm3.65586-.14061c-.23986.0579-.40529.21505-.38047.40528.0248.16543.23986.27295.488.21505.23986-.0579.40528-.21505.38047-.38047-.0248-.15715-.24813-.26468-.488-.23986zM20.73531-.19734273e-6C9.2632-.19734273e-6.48748 8.7095398.48748 20.18166c0 9.17273 5.77328 17.02207 14.01964 19.78464 1.05871.19024 1.43091-.46319 1.43091-1.00081.0-.51282-.0248-3.34156-.0248-5.0785.0.0-5.78982 1.24067-7.00568-2.46481.0.0-.94292-2.40691-2.29939-3.02725.0.0-1.8941-1.29857.13234-1.27376.0.0 2.05952.16542 3.19267 2.13396 1.81139 3.19267 4.84691 2.27457 6.02969 1.72868.19023-1.32339.72786-2.24149 1.32338-2.78739-4.62358-.51281-9.28852-1.18278-9.28852-9.13964.0-2.27458.62861-3.416 1.95199-4.87172-.21505-.53763-.9181-2.7543.21506-5.6161302 1.72867-.53762 5.7071 2.2332202 5.7071 2.2332202 1.65424-.46319 3.43254-.70305 5.1943-.70305 1.76176.0 3.54006.23986 5.1943.70305.0.0 3.97843-2.7791202 5.7071-2.2332202 1.13315 2.8701002.4301 5.0785002.21505 5.6161302 1.32339 1.46399 2.13397 2.60542 2.13397 4.87172.0 7.98168-4.87172 8.61856-9.49531 9.13964.76095.65342 1.4061 1.8941 1.4061 3.83782.0 2.78739-.0248 6.23647-.0248 6.9147.0.53763.38047 1.19105 1.43091 1.00082 8.27117-2.74603 13.87903-10.59537 13.87903-19.7681C41.51252 8.7095398 32.20745-.19734273e-6 20.73533-.19734273e-6zM8.52706 28.52727c-.10752.0827-.0827.27295.0579.4301.13234.13234.32258.19024.4301.0827.10753-.0827.0827-.27295-.0579-.4301-.13233-.13234-.32257-.19024-.4301-.0827zM7.63378 27.8573c-.0579.10753.0248.23987.19023.32258.13234.0827.29777.0579.35566-.0579C8.23757 28.01446 8.15487 27.88212 7.98944 27.7994 7.82401 27.7498 7.69168 27.7746 7.63378 27.8573zm2.67986 2.94454c-.13234.10753-.0827.35566.10752.51281.19024.19024.4301.21505.53763.0827.10752-.10752.0579-.35566-.10753-.51281-.18196-.19024-.4301-.21505-.53762-.0827zM9.37072 29.58598c-.13234.0827-.13234.29776.0.488.13234.19023.35566.27295.46319.19023.13234-.10752.13234-.32257.0-.51281-.1158-.19024-.33085-.27295-.46319-.16542z" id="path2" style="stroke-width:.08271171"/></svg>
</span></a><a href=https://x.com/AndyIbanezK><span class=inline-svg><svg viewBox="0 0 50 40" id="svg4" width="50" height="40"><path fill="currentColor" d="m44.56253 9.96871c.0313.43748.0313.87506.0313 1.31254C44.59383 24.62494 34.43764 40 15.87508 40 10.1563 40 4.84383 38.34368.37506 35.4688c.81253.0937 1.5937.12495 2.4375.12495 4.71867.0 9.06249-1.5937 12.53125-4.31245-4.43751-.0938-8.15627-3.00003-9.43754-7.00006.62505.0937 1.25001.15622 1.90632.15622.90622.0 1.81254-.12505 2.65624-.34369C5.84384 23.15619 2.37498 19.09373 2.37498 14.18748v-.12495c1.3437.75 2.90633 1.21875 4.56246 1.28117-2.71876-1.81253-4.49993-4.90624-4.49993-8.40627.0-1.87497.4999-3.59372 1.37496-5.09373 4.96877 6.125 12.43756 10.12493 20.81248 10.56251-.15622-.75001-.25-1.53118-.25-2.31245C24.37495 4.5312 28.87498.0 34.46871.0c2.90623.0 5.53121 1.21875 7.37501 3.1875 2.28118-.43748 4.46867-1.28127 6.40626-2.43749-.75011 2.3438-2.34381 4.31255-4.43751 5.56246 2.03127-.21864 4.00003-.78126 5.81247-1.56244-1.37477 1.99992-3.09362 3.7811-5.06237 5.21868z" id="path2" style="stroke-width:.09619153"/></svg>
</span></a><a href=https://www.linkedin.com/in/andyibanez/><span class=inline-svg><svg viewBox="0 0 41 40" id="svg4" width="41" height="40"><path fill="currentColor" d="M9.45332 40H1.16028V13.29405H9.45332zM5.30234 9.65111c-2.65185.0-4.80279-2.19648-4.80279-4.84832a4.80279 4.80279.0 019.60558.0c0 2.65184-2.15184 4.84832-4.80279 4.84832zM40.49152 40H32.21633V26.99971c0-3.09828-.0625-7.07159-4.3117-7.07159-4.3117.0-4.97243 3.36615-4.97243 6.84837V40H14.64808V13.29405h7.95375v3.64294h.11608c1.10716-2.09827 3.81169-4.3126 7.8466-4.3126 8.39304.0 9.93594 5.52691 9.93594 12.70564V40z" id="path2" style="stroke-width:.08928771"/></svg>
</span></a><a href=https://www.andyibanez.com/posts/index.xml><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m11.435816 34.282008c0 3.15793-2.5599899 5.71793-5.7179299 5.71793s-5.717840022654-2.56-5.717840022654-5.71793c0-3.15794 2.559990022654-5.71793 5.717930022654-5.71793s5.7178399 2.56008 5.7178399 5.71793zm15.68388 4.21873C26.373806 24.697208 15.317496 13.626978 1.4992361 12.880288.68361608 12.836188.46077346e-4 13.491538.46077346e-4 14.308318v4.29186c0 .75134.579460002654 1.38142 1.329190022654 1.43017 9.9849699.65036 17.9886099 8.63408 18.6402999 18.6403.0488.74973.67893 1.3292 1.43018 1.3292h4.29186c.81687 9e-5 1.47223-.68348 1.42812-1.49911zm12.87933.0257C39.249566 17.649718 22.452206.754048 1.4735261.00092799867.66727608-.027972.46077346e-4.623338.46077346e-4 1.430038v4.29177c0 .77008.610270002654 1.39687 1.379730022654 1.42848 17.0694999.6999 30.7701699 14.40316 31.4699899 31.46999.0315.76946.6583 1.37972 1.42848 1.37972h4.29177c.8066-8e-5 1.45794-.66731 1.42901-1.47356z" id="path2" style="stroke-width:.08928544"/></svg>
</span></a><a href=https://www.andyibanez.com/contact><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m39.99999 36.249999c0 2.0711-1.6789 3.75-3.74999 3.75H3.75c-2.07109.0-3.74999-1.6789-3.74999-3.75v-20.56843a3.7499996 3.7499996.0 011.43648-2.95125c1.94633-1.5257 3.55476-2.7628904 12.82812-9.4930404C15.57906 2.2789186 18.18727-.02709136 20 .00024864227 21.81234-.02745136 24.42156 2.2793086 25.73539 3.2371986c9.27242 6.72945 10.88304 7.9683604 12.82812 9.4931204a3.7499996 3.7499996.0 011.43648 2.95125zm-5.13015-15.35976c-.20024-.29125-.60156-.35898-.88586-.14898-1.78476 1.3182-4.33297 3.18008-8.24859 6.02179-1.31445.95828-3.92266 3.26414-5.73539 3.23672-1.81336.0269-4.41867-2.2768-5.73539-3.23672-3.91515-2.8414-6.46359-4.70343-8.24859-6.02179-.2843-.21-.68562-.14227-.88586.14898l-.70875 1.03094a.62484368.62484368.0 00.14367.8568c1.78805 1.32023 4.33235 3.1789 8.2268 6.00531 1.5839 1.15476 4.41593 3.73539 7.20812 3.71664 2.79094.0189 5.62195-2.56024 7.20804-3.71664 3.89453-2.82649 6.43891-4.68516 8.2268-6.00531a.62484368.62484368.0 00.14367-.8568z" id="path2" style="stroke-width:.07812498"/></svg></span></a></div></div><p class=made-with-love><a href=https://github.com/humrochagf/colordrop><b>Colordrop</b>
</a><span>theme | Made </span><span>by</span>
<a href=https://humberto.io/><b>Humberto Rocha</b></a></p></footer></div><script src=/copy/copy.js></script><script src=/search/elasticlunr.min.js></script><script src=/search/search.js></script><script>loadSearch("https://www.andyibanez.com/index.json")</script></body></html>