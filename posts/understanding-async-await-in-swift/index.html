<!doctype html><html prefix="og: http://ogp.me/ns#" lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,user-scalable=no"><meta http-equiv=x-ua-compatible content="ie=edge"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script><link rel=icon type=image/png href=https://www.andyibanez.com/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://www.andyibanez.com/img/favicon-16x16.png sizes=16x16><link rel=canonical href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/><link rel=alternate hreflang=en href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/ title><meta name=description content="Learn about Swift's async/await APIs and how to use them, complete with working examples."><meta name=author content><meta name=theme-color content="#292148"><meta itemprop=name content="Understanding async/await in Swift"><meta itemprop=description content="Learn about Swift's async/await APIs and how to use them, complete with working examples."><meta itemprop=datePublished content="2021-06-16T07:01:00-04:00"><meta itemprop=dateModified content="2021-06-16T07:01:00-04:00"><meta itemprop=wordCount content="3301"><meta itemprop=keywords content="swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading"><meta property="og:url" content="https://www.andyibanez.com/posts/understanding-async-await-in-swift/"><meta property="og:site_name" content="Andy Ibanez"><meta property="og:title" content="Understanding async/await in Swift"><meta property="og:description" content="Learn about Swift's async/await APIs and how to use them, complete with working examples."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-16T07:01:00-04:00"><meta property="article:modified_time" content="2021-06-16T07:01:00-04:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta name=twitter:card content="summary"><meta name=twitter:title content="Understanding async/await in Swift"><meta name=twitter:description content="Learn about Swift's async/await APIs and how to use them, complete with working examples."><meta name=twitter:creator content="@"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","url":"https://www.andyibanez.com/posts/understanding-async-await-in-swift/","headline":"Understanding async/await in Swift","description":"Learn about Swift&#39;s async/await APIs and how to use them, complete with working examples.","datePublished":"2021-06-16","keywords":"swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading","author":{"@type":"Person","name":""}}</script><title>Understanding async/await in Swift - Andy Ibanez</title><link rel=stylesheet href=https://www.andyibanez.com/style.main.min.18f604b90ed15864d7faa967f1ef9eacb99e1c967eff38762ec29b7bf1ab5876.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script></head><body><div class=wrapper><nav><div class=container><div class=language-selector></div></div></nav><header><div class=container><div class=header-group><div class=header-logo-container><a class=header-logo-link href=https://www.andyibanez.com/><img class=header-logo-circle src=https://www.andyibanez.com/img/andy_profile.png alt="Andy Ibanez logo"></a></div><div class=header-title><a href=https://www.andyibanez.com/>Andy Ibanez</a></div></div></div></header><nav><div class=container><div class=main-navigation><a href=/about/>About Me</a><a href=/posts/>Blog</a><a href=/projects/>Projects</a><a href=/tags/>Tags</a><a href=/contact/>Contact</a><a href=/privacy-policy/>Privacy policy</a></div></div></nav><div class=container><div class=search><input type=text id=searchInput placeholder="Type here to search"></div><div class="container search-results-container" hidden=true><div id=searchResults class=search-results></div></div></div><main><div class=container><article><h1 class=title>Understanding async/await in Swift</h1><p class=publish>Published on
<time class=post-date datetime=2021-06-16T07:01:00-04:00>June 16, 2021</time></p><p><em>This article is part of my <a href=/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift</a> article series.</em></p><p><em>This article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.</em></p><h6 id=table-of-contents>Table of Contents</h6><ol><li><a href=/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift: Introduction</a></li><li><strong>Understanding async/await in Swift</strong></li><li><a href=/posts/converting-closure-based-code-into-async-await-in-swift/>Converting closure-based code into async/await in Swift</a></li><li><a href=/posts/structured-concurrency-in-swift-using-async-let/>Structured Concurrency in Swift: Using async let</a></li><li><a href=/posts/structured-concurrency-with-group-tasks-in-swift/>Structured Concurrency With Group Tasks in Swift</a></li><li><a href=/posts/introduction-to-unstructured-concurrency-in-swift/>Introduction to Unstructured Concurrency in Swift</a></li><li><a href=/posts/unstructured-concurrency-with-detached-tasks-in-swift/>Unstructured Concurrency With Detached Tasks in Swift</a></li><li><a href=/posts/understanding-actors-in-the-new-concurrency-model-in-swift/>Understanding Actors in the New Concurrency Model in Swift</a></li><li><a href=/posts/mainactor-and-global-actors-in-swift/>@MainActor and Global Actors in Swift</a></li><li><a href=posts/sharing-data-across-tasks-tasklocal-new-swift-concurrency-model>Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model</a></li><li><a href=/posts/using-asyncsequence-in-swift/>Using AsyncSequence in Swift</a></li><li><a href=/posts/modern-swift-concurrency-summary-cheatsheet-thanks/>Modern Swift Concurrency Summary, Cheatsheet, and Thanks</a></li></ol><hr><p>Before you try to dive in with concurrency in Swift, you need to understand async/await. There&rsquo;s no way around it. While async/await are not the only <a href=https://www.andyibanez.com/posts/multithreading-options-on-apple-platforms/>concurrency options</a>, Apple&rsquo;s SDKs are starting to make heavy use of them. There is no doubt that third-party library providers will start offering these as well.</p><p>This article will explore async/await and nothing else. Once you understand these concepts, we will start moving on to more advanced articles where we cover structured concurrency, unstructured concurrency, SwiftUI, and more.</p><p>If you have been writing callback-based concurrency, keep in mind that the implementation for async/await is <em>very</em> different from anything you have seen before in Apple&rsquo;s technologies. It basically throws what you know about concurrent programming out the window. It&rsquo;s important to keep that in mind as you read this article.</p><p>In this article, we will write a function that downloads an image and then its metadata using a different network call. We will show you how doing this with callback-based concurrency can become hard to manage quickly, and how async/await solves this problem beautifully.</p><h1 id=refreshing-concepts>Refreshing Concepts</h1><h2 id=a-refresher-on-procedural-programming>A Refresher on Procedural Programming</h2><p>When you write any normal program with no exceptional needs such as networking and/or I/O, your program executes in the order your code is written, calling procedures as needed, and returning content to the caller if necessary.</p><p>Consider the following code:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>sayHi</span>() {
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Hi&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>multiply</span>(<span style=color:#fab387>_</span> x: <span style=color:#89dceb>Int</span>, <span style=color:#fab387>_</span> y: <span style=color:#89dceb>Int</span>) -&gt; <span style=color:#89dceb>Int</span> {
</span></span><span style=display:flex><span>    x <span style=color:#89dceb;font-weight:700>*</span> y
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>sayBye</span>(result: <span style=color:#89dceb>Int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Bye </span><span style=color:#a6e3a1>\(</span>result<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>performCoolStuff</span>() {
</span></span><span style=display:flex><span>    sayHi()
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>x</span> = <span style=color:#fab387>10</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>y</span> = <span style=color:#fab387>5</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>result</span> = multiply(x, y)
</span></span><span style=display:flex><span>    sayBye(result: result)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Calling performCoolStuff()</span>
</span></span><span style=display:flex><span>performCoolStuff()
</span></span></code></pre></div><p>When you call <code>performCoolStuff()</code>, your code is executed as follows:</p><ol><li>It will first call <code>sayHi()</code></li><li>It will declare two variables, <code>x</code> and <code>y</code>.</li><li>It will call <code>multiply</code> passing in the values for <code>x</code> and <code>y</code>.</li><li>It will call <code>sayBye</code> with the result of the multiplication</li></ol><p>There&rsquo;s nowhere to get lost here. Your code is called in the same order it was given. Functions that call other functions are placed in the <em>call stack</em> exactly as they appear, unwinding back as they return values to the main callers. As calls happen, the function give back control to the caller through the use of <code>return</code>. When we call <code>multiply</code>, we assign control to it, and when it returns us a result, it gives us back control through <code>return</code>.</p><p>You don&rsquo;t think much about procedural programming. Chances are you do it daily, and it always works the way you expect it to *.</p><h2 id=a-refresher-on-callback-based-concurrency-code>A refresher on callback-based concurrency code.</h2><p>Things are a bit more complicated when it comes to code that may run in parallel with other code. Consider the following example that will download an image through a network call and the metadata through a different network call (you can copy and paste this code in a view controller of a new project - it contains everything you need to run it). The download takes place at the same time as the main thread&rsquo;s execution:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>ImageMetadata</span>: Codable {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>name</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>firstAppearance</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>year</span>: <span style=color:#89dceb>Int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>DetailedImage</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span>: UIImage
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span>: ImageMetadata
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>enum</span> <span style=color:#f9e2af>ImageDownloadError</span>: Error {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>case</span> badImage
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>case</span> invalidMetadata
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>sayHi</span>() {
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Hi&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>multiply</span>(<span style=color:#fab387>_</span> x: <span style=color:#89dceb>Int</span>, <span style=color:#fab387>_</span> y: <span style=color:#89dceb>Int</span>) -&gt; <span style=color:#89dceb>Int</span> {
</span></span><span style=display:flex><span>    x <span style=color:#89dceb;font-weight:700>*</span> y
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>sayBye</span>(result: <span style=color:#89dceb>Int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Bye </span><span style=color:#a6e3a1>\(</span>result<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(
</span></span><span style=display:flex><span>    imageNumber: <span style=color:#89dceb>Int</span>,
</span></span><span style=display:flex><span>    completionHandler: @escaping (<span style=color:#fab387>_</span> image: DetailedImage?, <span style=color:#fab387>_</span> error: Error?) -&gt; <span style=color:#89dceb>Void</span>
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.png&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageTask</span> = URLSession.shared.dataTask(with: imageUrl) { data, response, error <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>data</span> = data, <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data), (response <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            completionHandler(<span style=color:#fab387>nil</span>, ImageDownloadError.badImage)
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.json&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataTask</span> = URLSession.shared.dataTask(with: metadataUrl) { data, response, error <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>data</span> = data, <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span>? JSONDecoder().decode(ImageMetadata.<span style=color:#fab387>self</span>, from: data),  (response <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>                completionHandler(<span style=color:#fab387>nil</span>, ImageDownloadError.invalidMetadata)
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>detailedImage</span> = DetailedImage(image: image, metadata: metadata)
</span></span><span style=display:flex><span>            completionHandler(detailedImage, <span style=color:#fab387>nil</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        metadataTask.resume()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    imageTask.resume()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>performMessyStuff</span>() {
</span></span><span style=display:flex><span>    sayHi()
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>x</span> = <span style=color:#fab387>10</span>
</span></span><span style=display:flex><span>    downloadImageAndMetadata(imageNumber: <span style=color:#fab387>1</span>) { image, error <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>        DispatchQueue.main.async {
</span></span><span style=display:flex><span>            <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;We got results&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>y</span> = <span style=color:#fab387>5</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>result</span> = multiply(x, y)
</span></span><span style=display:flex><span>    sayBye(result: result)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>performMessyStuff()
</span></span></code></pre></div><p><strong>Note</strong>: <em>Apple used a similar example in the <a href=https://developer.apple.com/videos/play/wwdc2021/10132/>Meet async/await in Swift session</a> at WWDC2021. This example is based on that, but I created a compilable version you can use.</em></p><p>This is what happens:</p><ol><li>The method calls <code>sayHi()</code> normally.</li><li>We create a variable <code>x</code> and assign it a value.</li><li><code>downloadImageAndMetadata</code> is called, which internally will set up the first variables it needs for its execution (<code>imageUrl</code>).</li><li>We create a variable, once again synchronously, that will hold a <code>dataTask</code> and provide it with a completion handler that will be called after it&rsquo;s done downloading.</li><li>We call <code>resume()</code> on the task to begin the download.</li><li>The contents of the completion handler will not be executed immediately. Instead, while the downloads happen, the program continues its execution.</li><li>The program may, or may not, print <code>"We got results"</code>. In the case of a network download, it will always take a while, but if this were a faster asynchronous operation, it may be called at this point. The program will create a variable <code>y</code>.</li><li>If both downloads have finished successfully, the program may print <code>"We got results".</code> Otherwise it creates the <code>result</code> variable and calls <code>multiply</code>, which may or may not finish before the downloads.</li><li>If the downloads have finished successfully, the program will print <code>"We got results"</code>, otherwise it will call <code>sayBye</code>.</li><li>Somewhere above there and at any point, the program may start the metadata download task after the image task has downloaded.</li></ol><p>This flow of execution is messy, because downloading data from the network is asynchronous and all its work happens somewhere else. Anything else may happen on the main thread while the downloads take place. Whatever the console prints may have a different output on each run **. The downloads spawn from the main thread onto another thread, but the program will continue executing the code in the main thread without any issue. This makes it hard to think procedurally, because we rely on the <code>completionHandler</code> to let us know when it has finished its work. If there are tasks that can be performed in the main thread, but they depend on an image and/or its metadata, we have to do all that work in the completion handler (while rerouting the work to the main thread with <code>DispatchQueue.main.async</code> whenever relevant).</p><p>In the case of callback-based asynchronous code, control is given back whenever completion handlers are executed.</p><p>And as you may imagine, these calls can become more and more complex and nested.</p><h1 id=introducing-asyncawait>Introducing async/await</h1><p>If I had to explain async/await in few words, I&rsquo;d say this:</p><blockquote><p>async/await is like a hybrid between procedural programming and callback-based closures.</p></blockquote><p>Before we explain why, let&rsquo;s keep two things in mind:</p><ol><li>Procedural code runs from top to bottom. Control is given back to the caller through <code>return</code></li><li>Callback-based concurrency will create asynchronous tasks, but it will continue executing the current thread without an issue, even if those tasks are running. Control is given back to the caller through completion handlers.</li></ol><p>Let&rsquo;s take a few minutes to discuss the <code>async</code> and <code>await</code> keywords individually.</p><h2 id=async>async</h2><p><code>async</code> has two uses:</p><ul><li>To tell the compiler when a piece of code is asynchronous.</li><li>To spawn asynchronous tasks in parallel.</li></ul><p>To mark a function as <code>async</code>, simply put the keyword after the function&rsquo;s closing parenthesis and before the arrow, like this:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(id: <span style=color:#89dceb>Int</span>) async -&gt; UIImage? { ... }
</span></span></code></pre></div><p>Or:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(id: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; UIImage { ... }
</span></span></code></pre></div><p>You can already see a huge advantage here. The completion handler is gone, and our function signature is very clear with its purpose. We can tell at first glance if it is <code>async</code> and what it returns.</p><p><code>async</code> code can only run in <em>concurrent</em> contexts. That is to say, within other <code>async</code> functions, or when manually dispatched via <code>Task {}</code>. We will explore <code>Task {}</code> in a bit.</p><h2 id=await>await</h2><p><code>await</code> is where the magic happens. Whenever the program finds the <code>await</code> keywords, it has the option of suspending the function. It may or may not do so, and the decision is up to the system.</p><p>If the system does suspend the function, <code>await</code> will return control, not to the caller, but to the system. The system will then use the thread to perform other work until the suspended function is done. The statements below <code>await</code> will not be executed until it has finished. The system decides what&rsquo;s important to execute, and at some point, it will return control back to you after it sees the <code>await</code>ed function has finished.</p><p>You can think of it as a traffic light. If you are driving down the road and you find a red light, chances are you will stop. But if it is 4 AM in the morning and there&rsquo;s no cars coming you may just run it. ***</p><p><strong>What you need to understand about await is that, if it does choose to suspend, nothing below it will execute until the system tells it to, and the system will use the thread to do other work.</strong></p><p>Every call to an <code>async</code> function, must be marked as <code>await</code>.</p><p>To better understand this, we will rewrite our <code>downloadImageAndMetadata</code> function, this time using <code>async</code> and using <code>await</code> within the body.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// Attempt to download the image first.</span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.png&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageRequest</span> = URLRequest(url: imageUrl)
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> (imageData, imageResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: imageRequest)
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: imageData), (imageResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>throw</span> ImageDownloadError.badImage
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// If there were no issues, continue downloading the metadata.</span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.json&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataRequest</span> = URLRequest(url: metadataUrl)
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> (metadataData, metadataResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: metadataRequest)
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>guard</span> (metadataResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>throw</span> ImageDownloadError.invalidMetadata
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>detailedImage</span> = DetailedImage(image: image, metadata: <span style=color:#cba6f7>try</span> JSONDecoder().decode(ImageMetadata.<span style=color:#fab387>self</span>, from: metadataData))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> detailedImage
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>This is a long function, but it&rsquo;s already much better than the pyramid version of it. Let&rsquo;s highlight the important parts first:</p><ol><li>The program procedurally creates <code>imageUrl</code> and <code>imageRequest</code>.</li><li>The program reaches a call to an async call, <code>URLSession.shared.data(for:)</code>.</li><li>The program will make a decision on suspending the function or continuing it. In this case, it&rsquo;s likely it will suspend due to the nature of networking, but don&rsquo;t get used to taking that for granted. We will assume the program suspends the function.</li><li>This will give control back to the system.</li><li>The system may do other work that is not relevant to this task while the download <code>await</code>s.</li><li>Anything under the first await <em>will not</em> be executed. It will not reach the guard, it will not create the variables for the metadata, it will do <em>nothing</em> until the <code>await</code>ed function finishes.</li><li>After some time, the system will give control back to you, after the <code>await</code>ed function has finished.</li><li>The <code>guard</code> statement is reached, throwing an error if necessary.</li><li>The program will repeat steps 2-8 but for the metadata task.</li><li>The program will return a new <code>DetailedImage</code>.</li></ol><p>As you can see, it is a pretty linear flow, and the way <code>await</code> suspends the rest of the execution until the system deems it necessary makes it behave very much like procedural programming.</p><p>We can separate that function into different functions as well:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = <span style=color:#cba6f7>try</span> await downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span> await downloadMetadata(<span style=color:#cba6f7>for</span>: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> DetailedImage(image: image, metadata: metadata)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImage</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; UIImage {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.png&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageRequest</span> = URLRequest(url: imageUrl)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (data, imageResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: imageRequest)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data), (imageResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>throw</span> ImageDownloadError.badImage
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> image
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadMetadata</span>(<span style=color:#cba6f7>for</span> id: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; ImageMetadata {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>id<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.json&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataRequest</span> = URLRequest(url: metadataUrl)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (data, metadataResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: metadataRequest)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> (metadataResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>throw</span> ImageDownloadError.invalidMetadata
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> JSONDecoder().decode(ImageMetadata.<span style=color:#fab387>self</span>, from: data)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As long as we mark the functions as <code>async</code>, this is possible to do.</p><p>It is important to note the linearity of this. The metadata and image <strong>are not being downloaded at the same time</strong>. It will download the image first, and the metadata later. We can make it download both the image and metadata at the same time, but this article is not about actual concurrency just yet. We will explore how to do both tasks at the same time when we learn about <em>structured concurrency</em>.</p><p>If you want to see the function suspension in action, simply put some print statements before and after <code>await</code> code. You will see that the print statements will be executed slowly, as the system suspends the download tasks, perform other tasks, and gives control back to you.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Will download image&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = <span style=color:#cba6f7>try</span> await downloadImage(imageNumber: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Has downloaded image&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Will download metadata&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span> await downloadMetadata(<span style=color:#cba6f7>for</span>: imageNumber)
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Has downloaded metadata&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> DetailedImage(image: image, metadata: metadata)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If your internet is a bit too speedy to appreciate the slow prints, Apple provides us a neat method: <code>Task.sleep</code>. This function solely exists to sleep the thread for a given number of time, and you can use it to explore async/await.</p><ul><li><strong>Note</strong>: <em>Unfortunately <code>Task.sleep</code> appears to crash as of Xcode 13 Beta 1. <code>await Task.sleep(2 * 1_000_000_000) </code>.</em></li></ul><p>One final important note about <code>await</code>: It&rsquo;s not guaranteed that the same thread that executed the code above it is the same one that will execute the code below it (commonly called the <em>continuation</em>). This has important implications when dealing with UI. If you use <code>await</code> in a context that needs the main thread such as a ViewController, make sure you mark the functions with <code>await</code> with the <code>@MainActor</code> attribute, or add the attribute to the entire class declaration. If you want a complete tour behind how the new concurrency works in Swift, check out the <a href=https://developer.apple.com/videos/play/wwdc2021/10254/>Swift concurrency: Behind the scenes</a> WWDC2021 session talk.</p><h2 id=bridging-between-the-sync-and-async-worlds-with-task>&ldquo;Bridging&rdquo; between the sync and async worlds with Task</h2><p>We can create a &ldquo;bridge&rdquo; between the sync and async worlds creating a <code>Task</code>. To understand why this is necessary, consider the following piece of code:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>performDownload</span>() {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageDetail</span> = <span style=color:#cba6f7>try</span>? await downloadMetadata(<span style=color:#cba6f7>for</span>: <span style=color:#fab387>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The compiler will protect us from erroneously running this, showing the following error:</p><blockquote><p>&lsquo;async&rsquo; call in a function that does not support concurrency
Add &lsquo;async&rsquo; to function &lsquo;performDownload()&rsquo; to make it asynchronous</p></blockquote><p>The compiler is suggesting we mark <code>performDownload</code> as async.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>performDownload</span>() async {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageDetail</span> = <span style=color:#cba6f7>try</span>? await downloadMetadata(<span style=color:#cba6f7>for</span>: <span style=color:#fab387>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But this is not always possible. What if <code>performDownload</code> is in a view controller or in another place that can&rsquo;t give you an asynchronous context?</p><p>To fix this, we can bridge this synchronous function to the asynchronous world using <code>Task {}</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>performDownload</span>() {
</span></span><span style=display:flex><span>    Task {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageDetail</span> = <span style=color:#cba6f7>try</span>? await downloadMetadata(<span style=color:#cba6f7>for</span>: <span style=color:#fab387>1</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We are explicitly creating an asynchronous context, and it will behave as such. We can now call perform download from any sync context without an issue.</p><h2 id=get-async>get async</h2><p>To make things even better, properties that are read-only can be <code>await</code>ed.</p><p>Suppose you have the following wrapper object:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>Character</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>id</span>: <span style=color:#89dceb>Int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can get its image and metadata by calling <code>downloadImageAndMetadata</code>, but you could also give this object two calculated properties to get its image and/or metadata independently.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>Character</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>id</span>: <span style=color:#89dceb>Int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>metadata</span>: ImageMetadata {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>get</span> async <span style=color:#cba6f7>throws</span> {
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span> await downloadMetadata(<span style=color:#cba6f7>for</span>: id)
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span> metadata
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>image</span>: UIImage {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>get</span> async <span style=color:#cba6f7>throws</span> {
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> await downloadImage(imageNumber: id)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And we can use it as such:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span>? await character.metadata
</span></span></code></pre></div><h1 id=summary>Summary</h1><p>This was a long introduction to async/await, but hopefully the included examples and discussion will help you understand how this works. <code>async/await</code> are the heart of the new concurrency system, so you need to have a fine grasp of them. Future articles may not be as long. Generally, covering the basics of something requires a lot of effort as it&rsquo;s important to not miss any details. Hopefully this article will be of use to you.</p><p>I have created a sample project that makes use of the downloaded image and metadata in a UIKit project. You can download it from <a href=/archives/AsyncAwaitIntro.zip>here</a>.</p><p>When ran, the program will simply download the contents and display them like this:</p><p><img src=/img/async_await_part_1.png alt="async/await Tutorial 1 result"></p><p>On the <code>viewDidAppear</code> method, you will find the following code:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#cba6f7>override</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>viewDidAppear</span>(<span style=color:#fab387>_</span> animated: <span style=color:#89dceb>Bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#fab387>super</span>.viewDidAppear(animated)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// </span><span style=color:#6c7086;font-style:italic>MARK:</span><span style=color:#6c7086;font-style:italic> METHOD 1 - Using Async/Await</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Task {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageDetail</span> = <span style=color:#cba6f7>try</span>? await downloadImageAndMetadata(imageNumber: <span style=color:#fab387>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#fab387>self</span>.imageView.image = imageDetail.image
</span></span><span style=display:flex><span>            <span style=color:#fab387>self</span>.metadata.text = <span style=color:#a6e3a1>&#34;</span><span style=color:#a6e3a1>\(</span>imageDetail.metadata.name<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1> (</span><span style=color:#a6e3a1>\(</span>imageDetail.metadata.firstAppearance<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1> - </span><span style=color:#a6e3a1>\(</span>imageDetail.metadata.year<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>)&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// </span><span style=color:#6c7086;font-style:italic>MARK:</span><span style=color:#6c7086;font-style:italic> METHOD 2 - Using async properties</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//        Task {</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//            let character = Character(id: 1)</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//            if</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//                let metadata = try? await character.metadata,</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//                let image = try? await character.image{</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//                imageView.image = image</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//                self.metadata.text = &#34;\(metadata.name) (\(metadata.firstAppearance) - \(metadata.year))&#34;</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//            }</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//        }</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// </span><span style=color:#6c7086;font-style:italic>MARK:</span><span style=color:#6c7086;font-style:italic> Method 3 - Using Callbacks</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//        downloadImageAndMetadata(imageNumber: 1) { imageDetail, error in</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//            DispatchQueue.main.async {</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//                if let imageDetail = imageDetail {</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//                    self.imageView.image = imageDetail.image</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//                    self.metadata.text =  &#34;\(imageDetail.metadata.name) (\(imageDetail.metadata.firstAppearance) - \(imageDetail.metadata.year))&#34;</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//                }</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//            }</span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//        }</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You can comment and uncomment everything under <code>MARK: - Method x</code> to fill the outlets with the data provided by the different methods of getting the data. Hopefully you can play around with this to get a better hang of how <code>async/await</code> work in Swift.</p><p>I want to revisit these two points I made earlier:</p><blockquote><ol><li>Procedural code runs from top to bottom. Control is given back to the caller through <code>return</code></li><li>Callback-based concurrency will create asynchronous tasks, but it will continue executing the current thread without an issue, even if those tasks are running. Control is given back to the caller through completion handlers.</li></ol></blockquote><p>We can now append one more thing to summarize:</p><blockquote><p>3 async/await will run in order just like procedural programming. When it finds an <code>await</code> call, the job will suspend and will give control back to the system instead of the caller. Unlike callback-based concurrency, it will not continue execution of the statements under it until it has finished. The system will make use of the thread to perform other work, and when it decides it&rsquo;s time to revisit your function, it will, and execution will resume linearly.</p></blockquote><p>When you are ready, you can proceed to the third article in the series, <a href=/posts/converting-closure-based-code-into-async-await-in-swift/>Converting Closure-based code into async/await in Swift</a> to learn more about continuations, explicit continuations, and how to bridge closure-based and delegate-based code into async/await.</p><h3 id=notes>Notes</h3><p>*: Well, except when you put bugs in.</p><p>**: This is not obvious in this example, but there exists asynchronous code that is much faster than a network call and it may finish much faster than expected, altering the output of the console on each run.</p><p>***: Drive responsibly.</p></article></div></main><footer><div class=container><div class=footer-navigation><a href=https://github.com/AndyIbanez><span class=inline-svg><svg viewBox="0 0 42 40" id="svg4" width="42" height="40"><path fill="currentColor" d="m14.20936 32.20794c0 .16542-.19024.29776-.4301.29776-.27295.0248-.46319-.10752-.46319-.29776.0-.16542.19024-.29776.4301-.29776.24814-.0248.46319.10752.46319.29776zm-2.57234-.3722c-.0579.16542.10753.35566.35566.40528.21505.0827.46319.0.51282-.16542.0496-.16542-.10753-.35566-.35566-.4301-.21505-.0579-.45492.0248-.51282.19024zm3.65586-.14061c-.23986.0579-.40529.21505-.38047.40528.0248.16543.23986.27295.488.21505.23986-.0579.40528-.21505.38047-.38047-.0248-.15715-.24813-.26468-.488-.23986zM20.73531-.19734273e-6C9.2632-.19734273e-6.48748 8.7095398.48748 20.18166c0 9.17273 5.77328 17.02207 14.01964 19.78464 1.05871.19024 1.43091-.46319 1.43091-1.00081.0-.51282-.0248-3.34156-.0248-5.0785.0.0-5.78982 1.24067-7.00568-2.46481.0.0-.94292-2.40691-2.29939-3.02725.0.0-1.8941-1.29857.13234-1.27376.0.0 2.05952.16542 3.19267 2.13396 1.81139 3.19267 4.84691 2.27457 6.02969 1.72868.19023-1.32339.72786-2.24149 1.32338-2.78739-4.62358-.51281-9.28852-1.18278-9.28852-9.13964.0-2.27458.62861-3.416 1.95199-4.87172-.21505-.53763-.9181-2.7543.21506-5.6161302 1.72867-.53762 5.7071 2.2332202 5.7071 2.2332202 1.65424-.46319 3.43254-.70305 5.1943-.70305 1.76176.0 3.54006.23986 5.1943.70305.0.0 3.97843-2.7791202 5.7071-2.2332202 1.13315 2.8701002.4301 5.0785002.21505 5.6161302 1.32339 1.46399 2.13397 2.60542 2.13397 4.87172.0 7.98168-4.87172 8.61856-9.49531 9.13964.76095.65342 1.4061 1.8941 1.4061 3.83782.0 2.78739-.0248 6.23647-.0248 6.9147.0.53763.38047 1.19105 1.43091 1.00082 8.27117-2.74603 13.87903-10.59537 13.87903-19.7681C41.51252 8.7095398 32.20745-.19734273e-6 20.73533-.19734273e-6zM8.52706 28.52727c-.10752.0827-.0827.27295.0579.4301.13234.13234.32258.19024.4301.0827.10753-.0827.0827-.27295-.0579-.4301-.13233-.13234-.32257-.19024-.4301-.0827zM7.63378 27.8573c-.0579.10753.0248.23987.19023.32258.13234.0827.29777.0579.35566-.0579C8.23757 28.01446 8.15487 27.88212 7.98944 27.7994 7.82401 27.7498 7.69168 27.7746 7.63378 27.8573zm2.67986 2.94454c-.13234.10753-.0827.35566.10752.51281.19024.19024.4301.21505.53763.0827.10752-.10752.0579-.35566-.10753-.51281-.18196-.19024-.4301-.21505-.53762-.0827zM9.37072 29.58598c-.13234.0827-.13234.29776.0.488.13234.19023.35566.27295.46319.19023.13234-.10752.13234-.32257.0-.51281-.1158-.19024-.33085-.27295-.46319-.16542z" id="path2" style="stroke-width:.08271171"/></svg>
</span></a><a href=https://x.com/AndyIbanezK><span class=inline-svg><svg viewBox="0 0 50 40" id="svg4" width="50" height="40"><path fill="currentColor" d="m44.56253 9.96871c.0313.43748.0313.87506.0313 1.31254C44.59383 24.62494 34.43764 40 15.87508 40 10.1563 40 4.84383 38.34368.37506 35.4688c.81253.0937 1.5937.12495 2.4375.12495 4.71867.0 9.06249-1.5937 12.53125-4.31245-4.43751-.0938-8.15627-3.00003-9.43754-7.00006.62505.0937 1.25001.15622 1.90632.15622.90622.0 1.81254-.12505 2.65624-.34369C5.84384 23.15619 2.37498 19.09373 2.37498 14.18748v-.12495c1.3437.75 2.90633 1.21875 4.56246 1.28117-2.71876-1.81253-4.49993-4.90624-4.49993-8.40627.0-1.87497.4999-3.59372 1.37496-5.09373 4.96877 6.125 12.43756 10.12493 20.81248 10.56251-.15622-.75001-.25-1.53118-.25-2.31245C24.37495 4.5312 28.87498.0 34.46871.0c2.90623.0 5.53121 1.21875 7.37501 3.1875 2.28118-.43748 4.46867-1.28127 6.40626-2.43749-.75011 2.3438-2.34381 4.31255-4.43751 5.56246 2.03127-.21864 4.00003-.78126 5.81247-1.56244-1.37477 1.99992-3.09362 3.7811-5.06237 5.21868z" id="path2" style="stroke-width:.09619153"/></svg>
</span></a><a href=https://www.linkedin.com/in/andyibanez/><span class=inline-svg><svg viewBox="0 0 41 40" id="svg4" width="41" height="40"><path fill="currentColor" d="M9.45332 40H1.16028V13.29405H9.45332zM5.30234 9.65111c-2.65185.0-4.80279-2.19648-4.80279-4.84832a4.80279 4.80279.0 019.60558.0c0 2.65184-2.15184 4.84832-4.80279 4.84832zM40.49152 40H32.21633V26.99971c0-3.09828-.0625-7.07159-4.3117-7.07159-4.3117.0-4.97243 3.36615-4.97243 6.84837V40H14.64808V13.29405h7.95375v3.64294h.11608c1.10716-2.09827 3.81169-4.3126 7.8466-4.3126 8.39304.0 9.93594 5.52691 9.93594 12.70564V40z" id="path2" style="stroke-width:.08928771"/></svg>
</span></a><a href=https://www.andyibanez.com/blog/index.xml><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m11.435816 34.282008c0 3.15793-2.5599899 5.71793-5.7179299 5.71793s-5.717840022654-2.56-5.717840022654-5.71793c0-3.15794 2.559990022654-5.71793 5.717930022654-5.71793s5.7178399 2.56008 5.7178399 5.71793zm15.68388 4.21873C26.373806 24.697208 15.317496 13.626978 1.4992361 12.880288.68361608 12.836188.46077346e-4 13.491538.46077346e-4 14.308318v4.29186c0 .75134.579460002654 1.38142 1.329190022654 1.43017 9.9849699.65036 17.9886099 8.63408 18.6402999 18.6403.0488.74973.67893 1.3292 1.43018 1.3292h4.29186c.81687 9e-5 1.47223-.68348 1.42812-1.49911zm12.87933.0257C39.249566 17.649718 22.452206.754048 1.4735261.00092799867.66727608-.027972.46077346e-4.623338.46077346e-4 1.430038v4.29177c0 .77008.610270002654 1.39687 1.379730022654 1.42848 17.0694999.6999 30.7701699 14.40316 31.4699899 31.46999.0315.76946.6583 1.37972 1.42848 1.37972h4.29177c.8066-8e-5 1.45794-.66731 1.42901-1.47356z" id="path2" style="stroke-width:.08928544"/></svg>
</span></a><a href=https://www.andyibanez.com/curriculum/><span class=inline-svg><svg viewBox="0 0 15680 20480" id="svg4" width="35" height="40"><path fill="currentColor" d="M11655.83 12824.48 7840.0001 16640.464 4024.17 12824.48c-2859.863 123.906-5143.7701 2463.775-5143.7701 5352.003v384.005c0 1059.853 859.96601 1919.512 1919.92167 1919.512H14879.678c1059.956.0 1919.922-859.659 1919.922-1919.512v-384.005c0-2888.228-2283.906-5228.097-5143.77-5352.003zM-575.64445 3193.1279l256.0032 59.9048v2335.7732c-279.9651 167.9381-479.9548 459.7818-479.9548 812.0422.0 335.8762 183.9639 615.9437 443.96075 787.9778l-623.9822 2491.9352c-67.9944 275.9716 84.02025 559.6229 303.9782 559.6229H996.31762c219.95798.0 371.97268-283.6513 303.97828-559.6229L676.31362 7188.8259c259.99685-172.0341 443.96078-452.1016 443.96078-787.9778.0-352.2604-199.98973-644.1041-479.95483-812.0422V3484.9716l2639.90503 635.9119c-344.0171 688.1366-559.9814 1456.1463-559.9814 2279.9646.0 2827.8113 2291.8942 5119.5519 5119.7569 5119.5519 2827.8619.0 5119.7569-2291.7406 5119.7569-5119.5519.0-823.8183-211.971-1591.828-559.982-2279.9646l3851.824-927.7556c727.971-176.1302 727.971-1083.9175.0-1260.0477L8635.9653 92.929226c-519.9937-123.905551-1067.943-123.905551-1587.9367.0L-575.64445 1928.9841c-723.92585 176.1302-723.92585 1088.0136.0 1264.1438z" id="path2" style="stroke-width:39.99821472"/></svg>
</span></a><a href=https://www.andyibanez.com/contact-me><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m39.99999 36.249999c0 2.0711-1.6789 3.75-3.74999 3.75H3.75c-2.07109.0-3.74999-1.6789-3.74999-3.75v-20.56843a3.7499996 3.7499996.0 011.43648-2.95125c1.94633-1.5257 3.55476-2.7628904 12.82812-9.4930404C15.57906 2.2789186 18.18727-.02709136 20 .00024864227 21.81234-.02745136 24.42156 2.2793086 25.73539 3.2371986c9.27242 6.72945 10.88304 7.9683604 12.82812 9.4931204a3.7499996 3.7499996.0 011.43648 2.95125zm-5.13015-15.35976c-.20024-.29125-.60156-.35898-.88586-.14898-1.78476 1.3182-4.33297 3.18008-8.24859 6.02179-1.31445.95828-3.92266 3.26414-5.73539 3.23672-1.81336.0269-4.41867-2.2768-5.73539-3.23672-3.91515-2.8414-6.46359-4.70343-8.24859-6.02179-.2843-.21-.68562-.14227-.88586.14898l-.70875 1.03094a.62484368.62484368.0 00.14367.8568c1.78805 1.32023 4.33235 3.1789 8.2268 6.00531 1.5839 1.15476 4.41593 3.73539 7.20812 3.71664 2.79094.0189 5.62195-2.56024 7.20804-3.71664 3.89453-2.82649 6.43891-4.68516 8.2268-6.00531a.62484368.62484368.0 00.14367-.8568z" id="path2" style="stroke-width:.07812498"/></svg></span></a></div></div><p class=made-with-love><a href=https://github.com/humrochagf/colordrop><b>Colordrop</b>
</a><span>theme | Made </span><span>by</span>
<a href=https://humberto.io/><b>Humberto Rocha</b></a></p></footer></div><script src=/copy/copy.js></script><script src=/search/elasticlunr.min.js></script><script src=/search/search.js></script><script>loadSearch()</script></body></html>