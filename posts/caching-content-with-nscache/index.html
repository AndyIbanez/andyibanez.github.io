<!doctype html><html prefix="og: http://ogp.me/ns#" lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,user-scalable=no"><meta http-equiv=x-ua-compatible content="ie=edge"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script><link rel=icon type=image/png href=https://www.andyibanez.com/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://www.andyibanez.com/img/favicon-16x16.png sizes=16x16><link rel=canonical href=https://www.andyibanez.com/posts/caching-content-with-nscache/><link rel=alternate hreflang=en href=https://www.andyibanez.com/posts/caching-content-with-nscache/ title><meta name=description content="Learn to cache content on Apple's Platforms with NSCache, a high-level native caching API."><meta name=author content><meta name=theme-color content="#292148"><meta itemprop=name content="Caching Content With NSCache"><meta itemprop=description content="Learn to cache content on Apple's Platforms with NSCache, a high-level native caching API."><meta itemprop=datePublished content="2019-08-28T07:00:00-04:00"><meta itemprop=dateModified content="2019-08-28T07:00:00-04:00"><meta itemprop=wordCount content="1917"><meta itemprop=keywords content="swift,caching,ios,tvos,ipados,watchos"><meta property="og:url" content="https://www.andyibanez.com/posts/caching-content-with-nscache/"><meta property="og:site_name" content="Andy Ibanez"><meta property="og:title" content="Caching Content With NSCache"><meta property="og:description" content="Learn to cache content on Apple's Platforms with NSCache, a high-level native caching API."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-28T07:00:00-04:00"><meta property="article:modified_time" content="2019-08-28T07:00:00-04:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Ios"><meta property="article:tag" content="Macos"><meta property="article:tag" content="Tvos"><meta name=twitter:card content="summary"><meta name=twitter:title content="Caching Content With NSCache"><meta name=twitter:description content="Learn to cache content on Apple's Platforms with NSCache, a high-level native caching API."><meta name=twitter:creator content="@"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","url":"https://www.andyibanez.com/posts/caching-content-with-nscache/","headline":"Caching Content With NSCache","description":"Learn to cache content on Apple&#39;s Platforms with NSCache, a high-level native caching API.","datePublished":"2019-08-28","keywords":"swift,programming,apple,ios,macos,tvos,watchos,ipados","author":{"@type":"Person","name":""}}</script><title>Caching Content With NSCache - Andy Ibanez</title><link rel=stylesheet href=https://www.andyibanez.com/style.main.min.18f604b90ed15864d7faa967f1ef9eacb99e1c967eff38762ec29b7bf1ab5876.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script></head><body><div class=wrapper><nav><div class=container><div class=language-selector></div></div></nav><header><div class=container><div class=header-group><div class=header-logo-container><a class=header-logo-link href=https://www.andyibanez.com/><img class=header-logo-circle src=https://www.andyibanez.com/img/andy_profile.png alt="Andy Ibanez logo"></a></div><div class=header-title><a href=https://www.andyibanez.com/>Andy Ibanez</a></div></div></div></header><nav><div class=container><div class=main-navigation><a href=/about/>About Me</a><a href=/posts/>Blog</a><a href=/projects/>Projects</a><a href=/tags/>Tags</a><a href=/contact/>Contact</a><a href=/privacy-policy/>Privacy policy</a></div></div></nav><div class=container><div class=search><input type=text id=searchInput placeholder="Type here to search"></div><div class="container search-results-container" hidden=true><div id=searchResults class=search-results></div></div></div><main><div class=container><article><h1 class=title>Caching Content With NSCache</h1><p class=publish>Published on
<time class=post-date datetime=2019-08-28T07:00:00-04:00>August 28, 2019</time></p><p>When we are working with apps on iOS, iPadOS, macOS, watchOS, or TVOS, it&rsquo;s possible that at some point we will have to store and retrieve a lot of temporary data throughout the lifecycle of our software. Depending on our needs, we may need to cache data on disk and manually manage it ourselves, or we may only need it to cache it in memory. In the case of the latter, Apple offers <code>NSCache</code>, a mutable collection that lets us cache files in memory using key-value pairs.</p><p><code>NSCache</code> is really nice for a few reasons:</p><ul><li>It stores data in memory only. If our app gets killed, this memory is freed up and it&rsquo;s not persisted to disk.</li><li>The key-value pair mechanism lets us very easily set and get cached content. Very similar to what we would do with a <code>Dictionary</code>. Unlike a dictionary, the keys are not copied, so it&rsquo;s slightly more memory efficient.</li><li>We can set automatic eviction conditions to help <code>NSCache</code> delete objects automatically. We can also manually evict objects if we need to.</li><li>It is multi-threading friendly. We can read and write the cache without having to manage threading ourselves.</li></ul><p>And there is just one reason it is not perfect:</p><ul><li>It&rsquo;s an Objective-C API, so you will end up doing some casting, even when working with basic objects such as strings.</li></ul><p>Use <code>NSCache</code> to store temporary objects that are expensive to create, but can be re-created if necessary. Suppose we have an app that downloads a lot of images to display to the user dynamically and they are very big - downloading them takes a long time and they consume a lot of data. It would be bad to re-download them these images every time the user needed them, so we can cache them instead. If at some point the system starts demanding memory, the system can just remove these images and we can re-download them if necessary.</p><p><code>NSCache</code> is available in all of Apple&rsquo;s Platforms: watchOS, iOS, iPadOS, macOS, and TVOS.</p><h1 id=nscache-basics>NSCache Basics</h1><h2 id=creating-a-nscache-object>Creating a NSCache Object</h2><p>The constructor of the <code>NSCache</code> object takes two generic objects: The key type, and the cached object type. We can optionally give it a name to identify it later.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>cache</span> = NSCache&lt;NSString, UIImage&gt;()
</span></span><span style=display:flex><span>cache.name = <span style=color:#a6e3a1>&#34;Remote Image Cache&#34;</span>
</span></span></code></pre></div><p>This API has its roots in the Objective-C days, and as such the generic parameters are constrained to conform to <code>AnyObject</code>, meaning that we cannot use <code>struct</code>s and must uses <code>class</code>es instead. For that reason we must use <code>NSString</code> instead of <code>String</code>. Both our keys and objects can be of any type as long as they are classes. In this example we chose strings for the keys, and images for the objects.</p><h2 id=storing-objects>Storing Objects</h2><p>Storing an object is as easy as calling the cache&rsquo;s <code>setObject</code> method.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>webImage</span> = UIImage(named: <span style=color:#a6e3a1>&#34;pullip_doll.png&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>cache.setObject(webImage, forKey: <span style=color:#a6e3a1>&#34;top banner&#34;</span>)
</span></span></code></pre></div><p>There is also an overloaded <code>setObject(object:forKey:cost:)</code> method, which we will talk about in a bit.</p><p><em>(I&rsquo;d love it if the API offered a subscript for this kind of task, but sadly that&rsquo;s not the case.)</em></p><h2 id=retrieving-objects>Retrieving Objects</h2><p>Retrieving objects is just as easy. There&rsquo;s just one method called <code>object(forKey:)</code>. This method returns an optional <code>ObjectType</code> (in our case, an optional <code>UIImage</code>), so we can easily check if the object exists. Whether the object no longer exists or it has been evicted, it will return <code>nil</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>webImage</span> = cache.object(forKey: <span style=color:#a6e3a1>&#34;top banner&#34;</span>) {
</span></span><span style=display:flex><span>		<span style=color:#6c7086;font-style:italic>// Do something with webImage</span>
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;The object is still cached&#34;</span>)
</span></span><span style=display:flex><span>} <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Web image went away&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>(Just like before there&rsquo;s no native subscript for this.)</em></p><h2 id=removing-objects>Removing Objects</h2><p>Deleting objects does not possess any kind of complexity, and there&rsquo;s methods to evict either a single object or the entire cache.</p><p>To remove a single object, just call the cache&rsquo;s <code>removeObject(forKey:)</code> method.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>cache.removeObject(forKey: <span style=color:#a6e3a1>&#34;top banner&#34;</span>)
</span></span></code></pre></div><p>And to remove all the objects, simply call <code>removeAllObjects()</code> on the cache.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>cache.removeAllObjects()
</span></span></code></pre></div><h1 id=automatic-eviction-conditions>Automatic Eviction Conditions</h1><p>Having manual control over the cache is important and it&rsquo;s going to be enough for many cases, but <code>NSCache</code> allows us to set conditions to automatically clean after itself. We can constrain it to hold a limited amount of objects, and we can specify a maximum &ldquo;cost&rdquo;.</p><p>Even when we don&rsquo;t set any eviction conditions, <code>NSCache</code> will start deleting objects if the system is really hungry for memory, so we cannot count on our objects always being there, even we don&rsquo;t set any eviction conditions ourselves.</p><h2 id=limiting-the-amount-of-objects-in-the-cache>Limiting the Amount of Objects in the Cache</h2><p>To limit the amount of objects our cache should hold, set the <code>countLimit</code> property to anything higher than 0. <code>0</code> means no limit, so the cache will keep storing objects indefinitely (unless the system really needs some memory, that is).</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>cache.countLimit = <span style=color:#fab387>10</span>
</span></span></code></pre></div><p>What a good size is depends strictly on our application. If we are dealing with big images, we can set a low number here, but in the case of something smaller, such as strings, it can probably be way higher.</p><p>It&rsquo;s worth noting that this is not a strict limit. The eviction of objects is governed by the implementation of the cache. If the cache goes over the limit, it may remove objects instantly, at a later moment, or possibly even never. It will all depend on the needs of the system at a given time.</p><h2 id=setting-a-maximum-cost>Setting a Maximum Cost</h2><h3 id=definition-of-cache-object-cost>Definition of Cache Object Cost</h3><p>The &ldquo;cost&rdquo; of an object in the cache is a bit abstract, and it depends on the context in which a cache is operating.</p><p>Let&rsquo;s go back to the example of storing images in the cache. We can define the &ldquo;cost&rdquo; of an image as its size in bytes. A bigger image will have a bigger cost. We could find a different definition, such as its size in dimensions (it&rsquo;s weight and height).</p><p>If you wanted to store strings, you could define the &ldquo;cost&rdquo; based on the number of characters in each string. So the string <code>"Pullip Classical Alice"</code> (22 characters) has a bigger cost than <code>"Pullip Alura"</code> (12 characters).</p><h3 id=limiting-the-maximum-total-cost-of-the-cache>Limiting the Maximum Total Cost of the Cache</h3><p>To set the maximum cost, set the <code>totalCostLimit</code> property of the cache. This number is an <code>Int</code>, and once again, what exactly it represents depends on the context of each cache.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// For our image cache, we will set a maximum cost of 50,000,000 bytes, or 50 megabytes.</span>
</span></span><span style=display:flex><span>cache.totalCostLimit = <span style=color:#fab387>50_000_000</span>
</span></span></code></pre></div><p>Now, when we want to add objects along with their cost, we can use the <code>setObject(object:forKey:cost:)</code> method we mentioned above.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Convert the image to Data.</span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>topBannerData</span> = webImage.pngData() {
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// The cost of our image is its size in bytes.</span>
</span></span><span style=display:flex><span>    cache.setObject(webImage, forKey: <span style=color:#a6e3a1>&#34;top banner&#34;</span>, cost: topBannerData.<span style=color:#89dceb>count</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Just like setting the maximum total objects, though, this is not a strict limit, and the cache will decide what to do with the objects once the limit is surpassed. If it needs to start evicting objects, it will start deleting some until the total cost of the cache is under the <code>totalCostLimit</code>. Keep in mind that the order in which the objects will be removed is random. We cannot, for example, expect the cache to start removing the biggest cost objects first (in our example, the biggest images), and there&rsquo;s no way to enforce a specific order.</p><h1 id=the-nsdiscardablecontent-protocol>The NSDiscardableContent Protocol</h1><p>The <code>NSDiscardableContent</code> protocol can be implemented when an object has subcomponents that can be discarded when not being used.</p><p>Suppose we have a class <code>Person</code> that looks like this:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>firstName</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>lastName</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>avatar</span>: UIImage? = <span style=color:#fab387>nil</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>init</span>(firstName: <span style=color:#89dceb>String</span>, lastName: <span style=color:#89dceb>String</span>, avatar: UIImage?) {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.firstName = firstName
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.lastName = lastName
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.avatar = avatar
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We want to cache this, but the <code>firstName</code> and <code>lastName</code> properties are probably too small to care about them persisting for a long time. On the other hand, the <code>avatar</code> can be big, so we want to remove only the <code>avatar</code> property when the system needs it. In this case, <code>Person</code> is a content-object, and the <code>avatar</code> property is the subcomponent that can be discarded.</p><p><code>NSCache</code> allows us to do this by implementing the <code>NSDiscardableContent</code> in our objects.</p><p><code>NSDiscardableContent</code> works with a simple variable counter system. When the memory is being read or is currently needed, its counter will have a value of <code>1</code>. If it&rsquo;s not needed at all and is not being used, the counter will be <code>0</code>. When a new ``NSDiscardableContent<code>is created, it's counter value starts with</code>1<code>. We will see how we can make use of this to help </code>NSCache<code>manage our</code>Person` class.</p><p>When we conform to <code>NSDiscardableContent</code>, there&rsquo;s four methods we must adopt:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// True if the content is still available and have been successfully accessed.</span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>beginContentAccess</span>() -&gt; <span style=color:#89dceb>Bool</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// Called when the content is no longer being accessed.</span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>endContentAccess</span>() {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// If our counter is 0, we can discard the image.</span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>discardContentIfPossible</span>() {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// True if the content has been discarded.</span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>isContentDiscarded</span>() -&gt; <span style=color:#89dceb>Bool</span> {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can implement <code>Person</code> conforming to the protocol the following way:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>Person</span>: NSDiscardableContent {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>firstName</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>lastName</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>avatar</span>: UIImage? = <span style=color:#fab387>nil</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// Our counter variable</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>accessCounter</span> = <span style=color:#fab387>true</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>init</span>(firstName: <span style=color:#89dceb>String</span>, lastName: <span style=color:#89dceb>String</span>, avatar: UIImage?) {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.firstName = firstName
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.lastName = lastName
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.avatar = avatar
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6c7086;font-style:italic>// </span><span style=color:#6c7086;font-style:italic>MARK:</span><span style=color:#6c7086;font-style:italic> - NSDiscardableContent</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>beginContentAccess</span>() -&gt; <span style=color:#89dceb>Bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>if</span> avatar <span style=color:#89dceb;font-weight:700>!=</span> <span style=color:#fab387>nil</span> {
</span></span><span style=display:flex><span>            accessCounter = <span style=color:#fab387>true</span>
</span></span><span style=display:flex><span>        } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            accessCounter = <span style=color:#fab387>false</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> accessCounter
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>endContentAccess</span>() {
</span></span><span style=display:flex><span>        accessCounter = <span style=color:#fab387>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>discardContentIfPossible</span>() {
</span></span><span style=display:flex><span>        avatar = <span style=color:#fab387>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>isContentDiscarded</span>() -&gt; <span style=color:#89dceb>Bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> avatar == <span style=color:#fab387>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we can create a cache of <code>Person</code>s. But there is one more thing we need to do.</p><p>By default, <code>NSCache</code> will evict all the objects it contains. In our case, it will discard <code>Person</code>s as necessary, and not just their avatar. To change this, set the cache&rsquo;s <code>evictsObjectsWithDiscardedContent</code> property to <code>false</code>.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>cache.evictsObjectsWithDiscardedContent = <span style=color:#fab387>false</span>
</span></span></code></pre></div><p>This property, whose default value is <code>true</code>, controls whether entire objects from the cache will be removed or just their discardable content. Setting it to <code>false</code> will ensure it just discards the <code>avatar</code>s and not whole <code>Person</code>s.</p><p>We can new create a new cache object of <code>Person</code>s and add objects to it.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>cache</span> = NSCache&lt;NSString, Person&gt;()
</span></span><span style=display:flex><span>cache.name = <span style=color:#a6e3a1>&#34;Person Cache&#34;</span>
</span></span><span style=display:flex><span>cache.evictsObjectsWithDiscardedContent = <span style=color:#fab387>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>andy</span> = Person(firstName: <span style=color:#a6e3a1>&#34;Andy&#34;</span>, lastName: <span style=color:#a6e3a1>&#34;Ibanez&#34;</span>, avatar: UIImage(named: <span style=color:#a6e3a1>&#34;silight.png&#34;</span>))
</span></span><span style=display:flex><span>cache.setObject(andy, forKey: <span style=color:#a6e3a1>&#34;me&#34;</span>)
</span></span></code></pre></div><p>Now, when the cache starts deleting <code>Person</code>s, it will only delete their avatars.</p><h1 id=the-nscachedelegate-protocol>The NSCacheDelegate Protocol</h1><p>To finish off this post, we can talk about the <code>NSCacheDelegate</code> protocol, which allows to see what a specific cache is doing. Currently, the delegate only has one method, <code>cache(_:willEvictObject)</code>, which allows us to know when an object is being removed.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>cache</span>(<span style=color:#fab387>_</span> cache: NSCache&lt;<span style=color:#89dceb>AnyObject</span>, <span style=color:#89dceb>AnyObject</span>&gt;, willEvictObject obj: <span style=color:#89dceb>Any</span>) {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>person</span> = obj <span style=color:#cba6f7>as</span>? Person {
</span></span><span style=display:flex><span>        <span style=color:#89dceb>print</span>(<span style=color:#a6e3a1>&#34;Cache </span><span style=color:#a6e3a1>\(</span>cache.name<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1> will evict person </span><span style=color:#a6e3a1>\(</span>person.firstName<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1> </span><span style=color:#a6e3a1>\(</span>person.lastName<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When an object is about to be deleted, we will be notified, which allows us to take some action. For now, we will just print who the person is that is being evicted.</p><p><em>(As is the case with the other API examples above, this comes from Objective-C, so we have to do some casting.)</em></p><h1 id=conclusion>Conclusion</h1><p><code>NSCache</code> is a good API to cache content that you only need in memory. You can both control the contents manually, or you can set conditions to allow the cache to manage itself. Being an Objective-C object at its core, it has some quirks to work with, but it&rsquo;s still very easy to use.</p></article></div></main><footer><div class=container><div class=footer-navigation><a href=https://github.com/AndyIbanez><span class=inline-svg><svg viewBox="0 0 42 40" id="svg4" width="42" height="40"><path fill="currentColor" d="m14.20936 32.20794c0 .16542-.19024.29776-.4301.29776-.27295.0248-.46319-.10752-.46319-.29776.0-.16542.19024-.29776.4301-.29776.24814-.0248.46319.10752.46319.29776zm-2.57234-.3722c-.0579.16542.10753.35566.35566.40528.21505.0827.46319.0.51282-.16542.0496-.16542-.10753-.35566-.35566-.4301-.21505-.0579-.45492.0248-.51282.19024zm3.65586-.14061c-.23986.0579-.40529.21505-.38047.40528.0248.16543.23986.27295.488.21505.23986-.0579.40528-.21505.38047-.38047-.0248-.15715-.24813-.26468-.488-.23986zM20.73531-.19734273e-6C9.2632-.19734273e-6.48748 8.7095398.48748 20.18166c0 9.17273 5.77328 17.02207 14.01964 19.78464 1.05871.19024 1.43091-.46319 1.43091-1.00081.0-.51282-.0248-3.34156-.0248-5.0785.0.0-5.78982 1.24067-7.00568-2.46481.0.0-.94292-2.40691-2.29939-3.02725.0.0-1.8941-1.29857.13234-1.27376.0.0 2.05952.16542 3.19267 2.13396 1.81139 3.19267 4.84691 2.27457 6.02969 1.72868.19023-1.32339.72786-2.24149 1.32338-2.78739-4.62358-.51281-9.28852-1.18278-9.28852-9.13964.0-2.27458.62861-3.416 1.95199-4.87172-.21505-.53763-.9181-2.7543.21506-5.6161302 1.72867-.53762 5.7071 2.2332202 5.7071 2.2332202 1.65424-.46319 3.43254-.70305 5.1943-.70305 1.76176.0 3.54006.23986 5.1943.70305.0.0 3.97843-2.7791202 5.7071-2.2332202 1.13315 2.8701002.4301 5.0785002.21505 5.6161302 1.32339 1.46399 2.13397 2.60542 2.13397 4.87172.0 7.98168-4.87172 8.61856-9.49531 9.13964.76095.65342 1.4061 1.8941 1.4061 3.83782.0 2.78739-.0248 6.23647-.0248 6.9147.0.53763.38047 1.19105 1.43091 1.00082 8.27117-2.74603 13.87903-10.59537 13.87903-19.7681C41.51252 8.7095398 32.20745-.19734273e-6 20.73533-.19734273e-6zM8.52706 28.52727c-.10752.0827-.0827.27295.0579.4301.13234.13234.32258.19024.4301.0827.10753-.0827.0827-.27295-.0579-.4301-.13233-.13234-.32257-.19024-.4301-.0827zM7.63378 27.8573c-.0579.10753.0248.23987.19023.32258.13234.0827.29777.0579.35566-.0579C8.23757 28.01446 8.15487 27.88212 7.98944 27.7994 7.82401 27.7498 7.69168 27.7746 7.63378 27.8573zm2.67986 2.94454c-.13234.10753-.0827.35566.10752.51281.19024.19024.4301.21505.53763.0827.10752-.10752.0579-.35566-.10753-.51281-.18196-.19024-.4301-.21505-.53762-.0827zM9.37072 29.58598c-.13234.0827-.13234.29776.0.488.13234.19023.35566.27295.46319.19023.13234-.10752.13234-.32257.0-.51281-.1158-.19024-.33085-.27295-.46319-.16542z" id="path2" style="stroke-width:.08271171"/></svg>
</span></a><a href=https://x.com/AndyIbanezK><span class=inline-svg><svg viewBox="0 0 50 40" id="svg4" width="50" height="40"><path fill="currentColor" d="m44.56253 9.96871c.0313.43748.0313.87506.0313 1.31254C44.59383 24.62494 34.43764 40 15.87508 40 10.1563 40 4.84383 38.34368.37506 35.4688c.81253.0937 1.5937.12495 2.4375.12495 4.71867.0 9.06249-1.5937 12.53125-4.31245-4.43751-.0938-8.15627-3.00003-9.43754-7.00006.62505.0937 1.25001.15622 1.90632.15622.90622.0 1.81254-.12505 2.65624-.34369C5.84384 23.15619 2.37498 19.09373 2.37498 14.18748v-.12495c1.3437.75 2.90633 1.21875 4.56246 1.28117-2.71876-1.81253-4.49993-4.90624-4.49993-8.40627.0-1.87497.4999-3.59372 1.37496-5.09373 4.96877 6.125 12.43756 10.12493 20.81248 10.56251-.15622-.75001-.25-1.53118-.25-2.31245C24.37495 4.5312 28.87498.0 34.46871.0c2.90623.0 5.53121 1.21875 7.37501 3.1875 2.28118-.43748 4.46867-1.28127 6.40626-2.43749-.75011 2.3438-2.34381 4.31255-4.43751 5.56246 2.03127-.21864 4.00003-.78126 5.81247-1.56244-1.37477 1.99992-3.09362 3.7811-5.06237 5.21868z" id="path2" style="stroke-width:.09619153"/></svg>
</span></a><a href=https://www.linkedin.com/in/andyibanez/><span class=inline-svg><svg viewBox="0 0 41 40" id="svg4" width="41" height="40"><path fill="currentColor" d="M9.45332 40H1.16028V13.29405H9.45332zM5.30234 9.65111c-2.65185.0-4.80279-2.19648-4.80279-4.84832a4.80279 4.80279.0 019.60558.0c0 2.65184-2.15184 4.84832-4.80279 4.84832zM40.49152 40H32.21633V26.99971c0-3.09828-.0625-7.07159-4.3117-7.07159-4.3117.0-4.97243 3.36615-4.97243 6.84837V40H14.64808V13.29405h7.95375v3.64294h.11608c1.10716-2.09827 3.81169-4.3126 7.8466-4.3126 8.39304.0 9.93594 5.52691 9.93594 12.70564V40z" id="path2" style="stroke-width:.08928771"/></svg>
</span></a><a href=https://www.andyibanez.com/blog/index.xml><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m11.435816 34.282008c0 3.15793-2.5599899 5.71793-5.7179299 5.71793s-5.717840022654-2.56-5.717840022654-5.71793c0-3.15794 2.559990022654-5.71793 5.717930022654-5.71793s5.7178399 2.56008 5.7178399 5.71793zm15.68388 4.21873C26.373806 24.697208 15.317496 13.626978 1.4992361 12.880288.68361608 12.836188.46077346e-4 13.491538.46077346e-4 14.308318v4.29186c0 .75134.579460002654 1.38142 1.329190022654 1.43017 9.9849699.65036 17.9886099 8.63408 18.6402999 18.6403.0488.74973.67893 1.3292 1.43018 1.3292h4.29186c.81687 9e-5 1.47223-.68348 1.42812-1.49911zm12.87933.0257C39.249566 17.649718 22.452206.754048 1.4735261.00092799867.66727608-.027972.46077346e-4.623338.46077346e-4 1.430038v4.29177c0 .77008.610270002654 1.39687 1.379730022654 1.42848 17.0694999.6999 30.7701699 14.40316 31.4699899 31.46999.0315.76946.6583 1.37972 1.42848 1.37972h4.29177c.8066-8e-5 1.45794-.66731 1.42901-1.47356z" id="path2" style="stroke-width:.08928544"/></svg>
</span></a><a href=https://www.andyibanez.com/curriculum/><span class=inline-svg><svg viewBox="0 0 15680 20480" id="svg4" width="35" height="40"><path fill="currentColor" d="M11655.83 12824.48 7840.0001 16640.464 4024.17 12824.48c-2859.863 123.906-5143.7701 2463.775-5143.7701 5352.003v384.005c0 1059.853 859.96601 1919.512 1919.92167 1919.512H14879.678c1059.956.0 1919.922-859.659 1919.922-1919.512v-384.005c0-2888.228-2283.906-5228.097-5143.77-5352.003zM-575.64445 3193.1279l256.0032 59.9048v2335.7732c-279.9651 167.9381-479.9548 459.7818-479.9548 812.0422.0 335.8762 183.9639 615.9437 443.96075 787.9778l-623.9822 2491.9352c-67.9944 275.9716 84.02025 559.6229 303.9782 559.6229H996.31762c219.95798.0 371.97268-283.6513 303.97828-559.6229L676.31362 7188.8259c259.99685-172.0341 443.96078-452.1016 443.96078-787.9778.0-352.2604-199.98973-644.1041-479.95483-812.0422V3484.9716l2639.90503 635.9119c-344.0171 688.1366-559.9814 1456.1463-559.9814 2279.9646.0 2827.8113 2291.8942 5119.5519 5119.7569 5119.5519 2827.8619.0 5119.7569-2291.7406 5119.7569-5119.5519.0-823.8183-211.971-1591.828-559.982-2279.9646l3851.824-927.7556c727.971-176.1302 727.971-1083.9175.0-1260.0477L8635.9653 92.929226c-519.9937-123.905551-1067.943-123.905551-1587.9367.0L-575.64445 1928.9841c-723.92585 176.1302-723.92585 1088.0136.0 1264.1438z" id="path2" style="stroke-width:39.99821472"/></svg>
</span></a><a href=https://www.andyibanez.com/contact-me><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m39.99999 36.249999c0 2.0711-1.6789 3.75-3.74999 3.75H3.75c-2.07109.0-3.74999-1.6789-3.74999-3.75v-20.56843a3.7499996 3.7499996.0 011.43648-2.95125c1.94633-1.5257 3.55476-2.7628904 12.82812-9.4930404C15.57906 2.2789186 18.18727-.02709136 20 .00024864227 21.81234-.02745136 24.42156 2.2793086 25.73539 3.2371986c9.27242 6.72945 10.88304 7.9683604 12.82812 9.4931204a3.7499996 3.7499996.0 011.43648 2.95125zm-5.13015-15.35976c-.20024-.29125-.60156-.35898-.88586-.14898-1.78476 1.3182-4.33297 3.18008-8.24859 6.02179-1.31445.95828-3.92266 3.26414-5.73539 3.23672-1.81336.0269-4.41867-2.2768-5.73539-3.23672-3.91515-2.8414-6.46359-4.70343-8.24859-6.02179-.2843-.21-.68562-.14227-.88586.14898l-.70875 1.03094a.62484368.62484368.0 00.14367.8568c1.78805 1.32023 4.33235 3.1789 8.2268 6.00531 1.5839 1.15476 4.41593 3.73539 7.20812 3.71664 2.79094.0189 5.62195-2.56024 7.20804-3.71664 3.89453-2.82649 6.43891-4.68516 8.2268-6.00531a.62484368.62484368.0 00.14367-.8568z" id="path2" style="stroke-width:.07812498"/></svg></span></a></div></div><p class=made-with-love><a href=https://github.com/humrochagf/colordrop><b>Colordrop</b>
</a><span>theme | Made </span><span>by</span>
<a href=https://humberto.io/><b>Humberto Rocha</b></a></p></footer></div><script src=/copy/copy.js></script><script src=/search/elasticlunr.min.js></script><script src=/search/search.js></script><script>loadSearch()</script></body></html>