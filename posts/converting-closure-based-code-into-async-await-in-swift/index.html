<!doctype html><html prefix="og: http://ogp.me/ns#" lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,user-scalable=no"><meta http-equiv=x-ua-compatible content="ie=edge"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script><link rel=apple-touch-icon sizes=180x180 href=https://www.andyibanez.com/favicons/apple-touch-icon-180x180.png><link rel=icon type=image/png sizes=32x32 href=https://www.andyibanez.com/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://www.andyibanez.com/favicons/favicon-16x16.png><link rel=manifest href=https://www.andyibanez.com/favicons/site.webmanifest><link rel=mask-icon href=https://www.andyibanez.com/favicons/safari-pinned-tab.svg color=#292148><meta name=msapplication-TileColor content="#292148"><meta name=msapplication-config content="https://www.andyibanez.com/favicons/browserconfig.xml"><meta name=theme-color content="#292148"><link rel=canonical href=https://www.andyibanez.com/posts/converting-closure-based-code-into-async-await-in-swift/><link rel=alternate hreflang=en href=https://www.andyibanez.com/posts/converting-closure-based-code-into-async-await-in-swift/ title><meta name=description content="Learn about checked continuations and converting closure and delegate-based code into async/await in Swift."><meta name=author content><meta name=theme-color content="#292148"><meta itemprop=name content="Converting closure-based code into async/await in Swift"><meta itemprop=description content="Learn about checked continuations and converting closure and delegate-based code into async/await in Swift."><meta itemprop=datePublished content="2021-06-23T07:00:00-04:00"><meta itemprop=dateModified content="2021-06-23T07:00:00-04:00"><meta itemprop=wordCount content="2089"><meta itemprop=keywords content="swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading"><meta property="og:url" content="https://www.andyibanez.com/posts/converting-closure-based-code-into-async-await-in-swift/"><meta property="og:site_name" content="Andy Ibanez"><meta property="og:title" content="Converting closure-based code into async/await in Swift"><meta property="og:description" content="Learn about checked continuations and converting closure and delegate-based code into async/await in Swift."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-23T07:00:00-04:00"><meta property="article:modified_time" content="2021-06-23T07:00:00-04:00"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Apple"><meta property="article:tag" content="Programming"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Async"><meta property="article:tag" content="Await"><meta name=twitter:card content="summary"><meta name=twitter:title content="Converting closure-based code into async/await in Swift"><meta name=twitter:description content="Learn about checked continuations and converting closure and delegate-based code into async/await in Swift."><meta name=twitter:creator content="@"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","url":"https://www.andyibanez.com/posts/converting-closure-based-code-into-async-await-in-swift/","headline":"Converting closure-based code into async/await in Swift","description":"Learn about checked continuations and converting closure and delegate-based code into async/await in Swift.","datePublished":"2021-06-23","keywords":"swift,apple,programming,ios,concurrency,async,await,ios,macos,ipados,watchos,wwdc2021,multithreading","author":{"@type":"Person","name":""}}</script><title>Converting closure-based code into async/await in Swift - Andy Ibanez</title><link rel=stylesheet href=https://www.andyibanez.com/style.main.min.18f604b90ed15864d7faa967f1ef9eacb99e1c967eff38762ec29b7bf1ab5876.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-CE7T69YX8Y"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CE7T69YX8Y")}</script></head><body><div class=wrapper><nav><div class=container><div class=language-selector></div></div></nav><header><div class=container><div class=header-group><div class=header-logo-container><a class=header-logo-link href=https://www.andyibanez.com/><img class=header-logo-circle src=https://www.andyibanez.com/img/andy_profile.png alt="Andy Ibanez logo"></a></div><div class=header-title><a href=https://www.andyibanez.com/>Andy Ibanez</a></div></div></div></header><nav><div class=container><div class=main-navigation><a href=/about/>About Me</a><a href=/posts/>Blog</a><a href=/projects/>Projects</a><a href=/tags/>Tags</a><a href=/contact/>Contact</a><a href=/privacy-policy/>Privacy policy</a></div></div></nav><div class=container><div class=search><input type=text id=searchInput placeholder="Type here to search"></div><div class="container search-results-container" hidden=true><div id=searchResults class=search-results></div></div></div><main><div class=container><article><h1 class=title>Converting closure-based code into async/await in Swift</h1><p class=publish>Published on
<time class=post-date datetime=2021-06-23T07:00:00-04:00>June 23, 2021</time></p><p><em>This article is part of my <a href=/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift</a> article series.</em></p><p><em>This article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.</em></p><h6 id=table-of-contents>Table of Contents</h6><ol><li><a href=/posts/modern-concurrency-in-swift-introduction/>Modern Concurrency in Swift: Introduction</a></li><li><a href=/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a></li><li><strong>Converting closure-based code into async/await in Swift</strong></li><li><a href=/posts/structured-concurrency-in-swift-using-async-let/>Structured Concurrency in Swift: Using async let</a></li><li><a href=/posts/structured-concurrency-with-group-tasks-in-swift/>Structured Concurrency With Task Groups in Swift</a></li><li><a href=/posts/introduction-to-unstructured-concurrency-in-swift/>Introduction to Unstructured Concurrency in Swift</a></li><li><a href=/posts/unstructured-concurrency-with-detached-tasks-in-swift/>Unstructured Concurrency With Detached Tasks in Swift</a></li><li><a href=/posts/understanding-actors-in-the-new-concurrency-model-in-swift/>Understanding Actors in the New Concurrency Model in Swift</a></li><li><a href=/posts/mainactor-and-global-actors-in-swift/>@MainActor and Global Actors in Swift</a></li><li><a href=posts/sharing-data-across-tasks-tasklocal-new-swift-concurrency-model>Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model</a></li><li><a href=/posts/using-asyncsequence-in-swift/>Using AsyncSequence in Swift</a></li><li><a href=/posts/modern-swift-concurrency-summary-cheatsheet-thanks/>Modern Swift Concurrency Summary, Cheatsheet, and Thanks</a></li></ol><hr><p><em>To better benefit from this article, you should be familiar with async/await. If you aren&rsquo;t, feel free to read the first part of this article series: <a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>Understanding async/await in Swift</a>.</em></p><p><em>I was debating whether this article should be its own or if its contents should be appended to Introducing async/await in Swift. I decided to make the previous article shorter in an attempt to not overload the articles with information, and to hopefully make it easier to understand these API with smaller articles.</em></p><p>Last week, we had a long discussion on async/await. We contrasted how it compares to callbacks, and we showed examples that hopefully convinced you async/await is really neat.</p><p>We are just one step away from actual concurrency. Before we dive into concurrency - with <em>structured concurrency</em> - next week, I want to show you how you can convert closure-based and delegate-based code into async/await code. The idea behind this article is to give you all the tools so that you can start adopting async/await in your projects, baby steps at a time.</p><p>If you are a library vendor, you will be able to provide async/await code for all your closure-based APIs, so not only will you be able to start using it for your uses, you will be able to ship async/await to your users.</p><p>If you are not a library vendor, but you do have an app in production, it&rsquo;s likely that your own app is using asynchronous code that notifies you via callbacks. If you want to start migrating that project, you can start by implementing <code>async</code> versions of your async methods. If you are using a third party library that is not offering async/await versions of their calls, you can easily provide your own.</p><h1 id=understanding-continuations>Understanding Continuations</h1><p>If you have read the <a href=https://www.andyibanez.com/posts/understanding-async-await-in-swift/>first part</a> of this article series, you may remember what a Continuation is, but let&rsquo;s have a quick refresher before we move on.</p><p>A continuation is simply what happens after an async call. When you are using async/await, the continuation is easy to understand: Everything below an <code>await</code> call, is a continuation.</p><p>Consider the following example:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadMetadata</span>(<span style=color:#cba6f7>for</span> id: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; ImageMetadata {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>id<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.json&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataRequest</span> = URLRequest(url: metadataUrl)
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> (data, metadataResponse) = <span style=color:#cba6f7>try</span> await URLSession.shared.data(<span style=color:#cba6f7>for</span>: metadataRequest)
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> (metadataResponse <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>throw</span> ImageDownloadError.invalidMetadata
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> JSONDecoder().decode(ImageMetadata.<span style=color:#fab387>self</span>, from: data)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this example, the keyword <code>await</code> will (may) trigger a data download task in a different thread. Everything underneath <code>await</code> (that is, starting on the line with a <code>guard</code>), is a <em>continuation</em>.</p><p>Continuations are not limited to the async/await APIs. When you are using closure-based async APIs, a continuation is everything called within your completion handlers.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.json&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataTask</span> = URLSession.shared.dataTask(with: metadataUrl) { data, response, error <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>data</span> = data, <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span>? JSONDecoder().decode(ImageMetadata.<span style=color:#fab387>self</span>, from: data),  (response <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>        completionHandler(<span style=color:#fab387>nil</span>, ImageDownloadError.invalidMetadata)
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>detailedImage</span> = DetailedImage(image: image, metadata: metadata)
</span></span><span style=display:flex><span>    completionHandler(detailedImage, <span style=color:#fab387>nil</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>metadataTask.resume()
</span></span></code></pre></div><p>This is a closure version of the code above. Once again, the continuation starts at the <code>guard</code>. The main difference is the completion handler version has a flow that is harder to follow.</p><h2 id=introducing-explicit-continuations>Introducing explicit continuations</h2><p>Swift provides a few methods we can use to convert callback-based code into async/await: <code>withCheckedContinuation</code> and <code>withCheckedThrowingContinuation</code>. The difference between the two is the latter is used for code that throws errors. I call these methods <em>explicit continuations</em>.</p><p>Suppose you have a completion handler version of the <code>downloadMetadata(for:)</code> method declared above:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// </span><span style=color:#6c7086;font-style:italic>MARK:</span><span style=color:#6c7086;font-style:italic> - Definitions</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>ImageMetadata</span>: Codable {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>name</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>firstAppearance</span>: <span style=color:#89dceb>String</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>year</span>: <span style=color:#89dceb>Int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>struct</span> <span style=color:#f9e2af>DetailedImage</span> {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span>: UIImage
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span>: ImageMetadata
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>enum</span> <span style=color:#f9e2af>ImageDownloadError</span>: Error {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>case</span> badImage
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>case</span> invalidMetadata
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// </span><span style=color:#6c7086;font-style:italic>MARK:</span><span style=color:#6c7086;font-style:italic> - Functions</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(
</span></span><span style=display:flex><span>    imageNumber: <span style=color:#89dceb>Int</span>,
</span></span><span style=display:flex><span>    completionHandler: @escaping (<span style=color:#fab387>_</span> image: DetailedImage?, <span style=color:#fab387>_</span> error: Error?) -&gt; <span style=color:#89dceb>Void</span>
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.png&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageTask</span> = URLSession.shared.dataTask(with: imageUrl) { data, response, error <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>data</span> = data, <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = UIImage(data: data), (response <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>            completionHandler(<span style=color:#fab387>nil</span>, ImageDownloadError.badImage)
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataUrl</span> = URL(string: <span style=color:#a6e3a1>&#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/</span><span style=color:#a6e3a1>\(</span>imageNumber<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>.json&#34;</span>)<span style=color:#89dceb;font-weight:700>!</span>
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadataTask</span> = URLSession.shared.dataTask(with: metadataUrl) { data, response, error <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>guard</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>data</span> = data, <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>metadata</span> = <span style=color:#cba6f7>try</span>? JSONDecoder().decode(ImageMetadata.<span style=color:#fab387>self</span>, from: data),  (response <span style=color:#cba6f7>as</span>? HTTPURLResponse)?.statusCode == <span style=color:#fab387>200</span> <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>                completionHandler(<span style=color:#fab387>nil</span>, ImageDownloadError.invalidMetadata)
</span></span><span style=display:flex><span>                <span style=color:#cba6f7>return</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>detailedImage</span> = DetailedImage(image: image, metadata: metadata)
</span></span><span style=display:flex><span>            completionHandler(detailedImage, <span style=color:#fab387>nil</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        metadataTask.resume()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    imageTask.resume()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And suppose you are not the original author of it, and it&rsquo;s closed source, preventing you from modifying it directly. If you wanted to start your async/await migration with this method, the simplest way to do it would be by wrapping a call to <code>downloadImageAndMetadata(for:imageNumber:completionHandler)</code> inside the <code>withCheckedThrowingContinuation</code> method.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>func</span> <span style=color:#89b4fa>downloadImageAndMetadata</span>(imageNumber: <span style=color:#89dceb>Int</span>) async <span style=color:#cba6f7>throws</span> -&gt; DetailedImage {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>return</span> <span style=color:#cba6f7>try</span> await withCheckedThrowingContinuation({
</span></span><span style=display:flex><span>        (continuation: CheckedContinuation&lt;DetailedImage, Error&gt;) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>        downloadImageAndMetadata(imageNumber: imageNumber) { image, error <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>            <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>image</span> = image {
</span></span><span style=display:flex><span>                continuation.resume(returning: image)
</span></span><span style=display:flex><span>            } <span style=color:#cba6f7>else</span> {
</span></span><span style=display:flex><span>                continuation.resume(throwing: error!)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The magic behind this function occurs inside the <code>withCheckedThrowingContinuation</code> part. This function will give us a <code>CheckedContinuation&lt;T, E> where E: Error</code> object that provides us with methods we need to call. In this example, the original version of <code>downloadImageWithMetadata</code> passes us a <code>DetailedImage</code> or an error, and we need to call the right <code>resume</code> method depending on what we get. If this method called us with a <code>Result&lt;DetailedImage, Error></code>, we could call <code>.resume(with:)</code> and pass it the <code>result</code> directly.</p><p>Continuations <strong>must be called exactly once</strong>, therefore there must be a continuation call within every branch of <code>withCheckedThrowingContinuation</code>. If you forget to call <code>.resume</code>, things could go awry. Luckily, Swift will let you know.</p><p><strong>Note</strong>: <em>Or at least, it is supposed to. This article is based on the last few minutes of the <a href="https://developer.apple.com/videos/play/wwdc2021/10132/?time=1733">Meet async/await in Swift</a> session. At least as of Beta 1, I was able to have code with branches that don&rsquo;t call <code>resume</code>.</em></p><p>And just like that, we have converted closure-based code into something prettier! Using the <code>async/await</code> version of this function is as easy as:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>Task {
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>if</span> <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>imageDetail</span> = <span style=color:#cba6f7>try</span>? await downloadImageAndMetadata(imageNumber: <span style=color:#fab387>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.imageView.image = imageDetail.image
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.metadata.text = <span style=color:#a6e3a1>&#34;</span><span style=color:#a6e3a1>\(</span>imageDetail.metadata.name<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1> (</span><span style=color:#a6e3a1>\(</span>imageDetail.metadata.firstAppearance<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1> - </span><span style=color:#a6e3a1>\(</span>imageDetail.metadata.year<span style=color:#a6e3a1>)</span><span style=color:#a6e3a1>)&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you want to see and run a program using this, you can download a sample project from <a href=/archives/CheckedContinuations.zip>here</a>.</p><h2 id=converting-delegate-based-code-into-asyncawait>Converting delegate-based code into async/await.</h2><p>Up to now we have seen how you can convert callback-based code into async/await. You can also do this with delegate-based code. While delegate-based APIs have mostly disappeared in favor of callbacks, it is still common to encounter them, especially if the APIs in question are event-driven (Bluetooth, Location, etc). As such, you may benefit from knowing you can also bridge these to async/await.</p><p>Suppose you have an UIKit app that lets users choose contacts in a ViewController. In its simplest form, it may look similar to this:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>ViewController</span>: UIViewController, CNContactPickerDelegate {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>@IBOutlet</span> <span style=color:#cba6f7>weak</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>contactNameLabel</span>: UILabel!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>override</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>viewDidLoad</span>() {
</span></span><span style=display:flex><span>        <span style=color:#fab387>super</span>.viewDidLoad()
</span></span><span style=display:flex><span>        <span style=color:#6c7086;font-style:italic>// Do any additional setup after loading the view.</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cba6f7>@IBAction</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>chooseContactTouchUpInside</span>(<span style=color:#fab387>_</span> sender: <span style=color:#89dceb>Any</span>) {
</span></span><span style=display:flex><span>        showContactPicker()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>showContactPicker</span>() {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>picker</span> = CNContactPickerViewController()
</span></span><span style=display:flex><span>        picker.delegate = <span style=color:#fab387>self</span>
</span></span><span style=display:flex><span>        present(picker, animated: <span style=color:#fab387>true</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>contactPicker</span>(<span style=color:#fab387>_</span> picker: CNContactPickerViewController, didSelect contact: CNContact) {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.contactNameLabel.text = contact.givenName
</span></span><span style=display:flex><span>        picker.dismiss(animated: <span style=color:#fab387>true</span>, completion: <span style=color:#fab387>nil</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pressing a &ldquo;choose contact&rdquo; button will call <code>showContactPicker</code>, displaying the actual picker and, when the user selects the contact, the system will notify us of the event through the <code>contactPicker(_:contact)</code> method.</p><p>But we can do better. We can instead create an object that will wrap all this Contacts stuff for us. We can then create <code>async</code> methods that will let us know when a user has selected a contact. With this, we will be able to keep linearity in our program and keep a flow that is easier to follow.</p><p>We can declare <code>ContactPicker</code> as follows:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>@MainActor
</span></span><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>ContactPicker</span>: NSObject, CNContactPickerDelegate {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>typealias</span> ContactCheckedContinuation = CheckedContinuation&lt;CNContact, Never&gt; <span style=color:#6c7086;font-style:italic>// 1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#cba6f7>unowned</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>viewController</span>: UIViewController
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>contactContinuation</span>: ContactCheckedContinuation? <span style=color:#6c7086;font-style:italic>// 2</span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>picker</span>: CNContactPickerViewController
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>init</span>(viewController: UIViewController) {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.viewController = viewController
</span></span><span style=display:flex><span>        picker = CNContactPickerViewController()
</span></span><span style=display:flex><span>        <span style=color:#fab387>super</span>.<span style=color:#f38ba8>init</span>()
</span></span><span style=display:flex><span>        picker.delegate = <span style=color:#fab387>self</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>pickContact</span>() async -&gt; CNContact { <span style=color:#6c7086;font-style:italic>// 3</span>
</span></span><span style=display:flex><span>        viewController.present(picker, animated: <span style=color:#fab387>true</span>)
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> await withCheckedContinuation({ (continuation: ContactCheckedContinuation) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>            <span style=color:#fab387>self</span>.contactContinuation = continuation
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>contactPicker</span>(<span style=color:#fab387>_</span> picker: CNContactPickerViewController, didSelect contact: CNContact) {
</span></span><span style=display:flex><span>        contactContinuation?.resume(returning: contact) <span style=color:#6c7086;font-style:italic>// 4</span>
</span></span><span style=display:flex><span>        contactContinuation = <span style=color:#fab387>nil</span>
</span></span><span style=display:flex><span>        picker.dismiss(animated: <span style=color:#fab387>true</span>, completion: <span style=color:#fab387>nil</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What you need to understand here is:</p><ol><li>We are typealiasing <code>CheckedContinuation&lt;CNContact, Never></code> so it&rsquo;s easier to refer to. Since we can&rsquo;t get an error, the error parameter is <code>Never</code>.</li><li><code>private var contactContinuation: ContactCheckedContinuation?</code> will hold a reference to the continuation itself. This continuation is given to us in the <code>withCheckedContinuation</code> handler. Itâ€™s an optional because we will set it to nil after the first call to avoid it being called more than once.</li><li><code>pickContact</code> is <code>async</code>, as it will return the <code>CNContact</code> to us. We call <code>withCheckedContinuation</code> here.</li><li>When the contact is picked, we will call the continuation with <code>resume</code>.</li></ol><p>And then, to use this:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#cba6f7>@IBAction</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>chooseContactTouchUpInside</span>(<span style=color:#fab387>_</span> sender: <span style=color:#89dceb>Any</span>) {
</span></span><span style=display:flex><span>    async {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>contactPicker</span> = ContactPicker(viewController: <span style=color:#fab387>self</span>)
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>contact</span> = await contactPicker.pickContact()
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.contactNameLabel.text = contact.givenName
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But, note that our implementation has a flaw. If you have used the <code>ContactsUI</code> framework before, you may have caught it.</p><p>The UI presented gives our users the option to cancel without choosing a contact. Earlier we said that when dealing with continuations, you need to call the continuation exactly once. In the program above, we are not implementing the <code>contactPickerDidCancel(_)</code> method, and therefore our continuation is not getting called when users cancel.</p><p>To solve this, we have two options: We can throw an error when users cancel, or we can pass in a nil contact. It doesn&rsquo;t make much sense to throw an error in this case, so we will modify the code to take a nil contact instead.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#f38ba8>class</span> <span style=color:#f9e2af>ContactPicker</span>: NSObject, CNContactPickerDelegate {
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>typealias</span> ContactCheckedContinuation = CheckedContinuation&lt;CNContact?, Never&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#cba6f7>unowned</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>viewController</span>: UIViewController
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>contactContinuation</span>: ContactCheckedContinuation?
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>private</span> <span style=color:#f38ba8>var</span> <span style=color:#f5e0dc>picker</span>: CNContactPickerViewController
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>init</span>(viewController: UIViewController) {
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.viewController = viewController
</span></span><span style=display:flex><span>        picker = CNContactPickerViewController()
</span></span><span style=display:flex><span>        <span style=color:#fab387>super</span>.<span style=color:#f38ba8>init</span>()
</span></span><span style=display:flex><span>        picker.delegate = <span style=color:#fab387>self</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>pickContact</span>() async -&gt; CNContact? {
</span></span><span style=display:flex><span>        <span style=color:#cba6f7>return</span> await withCheckedContinuation({ (continuation: ContactCheckedContinuation) <span style=color:#cba6f7>in</span>
</span></span><span style=display:flex><span>            <span style=color:#fab387>self</span>.contactContinuation = continuation
</span></span><span style=display:flex><span>            viewController.present(picker, animated: <span style=color:#fab387>true</span>)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>contactPicker</span>(<span style=color:#fab387>_</span> picker: CNContactPickerViewController, didSelect contact: CNContact) {
</span></span><span style=display:flex><span>        contactContinuation?.resume(returning: contact)
</span></span><span style=display:flex><span>        contactContinuation = <span style=color:#fab387>nil</span>
</span></span><span style=display:flex><span>        picker.dismiss(animated: <span style=color:#fab387>true</span>, completion: <span style=color:#fab387>nil</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>contactPickerDidCancel</span>(<span style=color:#fab387>_</span> picker: CNContactPickerViewController) {
</span></span><span style=display:flex><span>        contactContinuation?.resume(returning: <span style=color:#fab387>nil</span>)
</span></span><span style=display:flex><span>        contactContinuation = <span style=color:#fab387>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6c7086;font-style:italic>// in ViewController</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cba6f7>@IBAction</span> <span style=color:#f38ba8>func</span> <span style=color:#89b4fa>chooseContactTouchUpInside</span>(<span style=color:#fab387>_</span> sender: <span style=color:#89dceb>Any</span>) {
</span></span><span style=display:flex><span>    async {
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>contactPicker</span> = ContactPicker(viewController: <span style=color:#fab387>self</span>)
</span></span><span style=display:flex><span>        <span style=color:#f38ba8>let</span> <span style=color:#f5e0dc>contact</span> = await contactPicker.pickContact()
</span></span><span style=display:flex><span>        <span style=color:#fab387>self</span>.contactNameLabel.text = contact?.givenName
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is much better. We will now call <code>resume</code> in all possible paths, our program will always be in a valid state, and, while we did write more code, there will be cases in which going the extra mile to preserve linearity will benefit the structure of the program in the long run. *</p><p>You can download a full version of the contact picker app <a href=/archives/AsyncAwaitContactPicker.zip>here</a>. It&rsquo;s a UIKit app with a simple button and labels that shows you the given name of the contact you selected. Hopefully it will help you better understand the contents of this article.</p><h1 id=summary>Summary</h1><p>In this article we have explored how we can bridge from callback-based code or delegate-based code into <code>async/await</code>. We learned how to use checked continuations to do so, and we enforced the idea of what a continuation actually is.</p><p>With this, you should now understand all the essentials of <code>async/await</code>. You are now ready to tackle actual concurrency, and next week we will start talking about that, starting with <em>structured concurrency</em>. You will learn how to run many tasks in parallel and how to process such results.</p><h1 id=notes>Notes</h1><p>*: You should always stop and think if going that extra mile is actually worth it or if it is overkill. Over-engineering is a real and common problem in software engineering.</p></article></div></main><footer><div class=container><div class=footer-navigation><a href=https://github.com/AndyIbanez><span class=inline-svg><svg viewBox="0 0 42 40" id="svg4" width="42" height="40"><path fill="currentColor" d="m14.20936 32.20794c0 .16542-.19024.29776-.4301.29776-.27295.0248-.46319-.10752-.46319-.29776.0-.16542.19024-.29776.4301-.29776.24814-.0248.46319.10752.46319.29776zm-2.57234-.3722c-.0579.16542.10753.35566.35566.40528.21505.0827.46319.0.51282-.16542.0496-.16542-.10753-.35566-.35566-.4301-.21505-.0579-.45492.0248-.51282.19024zm3.65586-.14061c-.23986.0579-.40529.21505-.38047.40528.0248.16543.23986.27295.488.21505.23986-.0579.40528-.21505.38047-.38047-.0248-.15715-.24813-.26468-.488-.23986zM20.73531-.19734273e-6C9.2632-.19734273e-6.48748 8.7095398.48748 20.18166c0 9.17273 5.77328 17.02207 14.01964 19.78464 1.05871.19024 1.43091-.46319 1.43091-1.00081.0-.51282-.0248-3.34156-.0248-5.0785.0.0-5.78982 1.24067-7.00568-2.46481.0.0-.94292-2.40691-2.29939-3.02725.0.0-1.8941-1.29857.13234-1.27376.0.0 2.05952.16542 3.19267 2.13396 1.81139 3.19267 4.84691 2.27457 6.02969 1.72868.19023-1.32339.72786-2.24149 1.32338-2.78739-4.62358-.51281-9.28852-1.18278-9.28852-9.13964.0-2.27458.62861-3.416 1.95199-4.87172-.21505-.53763-.9181-2.7543.21506-5.6161302 1.72867-.53762 5.7071 2.2332202 5.7071 2.2332202 1.65424-.46319 3.43254-.70305 5.1943-.70305 1.76176.0 3.54006.23986 5.1943.70305.0.0 3.97843-2.7791202 5.7071-2.2332202 1.13315 2.8701002.4301 5.0785002.21505 5.6161302 1.32339 1.46399 2.13397 2.60542 2.13397 4.87172.0 7.98168-4.87172 8.61856-9.49531 9.13964.76095.65342 1.4061 1.8941 1.4061 3.83782.0 2.78739-.0248 6.23647-.0248 6.9147.0.53763.38047 1.19105 1.43091 1.00082 8.27117-2.74603 13.87903-10.59537 13.87903-19.7681C41.51252 8.7095398 32.20745-.19734273e-6 20.73533-.19734273e-6zM8.52706 28.52727c-.10752.0827-.0827.27295.0579.4301.13234.13234.32258.19024.4301.0827.10753-.0827.0827-.27295-.0579-.4301-.13233-.13234-.32257-.19024-.4301-.0827zM7.63378 27.8573c-.0579.10753.0248.23987.19023.32258.13234.0827.29777.0579.35566-.0579C8.23757 28.01446 8.15487 27.88212 7.98944 27.7994 7.82401 27.7498 7.69168 27.7746 7.63378 27.8573zm2.67986 2.94454c-.13234.10753-.0827.35566.10752.51281.19024.19024.4301.21505.53763.0827.10752-.10752.0579-.35566-.10753-.51281-.18196-.19024-.4301-.21505-.53762-.0827zM9.37072 29.58598c-.13234.0827-.13234.29776.0.488.13234.19023.35566.27295.46319.19023.13234-.10752.13234-.32257.0-.51281-.1158-.19024-.33085-.27295-.46319-.16542z" id="path2" style="stroke-width:.08271171"/></svg>
</span></a><a href=https://x.com/AndyIbanezK><span class=inline-svg><svg viewBox="0 0 50 40" id="svg4" width="50" height="40"><path fill="currentColor" d="m44.56253 9.96871c.0313.43748.0313.87506.0313 1.31254C44.59383 24.62494 34.43764 40 15.87508 40 10.1563 40 4.84383 38.34368.37506 35.4688c.81253.0937 1.5937.12495 2.4375.12495 4.71867.0 9.06249-1.5937 12.53125-4.31245-4.43751-.0938-8.15627-3.00003-9.43754-7.00006.62505.0937 1.25001.15622 1.90632.15622.90622.0 1.81254-.12505 2.65624-.34369C5.84384 23.15619 2.37498 19.09373 2.37498 14.18748v-.12495c1.3437.75 2.90633 1.21875 4.56246 1.28117-2.71876-1.81253-4.49993-4.90624-4.49993-8.40627.0-1.87497.4999-3.59372 1.37496-5.09373 4.96877 6.125 12.43756 10.12493 20.81248 10.56251-.15622-.75001-.25-1.53118-.25-2.31245C24.37495 4.5312 28.87498.0 34.46871.0c2.90623.0 5.53121 1.21875 7.37501 3.1875 2.28118-.43748 4.46867-1.28127 6.40626-2.43749-.75011 2.3438-2.34381 4.31255-4.43751 5.56246 2.03127-.21864 4.00003-.78126 5.81247-1.56244-1.37477 1.99992-3.09362 3.7811-5.06237 5.21868z" id="path2" style="stroke-width:.09619153"/></svg>
</span></a><a href=https://www.linkedin.com/in/andyibanez/><span class=inline-svg><svg viewBox="0 0 41 40" id="svg4" width="41" height="40"><path fill="currentColor" d="M9.45332 40H1.16028V13.29405H9.45332zM5.30234 9.65111c-2.65185.0-4.80279-2.19648-4.80279-4.84832a4.80279 4.80279.0 019.60558.0c0 2.65184-2.15184 4.84832-4.80279 4.84832zM40.49152 40H32.21633V26.99971c0-3.09828-.0625-7.07159-4.3117-7.07159-4.3117.0-4.97243 3.36615-4.97243 6.84837V40H14.64808V13.29405h7.95375v3.64294h.11608c1.10716-2.09827 3.81169-4.3126 7.8466-4.3126 8.39304.0 9.93594 5.52691 9.93594 12.70564V40z" id="path2" style="stroke-width:.08928771"/></svg>
</span></a><a href=https://www.andyibanez.com/posts/index.xml><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m11.435816 34.282008c0 3.15793-2.5599899 5.71793-5.7179299 5.71793s-5.717840022654-2.56-5.717840022654-5.71793c0-3.15794 2.559990022654-5.71793 5.717930022654-5.71793s5.7178399 2.56008 5.7178399 5.71793zm15.68388 4.21873C26.373806 24.697208 15.317496 13.626978 1.4992361 12.880288.68361608 12.836188.46077346e-4 13.491538.46077346e-4 14.308318v4.29186c0 .75134.579460002654 1.38142 1.329190022654 1.43017 9.9849699.65036 17.9886099 8.63408 18.6402999 18.6403.0488.74973.67893 1.3292 1.43018 1.3292h4.29186c.81687 9e-5 1.47223-.68348 1.42812-1.49911zm12.87933.0257C39.249566 17.649718 22.452206.754048 1.4735261.00092799867.66727608-.027972.46077346e-4.623338.46077346e-4 1.430038v4.29177c0 .77008.610270002654 1.39687 1.379730022654 1.42848 17.0694999.6999 30.7701699 14.40316 31.4699899 31.46999.0315.76946.6583 1.37972 1.42848 1.37972h4.29177c.8066-8e-5 1.45794-.66731 1.42901-1.47356z" id="path2" style="stroke-width:.08928544"/></svg>
</span></a><a href=https://www.andyibanez.com/contact><span class=inline-svg><svg viewBox="0 0 40 40" id="svg4" width="40" height="40"><path fill="currentColor" d="m39.99999 36.249999c0 2.0711-1.6789 3.75-3.74999 3.75H3.75c-2.07109.0-3.74999-1.6789-3.74999-3.75v-20.56843a3.7499996 3.7499996.0 011.43648-2.95125c1.94633-1.5257 3.55476-2.7628904 12.82812-9.4930404C15.57906 2.2789186 18.18727-.02709136 20 .00024864227 21.81234-.02745136 24.42156 2.2793086 25.73539 3.2371986c9.27242 6.72945 10.88304 7.9683604 12.82812 9.4931204a3.7499996 3.7499996.0 011.43648 2.95125zm-5.13015-15.35976c-.20024-.29125-.60156-.35898-.88586-.14898-1.78476 1.3182-4.33297 3.18008-8.24859 6.02179-1.31445.95828-3.92266 3.26414-5.73539 3.23672-1.81336.0269-4.41867-2.2768-5.73539-3.23672-3.91515-2.8414-6.46359-4.70343-8.24859-6.02179-.2843-.21-.68562-.14227-.88586.14898l-.70875 1.03094a.62484368.62484368.0 00.14367.8568c1.78805 1.32023 4.33235 3.1789 8.2268 6.00531 1.5839 1.15476 4.41593 3.73539 7.20812 3.71664 2.79094.0189 5.62195-2.56024 7.20804-3.71664 3.89453-2.82649 6.43891-4.68516 8.2268-6.00531a.62484368.62484368.0 00.14367-.8568z" id="path2" style="stroke-width:.07812498"/></svg></span></a></div></div><p class=made-with-love><a href=https://github.com/humrochagf/colordrop><b>Colordrop</b>
</a><span>theme | Made </span><span>by</span>
<a href=https://humberto.io/><b>Humberto Rocha</b></a></p></footer></div><script src=/copy/copy.js></script><script src=/search/elasticlunr.min.js></script><script src=/search/search.js></script><script>loadSearch("https://www.andyibanez.com/index.json")</script></body></html>