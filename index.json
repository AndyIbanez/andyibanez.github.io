[{"id":"90a44415b558133253206fe7e91fce57","title":"About Me","link":"/about/","content":"¬°Hola!\nMy name is Andy. I come from across the Andes, overwatched by the beautiful Illimani, and I am a Computer Systems Engineer, graduated from Universidad Privada Boliviana.\nI started programming when I was 14 years old. My career got kickstarted thanks to a website called Neoseeker. Neoseeker is one of the few old-style internet forums that is still around today. Neoseeker is a gaming website, and I joined the website because, well, I wanted to talk about videogames. However, little did I know that it would kickstart my programming career thanks to the fact it allows you to build and host a small HTML webpage on your profile. Thanks to the small, but active, programmer community on the website, I was able to extend my programming knowledge from simple HTML websites all the way up to native applications and backend development.\nThroughout the years I have been writing code, I have played around with many technologies and languages. I have worked with web frontends, PHP backends, NodeJS apps - but, ultimately, my heart belongs to Apple technologies, and I have been writing iOS apps for almost 15 years as of 2025. I have deployed my own apps to the App Store, and I have also helped others build and deploy theirs.\nMy professional career started with me freelancing for different people in the early to mid 2010\u0026rsquo;s. I helped both Bolivian clients and American clients improve and deploy their apps. By 2017, I really thought it was time for me to finish my college degree, and I stopped working to focus on my studies and finally finish all my courses in 2018. Shortly after, I started working for Banco Nacional de Bolivia. I started as an iOS Developer in 2019, and eventually got promoted to Software Architect in 2021. I was in charge of overseeing the development of all their mobile apps for both iOS and Android.\nI continued working with financial services after I left Banco Nacional de Bolivia, this time with Sharetec, a company that builds credit union software for multiple banking institutions in the USA, as a contractor through Blue Trail Software.\nAs of 2025, I am currently involved in the aircraft maintenance industry working for Trax, a company that developers software to aid aircraft maintenance personnel with their day to day tasks. Trax currently builds and deploys iPads apps for multiple airlines in the world, including some big ones like Southwest and Qatar Airlines.\nIn 2022, I published my first book, making it one of my favorite projects to date.\nAvailability for Hire If you are interested in working with me for any kind of project, in either short or long-term contracts, I established an LLC, Fairese, in 2025 specialized in iOS App Development. If you need work done on other technologies, I can use my contact network to find the right fit for your project.\nQuick Facts üíº 15 years of iOS development experience üéì Computer Systems Engineer (UPB, Bolivia) üõ†Ô∏è Former Software Architect at Banco Nacional de Bolivia ‚úàÔ∏è Currently at Trax, building iPad apps for airlines üßæ Founder of Fairese LLC, offering iOS development services ","tags":null},{"id":"27fa278f64361d08c7d9557998d72fb0","title":"Ten Years and Over a 100 Articles Later - And Break Notice","link":"/posts/ten-years-and-over-100-articles-later/","content":"This year marks 10 years since I started writing iOS apps. It also marks 10 years since I launched the first version of my blog, which was a thing hosted on Tumblr and on a completely different domain that I am not going to name here. A year after the Tumblr blog, I purchased andyibanez.com, got proper hosting, and started blogging on Wordpress with whatever little money I could make during my college days.\nThese have been 10 wild ten years - during all this time, not only did I learn iOS development, I also did tweak development for jailbroken devices during the period 2011 - 2014. I have had a bunch of different experiences since then, so I want to take this post to look back into the good old days, and what plans I have for the future.\nHow AndyIbanez.com Came To Life in 2019 Before I relaunched this website on 2019, I blogged - although with no consistency whatsoever - in the 2010\u0026rsquo;s. There were years I didn\u0026rsquo;t blog anything, and there were years that saw 5 new posts in total.\nIn September 2019, I applied for a banking job in early August. After all the interviews (which I thought I did really well), they didn\u0026rsquo;t call. After weeks of waiting and receiving no feedback altogether, I decided to relaunch my website from scratch, blog often to improve my portfolio - just for them to call me at the end of August. By the time they called me saying I got the job, I had already made a deal with myself that would blog weekly.\nTo be honest, this inspiration didn\u0026rsquo;t come on its own. A few months later I had started engaging very passively with the iOS dev community, by listening to Podcasts and reading other people\u0026rsquo;s content. A big drive that inspired me to write weekly was @_inside\u0026rsquo;s and @John Sundell\u0026rsquo;s StackTrace Podcast. At that time, John often talked about his upcoming static website generator for Swift. My original idea was to wait until that launched so I could create and maintain my site with my favorite programming language. But at some point, I couldn\u0026rsquo;t wait anymore, and I launched this website with Hugo. I didn\u0026rsquo;t end up using John\u0026rsquo;s site generator for this one like I wanted, but they still inspired me to blog with some consistency.\nA Blog Is Nothing With No Readers I have said this before, but every time I look at the achievements I got thanks to my website, I have to stop and thank everyone who reads these posts. Not only did you help me increase the reach of my website, helping it get featured in some of my favorite newsletters, but I have also seen on Github that a lot of people use what I teach for their own projects. It\u0026rsquo;s not an impact I see often, but it makes me happy to see I could contribute a little bit of knowledge to other people.\nHaving my readership also helped me tons by making Apple Contact me when my developer account was getting suspended with no explanation whatsoever. Everytime I remember that event, I don\u0026rsquo;t see it as a bad experience, but rather I see it as a point in which a bunch of people from the community helped me get in touch with Apple to get my Developer account back. A bunch of developers get their accounts suspended every day without having a chance to appeal, but my situation was different because I had everyone\u0026rsquo;s suppose by the time it happened. Truly, I thank you all for that.\nWhen I have my Swift Concurrency Workshop for try! Swift World, some of the people told me \u0026ldquo;when I saw it was you who was giving the workshop, I had to take it\u0026rdquo;. Those words made me incredibly happy, and it\u0026rsquo;s exactly the support one needs to keep creating content. I feel a simple \u0026ldquo;thank you\u0026rdquo; doesn\u0026rsquo;t cut it, but know that if you have such thoughts about my content, I am truly thankful to you.\nFuture Plans For My Content Blogging every week for two years - despite taking some breaks - actually takes a lot of effort. Some articles are fast to write, but others can take weeks before they reach any shape or form that I want to share. The situation wasn\u0026rsquo;t helped by COVID, as I was working more to begin with and spending more time in my computer. In all honestly I find it amazing that I was able to continue blogging throughout COVID. There were entire months in which I felt I was 16 hours a day in front of my computer, and the other 8 sleeping, probably with a 1 hour Reddit time occasionally. It\u0026rsquo;s a hard pace to keep. It has its amazingly positive returns in the shape of community support (and probably even money wise, but monetizing a blog is next to impossible in Bolivia), but I have realized that I cannot keep this pace for much longer.\nSo here\u0026rsquo;s a small announcement I want to make: I will take an indefinite break from posting on AndyIbanez.com (I promise I am not talking about months on end or years - I\u0026rsquo;m thinking it\u0026rsquo;s going to take 6 weeks). It\u0026rsquo;s really hard to say this because other than my Christmas breaks, I have never taken a break mid-year before. The truth is I need an actual break from coding on my spare time, and by the time I catch up with that, I want more time to work on my personal projects. As I said before, blogging often is a huge task, and there are times that if I am not working, I\u0026rsquo;m writing my blog, leaving me no time to work on my personal projects. I have recently taken a break from working on code out of my work hours by playing a little bit of my Nintendo Switch, but I need to balance things even more. The good news is I have recently switched jobs and my new job pays me better, treats me better, and doesn\u0026rsquo;t consume a ridiculous amount of hours like my banking job, so I already have more time for other things.\nI want to continue blogging and working for the community, so as soon as my indefinite break is over, I will start blogging, but it won\u0026rsquo;t be weekly anymore. I have not decided on the pace yet, but I\u0026rsquo;m thinking it\u0026rsquo;s going to be one article every 2 or three weeks. This is strictly tentative, and my plans may be different by the time I start blogging again.\nBut my biggest plan actually involves expanding my horizons. I have always wanted to bring my content to other formats, so I want to start doing videos for my articles - the idea is that for every article I have ever written (and will write), I will create a complimentary video for it. The video will cover the same content as the article, but it will be mostly useful for visual learners (I personally don\u0026rsquo;t like how most education content is audiovisual these days as I am more of a reading learner, but that\u0026rsquo;s another topic for another time), so you won\u0026rsquo;t have to read the article AND watch the video in order to understand the contents of it.\nEventually - and by the time I can leave Bolivia and settle down in a country that at least allows me to use PayPal - I will hopefully be able to monetize on my existing content or at least have the option of creating content on platforms such as Udemy and Gumroad (to be honest, I think the mere act of living in Bolivia not only holds back my own potential, but the potential of every single other programmer I know - we cannot monetize, hard to work outside, ridiculous fees when getting paid\u0026hellip; I could rage about this for hours, but I will abstain for now).\nSo my content will not end. Written articles will be less frequent, and I will start exploring other ways to create my content. The end goal is to balance work, community, and my personal life. Maybe someday I will achieve the indie life I so much dream of (that would allow me to work for the community almost full time, which is something I\u0026rsquo;d absolutely love), but until then, that will have to do. Not to mention I want to explore other areas of programming - I have had this itch of writing some C++ again (last time I wrote C++ must have been 10 years ago as well), I want to explore Rust, and I want to learn Ruby on Rails. I also need time for more personal growth!\nThank you so much for reading this article, and thank you once again for your everlasting support.\n","tags":["swift","apple","programming","ios"]},{"id":"7f41dbf337a68caaf77f681cb6e770e7","title":"The Mysterious CodableWithConfiguration Protocol","link":"/posts/the-mysterious-codablewithconfiguration-protocol/","content":"The Mysterious CodableWithConfiguration Protocol\nEvery year, at WWDC, Apple gives us a lot of new things to play around with. For the big new things, they prepare session videos and labs so developers can experiment with the new technologies and hopefully integrate them in their apps by the time the new OSes are out.\nThe \u0026ldquo;big things\u0026rdquo; are one thing, but Apple introduces a bunch of new APIs every year. Many (oh boy, many) of them do not get any coverage at WWDC at all. Not in a session, and sometimes not even a small mention of them anywhere.\nToday I want to talk about a new API that did not get coverage but I really like: CodableWithConfiguration.\nIntroducing CodableWithConfiguration CodableWithConfiguration is not really a protocol on its own - it\u0026rsquo;s actually a typealias for the union of the EncodableWithConfiguration and DecodableWithConfiguration protocols. If you have worked with Codable before, this all my sound familiar - That\u0026rsquo;s because Codable is really a typealias for Encodable \u0026amp; Decodable. If you already know how to use Codable, you can get started with this new shiny API very quickly. CodableWithConfiguration allows you to do exact same thing as plain old Codable - Serialize objects to and from different formats, such as JSON.\nBut what, exactly, is CodableWithConfiguration?\nCodableWithConfiguration allows us to inject a configuration object into the decoding and encoding processes of our codable types. These configuration allow you to have a bit more control over these processes without losing much flexibility. The configurations can do anything: Mutate objects, selectively decode or encode some keys, transform them\u0026hellip; The sky is the limit. Configuration objects can be, after all, anything you want.\nTo make this concept clearer, I will show you some examples of some use cases I have thought of, so hopefully you can start using CodableWithConfiguration right away.\nBefore continuing, keep in that this protocol was added on WWDC2021 to all Apple\u0026rsquo;s platforms, so you will need to target iOS 15, macOS 12, and so on.\nUsing CodableWithConfiguration To work with these examples, assume we have the following JSON objects:\nUser.json:\n{ \u0026#34;userId\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;AndyIbanez\u0026#34;, \u0026#34;avatarURL\u0026#34;: \u0026#34;https://pbs.twimg.com/profile_images/1403463750406098947/-gU-Ofaa_400x400.jpg\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;iOS Developer writing nifty apps.\u0026#34;, \u0026#34;interests\u0026#34;: [ \u0026#34;Programming\u0026#34;, \u0026#34;Pullip\u0026#34;, \u0026#34;The Legend of Zelda\u0026#34; ], \u0026#34;videogames\u0026#34;: [] } Videogame.json:\n{ \u0026#34;videogameId\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;The Legend of Zelda: Ocarina of Time\u0026#34;, \u0026#34;developer\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;publisher\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;personalRating\u0026#34;: 10, \u0026#34;hoursPlayed\u0026#34;: 128 } The idea is that we have a service that allows users to create their profiles and keep track of their videogames. Users can Update their avatar, biography, interests, and videogames. Web services don\u0026rsquo;t commonly allow you to edit your username, much less your user ID.\nThe info users can update from their videogames is their personal rating and the total hours they played them. The other info (videogame title, videogame ID, developer and publisher) belongs to the service, in a database somewhere, so it\u0026rsquo;s not really user editable.\nTo convert them into objects, your first instinct may be to create the following types:\nstruct User: Codable { let userId: Int? let username: String? var avatarURL: URL? var biography: String? var interests: [String]? var videogames: [Videogame]? } struct Videogame: Codable { let videogameId: Int? let title: String? let developer: String? let publisher: String? var personalRating: Int? var hoursPlayed: Int? } And this works fine, but configurations allow us to do some interesting things.\nTransforming properties based on configurations Configurations are really flexible. Just the fact you can define any object as your configuration object opens a world of possibilities. So from here on out, I will show you why these configuration objects are useful using examples, and we will start with simple property transformation.\nSuppose the API you are working with allows you to search for users. In a search view, you do not care about showing all the user info - you may care about having the username and avatar always visible. You can show a portion of the biography to help your users locate the right user they are searching for, but showing entire biographies could make your UI look funny. You could also show the first two interests in the search view, but definitely not all of them. You may also keep the user ID (although not visible) to use it as a reference for other calls.\nIf you wanted to achieve this with raw Codable, you would have to transform the properties after you have the objects. If the biography is too long or there are too many interests, it\u0026rsquo;s hard to know at decoding time because even if you implemented init(from:) yourself, you would have to hardcode all the logic there, and instead of having a reusable User object across your app, you would end up having a UserSearch object for the search results, a UserProfile object to display their entire profile, and so on. Something like this:\n// UserSearch.swift // Notice that we don\u0026#39;t have the videogames property, because it\u0026#39;s not used in search results. struct UserSearch: Codable { let userId: Int? let username: String? let avatarURL: URL? let biography: String? let interests: [String]? init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) userId = try container.decodeIfPresent(Int.self, forKey: .userId) username = try container.decodeIfPresent(String.self, forKey: .username) avatarURL = try container.decodeIfPresent(URL.self, forKey: .avatarURL) if let tempBiography = try container.decodeIfPresent(String.self, forKey: .biography) { // The biography will be truncated to a max of 20 characters. biography = String(tempBiography.prefix(20)) } else { biography = nil } if let tempInterests = try container.decodeIfPresent([String].self, forKey: .interests) { // We will keep a maximum of two interests. interests = Array(tempInterests.prefix(2)) } else { interests = nil } } } In the code above, we are hard coding the logic to limit biographies and interests in the decoder initializer. This forces us to write more code, but that is not necessarily a bad thing. The main problem is the biography length and interests have their limitations hard coded and cannot be changed.\nstruct UserProfile: Codable { let userId: Int? let username: String? let avatarURL: URL? let biography: String? let interests: [String]? let videogames: [Videogame] } The code above is much easier, but it\u0026rsquo;s still a copy/paste of all the properties of the UserSearch object. It has one additional property for videogames, but since this displays complete user profiles, we do not need to truncate the biography or limit the number of interests.\nClearly, in this situation, prior to to CodableWithConfiguration, it\u0026rsquo;s much better to just apply the transformations after decoding, maybe even at the moment you show your UI.\n// We decoded a User object called `user` userBio.text = user.biography.prefix(20) The way we do this with CodableWithConfiguration is prettier. We will start by creating a UserConfiguration object that will hold properties to dynamically limit biography length and a maximum number of interests.\nstruct UserConfiguration { // If nil, there is no limitation to biographies length. let biographyMaxLength: Int? // If nil, there is no limitations for interests let maxInterests: Int? } Next, we will grab the User object we created in the section above, and we will make it conform to both Codable and CodableWithConfiguration\nstruct User: Codable, CodableWithConfiguration { //... } Do note that by making the class conform with Codable, you will get the CodingKeys for free. If you only conform to CodingWithConfiguration you will need to provide the enum yourself.\nNext, we need to implement two methods:\ninit(from decoder: Decoder, configuration: UserConfiguration) throws { } func encode(to encoder: Encoder, configuration: UserConfiguration) throws { } CodableWithConfigurations offers the DecodingConfiguration and DecodingConfiguration associated types, and since we are providing the initializers ourselves, the compiler will infer that the typealias for both is UserConfiguration. For now, we will only use the decoder, we will add a fatalError() call to encode(to:configuration) since we don\u0026rsquo;t plan using it (an example of how you can use it will be shown below).\nWe will now implement init(from:configuration) so that it uses our configuration object to dynamically limit the biography, the interests, or both:\ninit(from decoder: Decoder, configuration: UserConfiguration) throws { let container = try decoder.container(keyedBy: CodingKeys.self) userId = try container.decodeIfPresent(Int.self, forKey: .userId) username = try container.decodeIfPresent(String.self, forKey: .username) avatarURL = try container.decodeIfPresent(URL.self, forKey: .avatarURL) biography = try { let bio = try container.decodeIfPresent(String.self, forKey: .biography) if let maxLength = configuration.biographyMaxLength, let bio = bio { // We will use our configuration object to dynamically truncate the biography to a length. Neat! return String(bio.prefix(maxLength)) } return bio }() interests = try { let interests = try container.decodeIfPresent([String].self, forKey: .interests) if let maxInterests = configuration.maxInterests, let interests = interests { // Using the configuration object to limit the max number of interests. return Array(interests.prefix(maxInterests)) } return interests }() videogames = try container.decodeIfPresent([Videogame].self, forKey: .videogames) } It looks like a mouthful, but I want you to sit down and appreciate the power of CodingWithConfiguration. We can now configure our object at decoding time, and we no longer need to do these transformations when showing the UI or creating different User* codable objects to achieve the same goal. The same user object we use to limit the amount of data displayed in the Search view, is the same object we can use to display a full user profile, in two different views.\nChoosing the properties that should be included in a JSON Another use case for CodableWithConfiguration is to limit the keys that should be decoded or encoded. This can be useful when you have an API that returns you a JSON, and then expects that JSON back with some changes for some operation.\nSuppose you want to allow users to edit their videogame data (personalRating and hoursPlayed) and it expects a JSON with the same structure as Videogame. When we are updating a videogame, we only want to give the API the personalRating, hoursPlayed, and the videogameId. The ID is necessary, otherwise the webservice won\u0026rsquo;t know what videogame we want to update. On the other hand, we don\u0026rsquo;t really need to send the title, developer, and publisher because the service owns this data and it\u0026rsquo;s not user editable. So to save the user a bit of their data plan, we can filter out those properties only when we are performing an update.\nStart by adding the CodableWithConfiguration conformance to videogame.\nstruct Videogame: Codable, CodableWithConfiguration {} You will also want to explicit declare the coding keys, otherwise they stay private and there unaccessible:\nenum CodingKeys: String, CodingKey, CaseIterable { case videogameId case title case developer case publisher case personalRating case hoursPlayed } This time, we will implement encode(to:configuration) method.\nfunc encode(to encoder: Encoder, configuration: VideogameConfiguration) throws { var container = encoder.container(keyedBy: CodingKeys.self) if configuration.codingKeys.contains(.videogameId) { try container.encode(videogameId, forKey: .videogameId) } if configuration.codingKeys.contains(.title) { try container.encode(title, forKey: .title) } if configuration.codingKeys.contains(.developer) { try container.encode(developer, forKey: .developer) } if configuration.codingKeys.contains(.publisher) { try container.encode(publisher, forKey: .publisher) } if configuration.codingKeys.contains(.personalRating) { try container.encode(personalRating, forKey: .personalRating) } if configuration.codingKeys.contains(.hoursPlayed) { try container.encode(hoursPlayed, forKey: .hoursPlayed) } } This time, we are simply checking to see if the configuration contains a given key, and if it does, we include it in the resulting JSON.\nWe will also add two helper static properties on VideogameConfiguration to have an easy reference to the object\u0026rsquo;s coding keys:\nstruct VideogameConfiguration { let codingKeys: Set\u0026lt;Videogame.CodingKeys\u0026gt; static let allKeys = Videogame.CodingKeys.allCases static let userWriteable: Set\u0026lt;Videogame.CodingKeys\u0026gt; = Set(arrayLiteral: .hoursPlayed, .personalRating, .videogameId) } For Videogames (and you could do this for User as well), you can implement decode(from:configuration) so that it checks each key to see if you need it:\ninit(from decoder: Decoder, configuration: VideogameConfiguration) throws { let container = try decoder.container(keyedBy: CodingKeys.self) if configuration.codingKeys.contains(.videogameId) { videogameId = try container.decodeIfPresent(Int.self, forKey: .videogameId) } else { videogameId = nil } if configuration.codingKeys.contains(.title) { title = try container.decodeIfPresent(String.self, forKey: .title) } else { title = nil } if configuration.codingKeys.contains(.developer) { developer = try container.decodeIfPresent(String.self, forKey: .developer) } else { developer = nil } if configuration.codingKeys.contains(.publisher) { publisher = try container.decodeIfPresent(String.self, forKey: .publisher) } else { publisher = nil } if configuration.codingKeys.contains(.personalRating) { personalRating = try container.decodeIfPresent(Int.self, forKey: .personalRating) } else { personalRating = nil } if configuration.codingKeys.contains(.hoursPlayed) { hoursPlayed = try container.decodeIfPresent(Int.self, forKey: .hoursPlayed) } else { hoursPlayed = nil } } I also want to take this chance to take you to the Users decode(from:configuration) method before we move on. As the last line of the method, you have this call:\nvideogames = try container.decodeIfPresent([Videogame].self, forKey: .videogames) And this works fine, but if you need to, you can actually pass a configuration to decode videogames differently as well. To do this, we can add an optional videogameConfiguration property to UserConfiguration:\nstruct UserConfiguration { // If nil, there is no limitation to biographies length. let biographyMaxLength: Int? // If nil, there is no limitations for interests let maxInterests: Int? /// The configuration we will use for Videogames let videogameConfiguration: VideogameConfiguration? } And then we can simply check for it at decoding time to see if we want to decode by default with Codable\u0026rsquo;s encode method, or with CodableWithConfiguration\u0026rsquo;s method:\nif let vgConfig = configuration.videogameConfiguration { videogames = try container.decodeIfPresent([Videogame].self, forKey: .videogames, configuration: vgConfig) } else { videogames = try container.decodeIfPresent([Videogame].self, forKey: .videogames) } You can do the same with Encoder.\nApplying our Configurations to Codable Objects So far, I have shown you how you can create your configurations, but how do you actually use them?\nFirst, I have some bad news for you. As of now, these are only useful when you are dealing with \u0026ldquo;envelope\u0026rdquo; JSON objects. That is to say, if you have a JSON that looks like this:\n{ \u0026#34;resultCount\u0026#34;: 30, \u0026#34;totalPages\u0026#34;: 5, \u0026#34;resultsPerPage\u0026#34;: 5, \u0026#34;currentPage\u0026#34;: 3, \u0026#34;videogames: [] } You have an envelope object. An envelope object is a top-level JSON that wraps one or more complex JSON objects (in this case, videogames is our \u0026ldquo;wrapped\u0026rdquo; object, which contains an array of Videogames).\nYou cannot apply configurations to top level objects directly.\n{ \u0026#34;videogameId\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;The Legend of Zelda: Ocarina of Time\u0026#34;, \u0026#34;developer\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;publisher\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;personalRating\u0026#34;: 10, \u0026#34;hoursPlayed\u0026#34;: 128 } In this example, the entire object is our videogame. There\u0026rsquo;s no wrapped object to speak of, so if you wanted to apply a configuration to a top-level Videogame, you sadly can\u0026rsquo;t. This is because neither JSONEncoder or JSONDecoder have a variation of their decoding/encoding methods that take a configuration. If you are interested in this functionality, please dupe my feedback: FB9662199.\nThe CodableConfiguration Property Wrapper We have finally arrived to the section were we talk about how we can actually apply our configurations.\nThere is a property wrapper called @CodableConfiguration. You use this property wrapper with codable objects.\nIn order to use this property wrapper, you need to create configuration providers and provide configurations for encoding and decoding. These provider objects must conform to DecodingConfigurationProviding and EncodingConfigurationProviding (for some reason, there is no typealias for DecodingConfigurationProviding \u0026amp; EncodingConfigurationProviding). To fulfill their requirements you need to provide static properties with the configuration you want to use. Going back to our user search example, we can create the following provider used exclusively for User objects found within other objects.\nstruct UserConfigurationSearchProviding: DecodingConfigurationProviding, EncodingConfigurationProviding { static var decodingConfiguration: UserConfiguration = .init(biographyMaxLength: 20, maxInterests: 2, videogameConfiguration: nil) static var encodingConfiguration: UserConfiguration = .init(biographyMaxLength: 20, maxInterests: 2, videogameConfiguration: nil) } Unfortunately, you need to provide both configurations, even if you don\u0026rsquo;t use them - recall attempting to encode a User will result in fatalError() being called. For now, we will simply use the same configuration we use for decoding.\nThe result object looks like this:\n{ \u0026#34;resultCount\u0026#34;: 1, \u0026#34;totalPages\u0026#34;: 1, \u0026#34;currentPage\u0026#34;: 1, \u0026#34;resultsPerPage\u0026#34;: 5, \u0026#34;users\u0026#34;: [ { \u0026#34;userId\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;AndyIbanez\u0026#34;, \u0026#34;avatarURL\u0026#34;: \u0026#34;https://pbs.twimg.com/profile_images/1403463750406098947/-gU-Ofaa_400x400.jpg\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;iOS Developer writing nifty apps. I was born and raised in La Paz, Bolivia many moons ago.\u0026#34;, \u0026#34;interests\u0026#34;: [ \u0026#34;Programming\u0026#34;, \u0026#34;Pullip\u0026#34;, \u0026#34;The Legend of Zelda\u0026#34; ], \u0026#34;videogames\u0026#34;: [ { \u0026#34;videogameId\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;The Legend of Zelda: Ocarina of Time\u0026#34;, \u0026#34;publisher\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;developer\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;personalRating\u0026#34;: 10, \u0026#34;hoursPlayed\u0026#34;: 900 }, { \u0026#34;videogameId\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;The Legend of Zelda: Majora\u0026#39;s Mask\u0026#34;, \u0026#34;publisher\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;developer\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;personalRating\u0026#34;: 10, \u0026#34;hoursPlayed\u0026#34;: 800 } ] } ] } And so, in order to decode it with the configuration object, you can do something like this:\nstruct UserSearch: Codable { let resultCount: Int let totalPages: Int let resultsPerPage: Int let currentPage: Int @CodableConfiguration(from: UserConfigurationSearchProviding.self) var users = [User]() } Beautiful! Injecting the provider this way will allow us to reuse the same User object and mutate it as necessary without having to delegate the work to upper layers of our app.\nlet users = try! JSONDecoder().decode(UserSearch.self, from: jsonData!) print(users.users.first!.biography) // \u0026#34;iOS Developer writin\u0026#34; print(users.users.first!.interests) // [\u0026#34;Programming\u0026#34;, \u0026#34;Pullip\u0026#34;] Now suppose our user wants to update some data in their videogames. You can start creating the configuration provider like so:\nstruct VideogameConfigurationUpdateProviding: DecodingConfigurationProviding, EncodingConfigurationProviding { static var decodingConfiguration: VideogameConfiguration = VideogameConfiguration(codingKeys: VideogameConfiguration.allKeys) static var encodingConfiguration: VideogameConfiguration = VideogameConfiguration(codingKeys: VideogameConfiguration.userWriteable) } The model object has a single property called updatedVideogames.\nstruct VideogameUpdateRequest: Codable { @CodableConfiguration(from: VideogameConfigurationUpdateProviding.self) var updatedVideogames = [Videogame]() init(videogames: [Videogame]) { self.updatedVideogames = videogames } } When this gets converted into JSON, it will discard all the properties of the videogames except for videogameId, hoursPlayed, and personalRating, which is the bare minimum we need to update their data:\nlet jsonString = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;resultCount\u0026#34;: 1, \u0026#34;totalPages\u0026#34;: 1, \u0026#34;currentPage\u0026#34;: 1, \u0026#34;resultsPerPage\u0026#34;: 5, \u0026#34;users\u0026#34;: [ { \u0026#34;userId\u0026#34;: 1, \u0026#34;username\u0026#34;: \u0026#34;AndyIbanez\u0026#34;, \u0026#34;avatarURL\u0026#34;: \u0026#34;https://pbs.twimg.com/profile_images/1403463750406098947/-gU-Ofaa_400x400.jpg\u0026#34;, \u0026#34;biography\u0026#34;: \u0026#34;iOS Developer writing nifty apps. I was born and raised in La Paz, Bolivia many moons ago.\u0026#34;, \u0026#34;interests\u0026#34;: [ \u0026#34;Programming\u0026#34;, \u0026#34;Pullip\u0026#34;, \u0026#34;The Legend of Zelda\u0026#34; ], \u0026#34;videogames\u0026#34;: [ { \u0026#34;videogameId\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;The Legend of Zelda: Ocarina of Time\u0026#34;, \u0026#34;publisher\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;developer\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;personalRating\u0026#34;: 10, \u0026#34;hoursPlayed\u0026#34;: 900 }, { \u0026#34;videogameId\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;The Legend of Zelda: Majora\u0026#39;s Mask\u0026#34;, \u0026#34;publisher\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;developer\u0026#34;: \u0026#34;Nintendo\u0026#34;, \u0026#34;personalRating\u0026#34;: 10, \u0026#34;hoursPlayed\u0026#34;: 800 } ] } ] } \u0026#34;\u0026#34;\u0026#34; let jsonData = jsonString.data(using: .utf8) let users = try! JSONDecoder().decode(UserSearch.self, from: jsonData!) // My games var games = users.users.first!.videogames! var firstGame = games[0] firstGame.personalRating = 11 firstGame.hoursPlayed = 1000 var secondGame = games[1] secondGame.personalRating = 11 secondGame.hoursPlayed = 900 let allGames = [firstGame, secondGame] let gamesToUpdate = VideogameUpdateRequest(videogames: allGames) print(gamesToUpdate) And as you can see, the JSON contains very few properties, as it is expected:\n{ \u0026#34;updatedVideogames\u0026#34;: [ { \u0026#34;personalRating\u0026#34;: 11, \u0026#34;hoursPlayed\u0026#34;: 1000, \u0026#34;videogameId\u0026#34;: 1 }, { \u0026#34;personalRating\u0026#34;: 11, \u0026#34;hoursPlayed\u0026#34;: 900, \u0026#34;videogameId\u0026#34;: 2 } ] } Conclusion CodableWithConfiguration is a very interesting object, and one of my favorite new additions to WWDC2021 for sure. Being able to inject configurations to have control over the encoding and decoding processes opens up a world of possibilities and cleaner code. This new API also makes use of property wrappers, which are a personal favorite feature of mine added to Swift in the past few years. While it\u0026rsquo;s hard to use them with top-level objects, the power is still there, and hopefully in the future, we will see versions of JSONEncoder and JSONDecoder that can take configuration providers to work with root objects.\n","tags":["swift","apple","programming","ios","macos","ipados","watchos","wwdc2021","codable","json","no overview available"]},{"id":"c10c557878db74bef8dd7b6f75f43b65","title":"try! Swift World: An Overview of the Modern Concurrency Features Introduced in Swift 5.5","link":"/tsw-concurrency2021/","content":"Workshop Description Swift 5.5 introduced an exciting new set of concurrency APIs. Starting with async/await, the language has received a set of features that allow us to write shorter, concise, and more obvious concurrent code. You will learn how the new concurrency APIs help us avoid \u0026ldquo;pyramids of doom\u0026rdquo; with async/await, how structured concurrency is cooperative and how to apply it in the world; how unstructured concurrency gives us more control without sacrificing code readability; how to transform callback and even delegate based code into async/await, and how actors isolate their own state to make them usable across concurrent code. We will finish this course giving a bird\u0026rsquo;s eye overview of other new concurrency features, such as global actors, the @TaskLocal property wrapper, and AsyncSequences and AsyncStreams. By the end of this workshop, you will have a solid of understanding of the new concurrency system in Swift in order to tackle concurrency problems in the real world.\nXcode 13 is required for this course, as the sample code will be built with SwiftUI targeting the latest Apple OSes.\nMaterials Post-workshop The following sample project was created in this workshop. You will also find the slides(ModernConcurrencyWorkshopSWWSept2021.key) in this Github repo:\nModernConcurrencyWorkshopTrySwiftWorldSept2021 ","tags":null},{"id":"1e945e079ab3a04bb1967169c6b61f89","title":"Modern Swift Concurrency Summary, Cheatsheet, and Thanks","link":"/posts/modern-swift-concurrency-summary-cheatsheet-thanks/","content":"Table of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Group Tasks in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks Since WWDC21, we have talked, extensively, about all the new concurrency features introduced in Swift 5.5. We covered a lot of topics, so I decided to finish off this series writing a summary article were we cover the most important topics of each article. Links will be given to the relevant articles when necessary in case this summary is not enough.\nasync/await async and await are the most fundamental keywords of the new concurrency system. When you learn to program, you are used to writing code that executes linearly (called procedural programming). Your code executes its lines in the order you give them. When dealing with concurrent tasks, prior to async/await, Apple gave us callback/closure-based concurrency, in which we are notified via a closure when the task is done, or delegate-based concurrency in the case of older concurrent code. Callback and delegate based concurrency can alter the order in which our program runs. If we have a set of linear instructions, we can be notified as that linear code executes and receive new data from a different thread. This makes it possible to deal with concurrency, but it can become hard to understand as time goes by. async/await allow us to write linear concurrent code that executes from top to bottom. To work with this, functions that can be called asynchronously should be marked as async in the function signature. func downloadData() async throws -\u0026gt; CustomData { //... } When we call a function marked as async, it needs to be prepended with the word await. func processData() async throws -\u0026gt; CustomData { let newData = try await downloadData() return newData } When execution of our code reaches the await keyword, execution of our code may be suspended suspended, and the thread our code is running on is free to do other work. This other work is assigned by the system. Because our code is suspended, the lines below the await will not be executed until the async task is done running. If our code was suspended, at some point, the async task will be done running. The system will come back to our code and continue executing our code. That means everything under the await call will resume execution. async/await allow us to keep a procedural flow that runs from top to bottom thanks to thread suspension. Anything below an await call is called a continuation. This is relevant to know if you want to convert delegate or closure based concurrent code into async/await. It\u0026rsquo;s important to note that a continuation may not be executed in the same thread that was suspended. If you need to update your UI, you should run that code in the @MainActor. async code needs to run in async contexts. This means functions marked as async, or if you create such context yourself with Task {}. To learn about async/await, checkout the Understanding async/await in Swift article.\nConverting Delegate and Closure Based Code into async/await. The compiler can already do this for you for free without any effort - if you start typing a method that you expect it to have a closure, you may find the compiler has already created an async version of it for you for free. You can create such conversions yourself. To create such conversions, you create manual continuations. Recall a continuation is everything that happens after an await call. To create these conversions yourself, you can use the withCheckedContinuation or withCheckedThrowingContinuation functions. Use them to wrap your closure-based calls, or store references to the continuations in order to call them later as part of delegate-based calls. These methods will provide you with the continuation you need to call explicitly when your concurrent tasks are done. You can call them passing in the \u0026ldquo;returned\u0026rdquo; value, or throwing an error (in the case of withCheckedThrowingContinuation. You are required to call a continuation exactly once. Don\u0026rsquo;t forget to call it. Do call it once and no more. The following code hows how to convert closure-based concurrency into async/await. func downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { return try await withCheckedThrowingContinuation({ (continuation: CheckedContinuation\u0026lt;DetailedImage, Error\u0026gt;) in downloadImageAndMetadata(imageNumber: imageNumber) { image, error in if let image = image { continuation.resume(returning: image) } else { continuation.resume(throwing: error!) } } }) } Converting delegate-based calls into async/await is slightly more involved, but not impossible. You need to store the continuation provided by the withChecked*Continuation call and call it whenever it is appropriate. class ContactPicker: NSObject, CNContactPickerDelegate { private typealias ContactCheckedContinuation = CheckedContinuation\u0026lt;CNContact, Never\u0026gt; // 1 private unowned var viewController: UIViewController private var contactContinuation: ContactCheckedContinuation? // 2 private var picker: CNContactPickerViewController init(viewController: UIViewController) { self.viewController = viewController picker = CNContactPickerViewController() super.init() picker.delegate = self } func pickContact() async -\u0026gt; CNContact { // 3 viewController.present(picker, animated: true) return await withCheckedContinuation({ (continuation: ContactCheckedContinuation) in self.contactContinuation = continuation }) } func contactPicker(_ picker: CNContactPickerViewController, didSelect contact: CNContact) { contactContinuation?.resume(returning: contact) // 4 contactContinuation = nil picker.dismiss(animated: true, completion: nil) } } You are not limited to converting delegate-based concurrency. Even delegate-based call that does everything in the same thread can benefit from this (but do consider if your effort will be worth it and it won\u0026rsquo;t be over-engineering. To learn more about converting existing closure or delegate based code into async/await, check out the Converting closure-based code into async/await in Swift article.\nStructured Concurrency Having multiple await calls in a row does not mean that concurrency is taking place. The code below is not concurrent, although the await calls are independent so they could very well be. func downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { let image = try await downloadImage(imageNumber: imageNumber) let metadata = try await downloadMetadata(for: imageNumber) return DetailedImage(image: image, metadata: metadata) } Structured concurrency allows us to write concurrent code that can also be read from top to bottom. We can launch multiple tasks in parallel easily. There\u0026rsquo;s two types of structured concurrency: async let calls and Task Groups. async let concurrency Calls that can be awaited can also be executed concurrently. To do so, simply add the async keyword in your variable definition before the let or var, and remove the await call. Then simply await for the variable at the point that you need it. The following code is the same code as above, but it now performs both async tasks concurrently. func downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { async let image = downloadImage(imageNumber: imageNumber) async let metadata = downloadMetadata(for: imageNumber) return try DetailedImage(image: await image, metadata: await metadata) } Despite the fact that image and metadata are async values, the code is still very easy to read, because we await for their values before we return from the function. async let is perfect when you know the exact number of concurrent tasks you need to perform. In the example above, we know we have two: downloadImage and downloadMetadata. To learn more about structured concurrency with async let, read the Structured Concurrency in Swit: Using async let article.\nGroup Tasks Use group tasks when the amount of concurrency is not known before hand. Like fetching a variable number of URLs from a web service, which you later want to download concurrently. To launch them, use the withThrowingTaskGroup or withTaskGroup methods. In the example above, we create a Task Group to download a variable number of images. func downloadMultipleImagesWithMetadata(images: Int...) async throws -\u0026gt; [DetailedImage]{ var imagesMetadata: [DetailedImage] = [] try await withThrowingTaskGroup(of: DetailedImage.self, body: { group in for image in images { group.async { async let image = downloadImageAndMetadata(imageNumber: image) return try await image } } for try await image in group { imagesMetadata += [image] } }) return imagesMetadata } the group variable will have our data as it is downloaded. It\u0026rsquo;s an AsyncSequence, so you can iterate over it, or apply functions such as filter, map, reduce. You can specify the priority of the group, making this structured concurrency method a bit more flexible than async let. group.async(priority: .userInitiated) { //... } We can be ready for cancellation with asyncUnlessCancelled. group.asyncUnlessCancelled(priority: nil) { //... } Sendable Types Sendable types are the types that work well with concurrency. The compiler won\u0026rsquo;t complain if you use these in concurrent contexts. There are @Sendable closures that only work with Sendable types (a protocol). @Sendable closures cannot capture mutating variables. You should only capture value types, actors, classes, or other objects that implement their own synchronization. To learn more about Group Tasks and/or Sendable types, read the Structured Concurrency With Task Groups in Swift and Understanding Actors in the New Concurrency Model in Swift articles.\nThe Task Tree An important concept of structured concurrency (for both async let and Task Groups) is the Task Tree.\nasync functions can spawn other async tasks. These spawned tasks are the children of the task that launched them. Children tasks inherit info from their parents, such as priority, local variables, and cancellation. It is said that a Parent task can only finish their work when their children have also finished their work. Cancellation of a task is governed by the task tree and it is cooperative. When a task is cancelled - either manually via a cancel or cancellAll call, or when they throw an error -, the tasks in the tree are not cancelled instantly. Instead, the task is marked as cancelled, but they continue doing their work until they see it is appropriate to be cancelled. When a parent task is marked as cancelled, its children tasks are marked as cancelled as well. To check the cancellation status of a task and determine if you need to stop working, you can use the Task.checkCancellation() method for tasks that may throw errors, or Task.isCancelled for tasks that don\u0026rsquo;t throw. func downloadImage(imageNumber: Int) async throws -\u0026gt; UIImage { try Task.checkCancellation() // \u0026lt;- If we are cancelled, this throws. let imageUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part3/\\(imageNumber).png\u0026#34;)! let imageRequest = URLRequest(url: imageUrl) let (data, imageResponse) = try await URLSession.shared.data(for: imageRequest) guard let image = UIImage(data: data), (imageResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.badImage } return image } To learn more about the Task Tree, check out the Structured Concurrency in Swit: Using async let article.\nUnstructured Concurrency Unstructured concurrency is useful when you don\u0026rsquo;t have such a procedural flow for your tasks, but they can still help you greatly reduce the amount of unusual execution flows. Unstructured concurrency also gives you more control over structured concurrency.\nThere\u0026rsquo;s two ways to do unstructured concurrency: Task calls and detached tasks with Task.detached.\nTask When you use Task {}, you are actually launching a concurrent task. This is how the \u0026ldquo;bridge\u0026rdquo; between the async and sync worlds is done. You can store them in variables so you can manually cancel them when necessary. You can also start them with a specific priority. To learn more about Unstructured Concurrency with tasks, check out the Introduction to Unstructured Concurrency in Swift article.\nDetached tasks Launched with Task.detached {}. Unlike the other kinds of tasks, they do not inherit anything from their parent tasks. Not even the priority. They are independent from the context they are launched in. To learn more about Detached Tasks, check out the Unstructured Concurrency With Detached Tasks in Swift article.\nActors Actors are reference types that isolate their state from the rest of the program. This is a perfect mechanism to prevent data races in your program. They provide their own internal synchronization for when they are accessed. This prevents data races. You cannot modify an actor state directly. Every call that modifies the actor needs to go through the actor itself. All the methods the actor provides are exposed through await calls even when you don\u0026rsquo;t explicitly mark them as such. Properties are method that don\u0026rsquo;t need to be or can\u0026rsquo;t be isolated can be marked as nonisolated. You should take care to design for actor reentrancy (entering the actor multiple times). Because its state changes, you may need to do some considerations. For example, an actor that downloads and caches images may download and cache the same image twice if entered in quick succession. Understanding Actors in the New Concurrency Model in Swift\n@MainActor and Global Actors We can define global actors across different files and types. Marking a class as running on a specific actor ensures that all code will be run in the same thread. You declare global actors with the @globalActor attribute, and then you use that actor by referencing its name prepending a @. In the example above, we create an actor called MediaActor and we create a variable called videogames that runs on this actor. @globalActor struct MediaActor { actor ActorType { } static let shared: ActorType = ActorType() } struct Videogame { let id = UUID() let name: String let releaseYear: Int let developer: String } @MediaActor var videogames: [Videogame] = [] The @MainActor is a special global actor provided by Swift that runs on the main thread. We can mark view controllers, view models, and other code that we want to force to run on the main thread as @MainActor. Marking a class with an actor means that all its properties and methods will be run on that same actor. In the example below, we add the @MainActor attribute to a view controller, ensure all its code runs on the main thread. @MainActor class GameLibraryViewController: UIViewController { //... nonisolated var fetchVideogameTypes() -\u0026gt; [VideogameType] { ... } //... } It\u0026rsquo;s possible to override the actor of specific methods.\n@MainActor class GameLibraryViewController: UIViewController { @MediaActor func doThisInAnotherActor() {} } @MainActor and Global Actors in Swift\nSharing Data Across Tasks with @TaskLocal The @TaskLocal property wrapper can be used to share data across local tasks. The tasks should be part of the same tree - detached tasks launched within some task will not inherit them. class ViewController: UIViewController { @TaskLocal static var currentVideogame: Videogame? // ... } Only static properties can have this property wrapper. To write values to them, we need to bind them values. override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. let vg = Videogame(title: \u0026#34;The Legend of Zelda: Ocarina of Time\u0026#34;, year: 1998) Self.$currentVideogame.withValue(vg) { // we cam launch some async tasks here that make use of the LocalValue } } Reading them is an awaited call. func expensiveVidegameOperation() async { if let vg = await ViewController.currentVideogame { print(\u0026#34;We are processing \\(vg.title)\u0026#34;) } } Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model\nAsyncSequence and AsyncStream AsyncSequence allows us to receive values over time, awaiting them in a loop, or even applying functions such as filter, map, reduce to them. func loadVideogames() async { let url = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part11/videogames.csv\u0026#34;)! let videogames = url .lines .filter { $0.contains(\u0026#34;|\u0026#34;) } .map { Videogame(rawLine: $0) } do { for try await videogame in videogames { print(\u0026#34;\\(videogame.title) (\\(videogame.year ?? 0))\u0026#34;) } } catch { } } Worth noting that the sequence will not \u0026ldquo;start\u0026rdquo; until we put it in a loop. Applying higher order functions simply limits what will be received in the await for loop. Multiple APIs have been updated to support this in WWDC21, including the NSNotificationCenter APIs. The AsyncStream object can be used to take a stream of values from somewhere and convert it into something that can be used in a for await loop. For example, if you receive GPS updates in real time in a delegate, you can wrap all that up and receive the new coordinates in a loop instead. Using AsyncSequence in Swift\nCredits and Thanks The articles in this series have quickly become one of my most visited pages on my website since I relaunched it in 2019. Because of that, I have also received a lot feedback from members in the community.\nI want to take a minute to thank everyone who has written me regarding typos or weird phrasing in some sentences. I have taken a lot of care into improving the articles with all your opinions and comments. You have all helped me increase the quality of these articles a lot.\nI have received a lot of emails, and it\u0026rsquo;s really, really hard to name all of you due to the sheer amount of people who wrote to me. So, thank you all so much for helping me improve the quality of my blog. I am also sorry if I could not reply to everyone - I got a lot of email and sometimes I lost track of who I had replied to.\nThere is one person in particular I want to mention by name, because he has spent a lot of time going through all the articles in the series and sending very detailed emails with observations and improvements. This person\u0026rsquo;s emails were actually very long, and whenever I received an email from him, I spent a long time working through the fixes. That said, every second I spent working on his recommendations paid off, and this article series is probably one of the things I\u0026rsquo;m very proud of. This person is Dennis Birch. Big thanks to Dennis for helping this article series become one of my favorites.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"e459e6cc2e246ecd4b1b4043b69ccac9","title":"Using AsyncSequence in Swift","link":"/posts/using-asyncsequence-in-swift/","content":" This article is part of my Modern Concurrency in Swift Article Series.* Table of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Group Tasks in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks Along the new concurrency APIs introduced in Swift at WWDC2021, we have AsyncSequence. AsyncSequence is a collection protocol that allow us to receive data in loops and even top higher order functions - such as filter, map and reduce - asynchronously, being able to await for new data as it becomes available.\nIntroducing AsyncSequence As a sequence, we can do with them anything we can do with any other sequences. Other than applying higher order functions, we can also search through them, count the number of elements, and more.\nWhat we need to understand is the underlying behavior of these sequences.\nRecall that await means suspension - when our code runs, if it encounters an await call, it will begin doing the awaited work somewhere else, and execution of your code will stop. When the asynchronous task is done downloading, the compiler will, at some point begin executing everything below the awaited call.\nAsyncSequence has essentially the same behavior, save a key difference.\nImagine you have the following file in a remote server:\n// videogames.csv The Legend of Zelda: Ocarina of Time|1998|10 The Legend of Zelda: Majora\u0026#39;s Mask|2000|10 The Legend of Zelda: The Wind Waker|2003|10 Tales of Vesperia|2008|8 Tales of Graces|2011|9 Tales of the Abyss|2006|10 Tales of Xillia|2013|10 For your convenience, you can find that file here.\nUsing AsyncSequence It is very easy to consume this file, line by line:\nstruct Videogame { let title: String let year: Int? let score: Int? init(rawLine: String) { let splat = rawLine.split(separator: \u0026#34;|\u0026#34;) self.title = String(splat[0]) self.year = Int(splat[1]) self.score = Int(splat[2]) } } //... func loadVideogames() async { let url = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part11/videogames.csv\u0026#34;)! var videogames: [Videogame] = [] do { for try await rawVg in url.lines { if rawVg.contains(\u0026#34;|\u0026#34;) { // Valid videogame videogames += [Videogame(rawLine: rawVg)] } } } catch { // Handle the error } } lines is an AsyncSequence - as the URL obtains new lines from the file, they processed, one by one. It\u0026rsquo;s not accurate to say it\u0026rsquo;s an array or any other kind of specific collection. This really is just an abstraction for something that will deliver values to us overtime. We can also create our own AsyncSequences.\nBut AsyncSequence wouldn\u0026rsquo;t be half as interesting if we could\u0026rsquo;t refactor the code into something more sensible that makes equal sense.\nfunc loadVideogames() async { let url = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part11/videogames.csv\u0026#34;)! let videogames = url .lines .filter { $0.contains(\u0026#34;|\u0026#34;) } .map { Videogame(rawLine: $0) } do { for try await videogame in videogames { print(\u0026#34;\\(videogame.title) (\\(videogame.year ?? 0))\u0026#34;) } } catch { } } At this point, there\u0026rsquo;s one thing worth mentioning: When we are using AsyncSequence this way - chaining multiple calls to transform our \u0026ldquo;collection -, you will notice that sequence doesn\u0026rsquo;t \u0026ldquo;start\u0026rdquo; automatically. If you do not add the for loop there, the sequence will not start, and you will see nothing. This means that we have some limitations, like we can\u0026rsquo;t get the number of elements by calling .count on videogames. I have also noticed that it\u0026rsquo;s missing some methods that you may have seen elsewhere, like dropLast().\nThe sequence will be awaited when it\u0026rsquo;s needed for it to produce a new value - that is, in our specific example, each new videogame newline will trigger an await. Each time a new value is emitted, our code is suspended, and the thread is off to do different work, until it either produces a new value, its done, or an error is thrown.\nAnd because this is just a normal iteration, you can use break and continue within the loop.\nfor try await videogame in videogames { if videogame.score == 10 { continue } print(\u0026#34;\\(videogame.title) (\\(videogame.year ?? 0))\u0026#34;) } In this example we are adding a continue statement to avoid printing all the games with a perfect score. Of course, you could just alternatively add a filter to videogames adding this constraint, and all videogames with a score of 10 would not get printed.\nlet videogames = url .lines .filter { $0.contains(\u0026#34;|\u0026#34;) } .map { Videogame(rawLine: $0) } .filter { $0.score != 10 } // Apply the filter here do { for try await videogame in videogames { print(\u0026#34;\\(videogame.title) (\\(videogame.year ?? 0))\u0026#34;) } } catch { } One other thing of interest is that in this particular case we are using an AsyncSequence that is delivering data over the network. It is also possible to use it with local files.\nApple has added multiple APIs that make use of AsyncSequence throughout the SDK, including but not limited to:\nFileHandle.standardInput.bytes.lines, which can be used to receive input from the command line or other sources. URLs can access both lines and bytes, when you want to read an input-as is rather than line by line, by calling URL\u0026rsquo;s resourceBytes property. URLSession has a bytes(from:) method, which you can use to download data byte by byte from the network. NotificationCenter now has APIs to await on new notifications of the specified types. I may write an article on this eventually. Using AsyncStream It\u0026rsquo;s possible that already have code that continuously delivers updates on certain events via a callback or even delegates. For example, if you are using CoreLocation to receive the user\u0026rsquo;s location in realtime, you have code that receives new location points as they become available.\nWe can streamline code like that - which delivers its results in many different places at once - using an AsyncStream. Similar to Converting closure-based code into async/await in Swift, we can convert \u0026ldquo;real-time\u0026rdquo; or \u0026ldquo;streaming\u0026rdquo; code into into a sensible async sequence.\nTo show you this, we will first create a small wrapper for the CoreLocation delegate methods that receive events. This will be a beautiful example, because we will both create a continuation for the authorization status, and then we will setup a stream for the location events.\n@MainActor class LocationUpdater: NSObject, CLLocationManagerDelegate { private(set) var authorizationStatus: CLAuthorizationStatus private let locationManager: CLLocationManager // The continuation we will use to asynchronously ask the user permission to track their location. private var permissionContinuation: CheckedContinuation\u0026lt;CLAuthorizationStatus, Never\u0026gt;? var locationHandler: ([CLLocation]) -\u0026gt; Void = { _ in } override init() { locationManager = CLLocationManager() authorizationStatus = locationManager.authorizationStatus super.init() locationManager.delegate = self locationManager.desiredAccuracy = kCLLocationAccuracyBest } func start() { locationManager.startUpdatingLocation() } func stop() { locationManager.stopUpdatingLocation() } func requestPermission() async -\u0026gt; CLAuthorizationStatus { locationManager.requestWhenInUseAuthorization() return await withCheckedContinuation { continuation in permissionContinuation = continuation } } // MARK: - Location Delegate func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { locationHandler(locations) } func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) { authorizationStatus = manager.authorizationStatus permissionContinuation?.resume(returning: authorizationStatus) } } This LocationUpdater class allow users to ask for authorization and it does so with async await, thanks to the permissionContinuation continuation. Developers can then call this code as follows:\nlet authorizationsStatus = await updater.requestPermission() This code will return the status on a single line, even though internally it jumps through two different methods to get the result. If you don\u0026rsquo;t remember or don\u0026rsquo;t know how continuations work, check out my Converting closure-based code into async/await in Swift article.\nThe var locationHandler: ([CLLocation]) -\u0026gt; Void = { _ in } property is a closure that will allow us to receive location events without having to implement more delegates on our side. We can wrap this is in a AsyncStream and start receiving location events as they happen, and receive them in a loop, and even use the sequence functions to mutate this array later on:\nfunc beginTracking() async { await requestPermission() if authorizationsStatus == .authorizedWhenInUse { for await location in locationEvents() { print(location.speed) } } } func locationEvents() -\u0026gt; AsyncStream\u0026lt;CLLocation\u0026gt; { let locations = AsyncStream(CLLocation.self) { continuation in updater.locationHandler = { locations in locations.forEach { continuation.yield($0) } } updater.start() } return locations } locationEvents is our AsyncSequence.\nOne important note here is that you can listen to the continuation to learn when it is stopped. If you have a sequence that needs to be manually stopped or you need to do some sort of cleanup after receiving events, it is useful to implement. That method is\ncontinuation.onTermination = { _ in} Unfortunately, implementing that method requires our streaming type - in this case CLLocation - to be @Sendable. Because CLLocation is not sendable, we cannot use it here. To learn about @Sendable, check out the \u0026ldquo;The Sendable Type\u0026rdquo; section of my Understanding Actors in the New Concurrency Model in Swift article. I tried to work around this by creating a wrapper type with a single property location property, but it didn\u0026rsquo;t work. At this time, I am not sure what would be the best way to use AsyncStream with CoreLocation, other than creating structs with all the same properties as CLLocation, which would take a while.\nConclusion AsyncSequence allows us to await on events as they happen in real time. Whether it is network events or other system events, AsyncSequence can help us streamline our code to be easier to read and write. AsyncStream can be used to wrap a continuous event emitter into an AsyncSequence that can receive its events in a loop, and we can filter, map, reduce, and perform more standard collection operations on them.\n","tags":["asyncstream","asyncsequence","swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"5056400bafe5a7b64bdebad31eb221ef","title":"Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model","link":"/posts/sharing-data-across-tasks-tasklocal-new-swift-concurrency-model/","content":"This article is part of my Modern Concurrency in Swift Article Series.\nTable of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Task Groups in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks Sharing Data Across Tasks with @TaskLocal with the new Swift Concurrency Model\nThroughout this tutorial series, we have explored a lot of topics related to concurrency. We have learned the most basic details of how concurrency works, and how we can do more complex work with Detached Tasks.\nOne particular topic of interest we have mentioned is the Task Tree (refer to the Structured Concurrency in Swift: Using async let article for a refresher on the details). The task tree is the result of calling multiple tasks within other tasks - unless they are detached tasks - and the tasks in the tree inherit some information from their parent tasks such as priority and context.\nJust like tasks can share contextual information, wouldn\u0026rsquo;t be it be great if they could share other data as well? Turns out there is a way to do that: The @TaskLocal property wrapper. In this article, we will talk about sharing data with this property wrapper across different tasks.\nNote: Just like global actors (excluding @MainActor), the first time I ever saw @TaskLocal being referenced was in Xcode 13 Beta 3\u0026rsquo;s release notes. It is not clear to me if the feature was there before and undocumented or if is completely new.\nIntroducing The @TaskLocal Property Wrapper TaskLocal values can be read and written to in the context of a task. The value is shared implicitly and it is accessibly by any child tasks the task create, whether they are async let or group tasks.\nUsing @TaskLocal To use this property wrapper, properties marked as @TaskLocal must be static. They can be optional or have a default value.\nTo read their values, you don\u0026rsquo;t need to do anything especial. You can attempt to use the value from anywhere, but if the value was not set by a parent async task beforehand, it will be either nil or the default value you assigned it.\nclass ViewController: UIViewController { @TaskLocal static var currentVideogame: Videogame? // ... } In the code above, we have created a TaskLocal currentVideogame property.\nIf we want to read it:\n// Outside of ViewController func expensiveVidegameOperation() async { if let vg = await ViewController.currentVideogame { print(\u0026#34;We are processing \\(vg.title)\u0026#34;) } } Now, if you try to modify currentVideogame directly, from anywhere (including ViewController itself), you will notice that the compiler won\u0026rsquo;t let us because it\u0026rsquo;s a get-only property.\nIn order to \u0026ldquo;assign\u0026rdquo; it a value, we need to \u0026ldquo;bind it\u0026rdquo;. To do this, simply access the TaskLocals projected value and you will have access to a binding method called withValue.\noverride func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. let vg = Videogame(title: \u0026#34;The Legend of Zelda: Ocarina of Time\u0026#34;, year: 1998) Self.$currentVideogame.withValue(vg) { // we cam launch some async tasks here that make use of the LocalValue } } In this sample, we are binding vg to our currentVideogame task value. All tasks spawned from here on out will have access to it for as long as they are part of the task tree.\nConsider the following example:\nclass ViewController: UIViewController { @TaskLocal static var currentVideogame: Videogame? override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. let vg = Videogame(title: \u0026#34;The Legend of Zelda: Ocarina of Time\u0026#34;, year: 1998) Self.$currentVideogame.withValue(vg) { Task { await expensiveVidegameOperation() Task { await expensiveVidegameOperation() Task.detached { await expensiveVidegameOperation() } } } } } } In the code above, we start launching some tasks after binding our Videogame. We start a Task where we call expensiveVideogameOperation. It will print We are processing The Legend of Zelda: Ocarina of Time After it awaits, we launch another Task, which is a child of the current one. Calling expensiveVideogameOperation will also print We are processing The Legend of Zelda: Ocarina of Time, because this child task has access to the same parent. Things are more interesting when we launch a detached task. When we launch the detached task, we also call expensiveVideogameOperation, but this time it prints No videogame found in the task hierarchy!. As we discussed when we talk about detached tasks, detached tasks are completely independent and they don\u0026rsquo;t really have a parent to speak of (although they can parents of other tasks, as long as they aren\u0026rsquo;t launched as detached tasks). For this reason, our detached task in the code above doesn\u0026rsquo;t have the currentVideogame.\nYou can freely bind another videogame within the detached task, launch another task, and have access to that value:\nTask.detached { await expensiveVidegameOperation() let anotherVg = Videogame(title: \u0026#34;Tales of the Abyss\u0026#34;, year: 2005) await Self.$currentVideogame.withValue(anotherVg) { await expensiveVidegameOperation() } } Note the await before we bind the value with currentVideogame. I am not sure if this is compiler magic, but you will be forced to put an await when you are inside the task. The reasoning makes sense, as TaskLocal values can potentially be accessed by multiple threads at the same time, so writing one will prevent our program from having any reace conditions.\nConclusion You may find a case in which you need to share a value to all the children in the task hierarchy. When you do, feel free to use the @TaskLocal property wrapper. Values will be shared to all the children, but any detached tasks will not have any access to them due to their nature.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"e7f56c3f7dbc8f87ccfb8c21dcfb994a","title":"@MainActor and Global Actors in Swift","link":"/posts/mainactor-and-global-actors-in-swift/","content":"This article is part of my Modern Concurrency in Swift Article Series.\nTable of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Task Groups in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks We have recently talked about actors, what they are, and how to use them. If you remember, an actor controls access to its properties, so a member doesn\u0026rsquo;t get written from different processes at the same time, avoiding corrupted data.\nIt\u0026rsquo;s all about the main thread. Whether you have been programming for Apple platforms for a while, or you are fairly new, chances are you have heard about the Main Thread. The Main Thread is in charge of running your UI Code. On Apple platforms, we are not allowed to update our UI in any other place outside the main thread. When we are running processes that are commonly asynchronous, it\u0026rsquo;s possible they will return their values on whatever thread they are running on, but we need to deliver those results the main thread. Before the modern concurrency system, we could simply call DispatchQueue.main.async and pass in a completion block. This block would run on main, making it safe to update our UI from there. Of course, this doesn\u0026rsquo;t mean that we should try to do everything on the main thread, because if the main thready is really busy, it will result in visible performance issues for your users, and if the app becomes unresponsive, the system will kill it after a defined amount of time.\nBecause the new concurrency system may jump around different threads, suspending tasks, resuming others (which may do so in different threads), and so on, we need another mechanism to update our main thread. This mechanism exists, and it is a \u0026ldquo;special\u0026rdquo; kind of actor called the @MainActor.\nIntroducing the main actor The main actor, written as @MainActor, represents your main thread. The main actor will perform all its synchronization on the main dispatch queue. This actor is \u0026ldquo;special\u0026rdquo; because it can be found all over Apple\u0026rsquo;s frameworks. It\u0026rsquo;s on SwiftUI, AppKit, UIKit, watchKit\u0026hellip; The number of places that need to run on the main thread is huge, and we aren\u0026rsquo;t even thinking of the individual UI classes within these framework that need main thread synchronization. Every single view or view controller needs to work on the main thread, and thus the need to access the @MainActor from everywhere really increases.\nTo use the main actor, you need to add the @MainActor attribute to a definition. It can be either a method or a class. When adding @MainActor to a function, the function will always execute on the main thread.\n@MainActor func fetchGames() { } In the above example, fetchGames will always execute on the main actor. This is neat, because this way, future programmers will always know that this code is supposed to run on the main thread, deducing the guesswork and helping you write more obvious code.\nIf you call a @MainActor method outside of the main thread, you need to await on it.\nawait fetchGames() Adding the @MainActor attribute to a bigger definition such as a class, will make all properties and methods be MainActor. Individual methods can choose to not be part of the main actor by adopting the nonisolated keyword.\n@MainActor class GameLibraryViewController: UIViewController { //... nonisolated var fetchVideogameTypes() -\u0026gt; [VideogameType] { ... } //... } MainActor is a really important concept, and learning to use it properly will help you adopt the modern concurrency system easier with any of Apple\u0026rsquo;s provided UI framework. Luckily, its usage is straightforward, and it has no magic or hidden behavior you need to concern yourself with.\nGlobal Actors Earlier we said that MainActor is a \u0026ldquo;special\u0026rdquo; kind of actor. And it kind of is, but it\u0026rsquo;s not the only one of its kind. Turns out that @MainActor is a type of actor called a Global Actor.\nYou know that UI Components are quite literally, all over the place. Different framework have them, and they may be found across files and different imports. To make MainActor work with the UI, there needs to be a way to create an actor that everyone can use when necessary. Global actors, like their name say, are declared globally, and every object interested in adopting them simply need to append it as an attribute, like @MainActor class MyClassThatRunsOnMainActor.\nStarting on Xcode 13, Beta 3, we can define our own global actors for our own purposes.\nNote: The Release Notes for Xcode 13, beta 3, are the the first ones that mention the existence and use of global actors. They weren\u0026rsquo;t mentioned in previous release notes and they were not mentioned in any WWDC2021 session on concurrency. I do not know if it was possible to use them in earlier betas of Xcode 13, but I\u0026rsquo;m mentioning this because I like small curiosities like this.\nCreating Global Actors Creating a Global Actor is as follows:\n@globalActor struct MediaActor { actor ActorType { } static let shared: ActorType = ActorType() } Where MediaActor is the name we assigned to it ourselves. Then, every type, method, or even module interested in adopting can do su by appending its name before the declaration, like with @MainActor.\nSuppose you have a global array that can be written to and read from multiple places at once. That global variable can be attributed with @MediaActor, and all operations upon it will run on the same thread, making the actor synchronize the state as necessary.\nIn the following example, we will create a global videogames array, and we will update it from different places.\nStart by creating a file called GlobalState where we will declare our global actor, global variable, and Videogame struct:\n// GlobalState.swift @globalActor struct MediaActor { actor ActorType { } static let shared: ActorType = ActorType() } struct Videogame { let id = UUID() let name: String let releaseYear: Int let developer: String } @MediaActor var videogames: [Videogame] = [] IMPORTANT NOTE: I do not condone the use of global variables this way and there are better ways to abstract it. Remember you are using this project to teach you about global actors, nothing more, nothing less\nSecond, we will create a view controller where everything will run in the main actor by default.\n// ViewController.swift @MainActor class ViewController: UIViewController { @MediaActor func addRandomVideogames() { let zeldaOot = Videogame(name: \u0026#34;The Legend of Zelda: Ocarina of Time\u0026#34;, releaseYear: 1998, developer: \u0026#34;Nintendo\u0026#34;) let xillia = Videogame(name: \u0026#34;Tales of Xillia\u0026#34;, releaseYear: 2013, developer: \u0026#34;Bandai Namco\u0026#34;) let legendOfHeroes = Videogame(name: \u0026#34;The Legend of Heroes: A Tear of Vermilion\u0026#34;, releaseYear: 2004, developer: \u0026#34;Nihon Falcom\u0026#34;) videogames += [zeldaOot, xillia, legendOfHeroes] } @MediaActor func removeRandomvideogame() { if let randomElement = videogames.randomElement() { videogames.removeAll { $0.id == randomElement.id } } } @MediaActor func getRandomGame() -\u0026gt; Videogame? { return videogames.randomElement() } override func viewDidLoad() { super.viewDidLoad() Task { await addRandomVideogames() await removeRandomvideogame() if let randomGame = await getRandomGame() { print(\u0026#34;Random game: \\(randomGame.name)\u0026#34;) } } } } I chose this example because the ViewController itself will run on the @MainActor, and so will all its properties and methods by default. But, if we are going to interact with the global videogames variable, we need to run these methods in MediaActor. All three possible operations of the view controller (addRandomVideogames(), removeRandomvideogame, and getRandomGame()) that need to run on the same actor as videogames, can do so, by simply marking them as MediaActor .\nWhen we need to access this @MediaActor data from the @MainActor, the methods are implicitly marked as async, so we will need to await on them.\nSo far, @MainActor is in many different places. Not only do we have accesses to it in two different files, but also via different declarations. To finish, we will create a file called Functions.swift where we will put one function that runs on @MediaActor.\n// Functions.swift @MediaActor func showAvailableGames() async { for game in videogames { print(\u0026#34;\\(game.name)\u0026#34;) } } And that\u0026rsquo;s it! You can see how simple it is to implement your own global actors.\nConclusion @MainActor is a Global Actor. All our UI code runs on the main actor. When we run code that may run on different threads but we need it on the main thread, we can mark the method as @MainActor and receive data on it.\nGlobal Actors are useful as they allow us to mark declarations in physical different files, across different declarations, and more. You can create your own global actor if you need to synchronize state across different files and types. Declaring a global actor is easy, and declarations interested in running on them can simply adopt them as @ attributes.\nHere is the sample project we wrote that makes use of our custom global actor.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"d53e4a326ff62aaea26f96f18ef481a1","title":"Understanding Actors in the New Concurrency Model in Swift","link":"/posts/understanding-actors-in-the-new-concurrency-model-in-swift/","content":"This article is part of my Modern Concurrency in Swift Article Series.\nTable of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Task Groups in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks When we are working with concurrency, the most common problem developers face are data races. Whether it is a task updating a value at the same time another task is reading it or two tasks writing a value so that it it has an invalid value, data races are probably the main pain point of concurrency. Data races are very easy create, and hard to debug. There are entire books dedicated to the problem of data races and established patterns to avoid them.\nData races happen when there\u0026rsquo;s shared mutable state. If you are only working with let variables that are never mutated, you are unlikely to encounter them. Unfortunately, even the most trivial of programs does have mutable state at some point, so racking your brain to make everything immutable is not going to yield results. In general, preferring to use let as much as possible and using value semantics (like structs) is going to help a lot when dealing with data races.\nShared mutable state requires synchronization. In the most basic - and hardest - form, you can make use of locks (a concept that guarantees mutable state will only be modified by one process at a time) and other primitives. In the past few years, many Apple Platform developers have used serial dispatch queues, which are higher level concepts for dealing with concurrency. Going this route requires you to write all that code.\nLuckily, with Swift 5.5 and the new concurrency APIs introduced at WWDC2021, Swift now has a much easier way to deal with mutable state, ensuring that only one process at a time modifies a value. Of course, this has the same implications as the other new concurrency APIs we have seen so far in this series. It iss easy to use, but may be limiting if you need more control. The good news is that the actors API is going to be enough for the vast majority of developers.\nIntroducing actors Actors provide synchronization for mutable state automatically, and they isolate their state from the rest of the program. This means that nobody can modify the shared state unless they go through the actor itself. Because the actor is isolated and you need to talk to it to modify values, the actor ensures that access to its state is mutually exclusive. Only one process will be able to modify its state at a time. Behind the scenes, actors will take care of the manual synchronization for you, and it will \u0026ldquo;queue up\u0026rdquo; processes as they attempt to modify it so they only do so one at a time.\nImplementation details actors in Swift are implemented as actor types. Similar to how you define classes, enums, and structs, you declare an actor by using the actor keyword. Actors are reference types, meaning that their behaviors are more similar to classes than structs. Which makes complete sense if you think about it, as actors are all about hiding shared mutable state that other types may need to access. The main differences between actors and classes is that actors implement all the synchronization mechanisms behind the scenes, their data is isolated from the rest of the program, and actors cannot inherit or be inherited from, although they can conform to protocols and be extended.\nThanks to the fact that actors are integrated deeply into the Swift compiler, Swift will do a lot to protect you against code that may run haywire due to its concurrency needs.\nConsider the following example:\nclass Counter { var count = 0 func increment() -\u0026gt; Int { count += 1 return count } } class ViewController: UIViewController { var tasks = [Task\u0026lt;Void, Never\u0026gt;]() override func viewDidLoad() { super.viewDidLoad() let counter = Counter() tasks += [ Task.detached { print(counter.increment()) } ] tasks += [ Task.detached { print(counter.increment()) } ] } } (Apple uses a similar example in the Protect mutable state with Swift actors WWDC2021 session)\nAlso, I originally intended to provide a sample Playground with these examples, but I couldn\u0026rsquo;t get it to work as of Xcode 13 Beta 4, so I will provide a standard iOS project instead at the end of this article)\nIn this example, you are attempting to increment the counter variable inside detached tasks. There is no locking mechanism or any synchronization that ensures that the code will work as you expect it to work. The system could increment to 0 both times, and the values that get printed can be drastically different on each turn.\nWe can fix it and ensure that the output is always \u0026ldquo;1, 2\u0026rdquo; by making Counter an actor instead of a class.\nactor Counter { var count = 0 func increment() -\u0026gt; Int { count += 1 return count } } Simply making this change will not be enough. Trying to compile and run it will give you this error in both places where we try to print:\nExpression is \u0026#39;async\u0026#39; but is not marked with \u0026#39;await\u0026#39; This is beautiful, and it really shows you how deeply concurrency is implemented at the compiler level to save you from writing buggy concurrent code. It can save you from having to spend hours, days, months, or even years, learning to write concurrent code safely yourself. I absolutely love the compiler integration, because it also shows you that all the concepts we have explored throughout this series converge. The compiler is helping us make sense of everything we learned so far.\nTo fix that error, simply add await when you call increment().\nprint(await counter.increment()) All of an actor\u0026rsquo;s public interface are automatic made async for its consumers. This allows us to safely interact with actors, because using the await keyword will suspend execution until the code is notified that it can go into the actor next and do its job.\n(This is a good point to stop and think if you actually understand async/await, which are the most basic building blocks for the new concurrency system in Swift. If you think you need a refresher, you can read the Understanding async/await in Swift article of this series.)\nDo note that this has some implications when attempting to access the properties (in this case, count) directly. First, you can do read-only access, but it has to be done through asynchronous contexts. This therefore, will not work:\nprint(counter.count) It will make the compiler yell at you with:\nActor-isolated property \u0026#39;count\u0026#39; can only be referenced from inside the actor This is because, just like methods, properties expose their getters as async.\nasync { let count = await counter.count print(\u0026#34;count is \\(count)\u0026#34;) } Finally, remember when we said nobody can modify the shared state in an actor without going through the actor itself? This means that the actor has to expose methods that would modify its values. You cannot modify properties of an actor directly.\ncounter.count = 3 Actor-isolated property \u0026#39;count\u0026#39; can only be mutated from inside the actor Inside the actor The actor will expose asynchronous code to external callers, helpfully marking everything relevant as async. But within the actor itself, all calls are synchronous. This will help you write more natural code within the actor as you won\u0026rsquo;t have to worry about weird execution orders.\nYou can observe this yourself, add the following method to Counter.\nfunc reset() { while count \u0026gt; 0 { count -= 1 } print(\u0026#34;Done resetting\u0026#34;) } Then, create a new function, foo, and typing reset within it. You will see that the autocomplete suggestions will suggest you autofill with reset().\nWhereas, if you call reset externally, you will see that the reset() method has async on its signature.\n.\nYou can see that anything called within the actor is synchronous (as you can tell due to the lack of the async keyword), but calling the very same methods externally are async. Synchronous code on the actor always runs to completion without being interrupted. You will notice you cannot await on the actor\u0026rsquo;s properties or methods, although nothing prevents the actor from calling async methods from other actors or other places.\nActor reentrancy While actors isolate their own state from others, they rarely work alone. They are likely to interact with other actors or with the rest of your codebase in general.\nThis can cause unexpected behavior. Consider the following example:\nenum ImageDownloadError: Error { case badImage } func downloadImage(url: URL) async throws -\u0026gt; UIImage { let imageRequest = URLRequest(url: url) let (data, imageResponse) = try await URLSession.shared.data(for: imageRequest) guard let image = UIImage(data: data), (imageResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.badImage } return image } actor ImageDownloader { private var cache: [URL: UIImage] = [:] func image(from url: URL) async throws -\u0026gt; UIImage { if let image = cache[url] { return image } let image = try await downloadImage(url: url) cache[url] = image return image } private func downloadImage(url: URL) async throws -\u0026gt; UIImage { let imageRequest = URLRequest(url: url) let (data, imageResponse) = try await URLSession.shared.data(for: imageRequest) guard let image = UIImage(data: data), (imageResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.badImage } return image } } (This code is similar to Apple\u0026rsquo;s ImageDownloader code from their Protect mutable state with Swift actors WWDC2021 session, but I have created a sample you can run.\nWe have an image downloader that caches images so as to not download them again. The if let will check if an image is cached and return it if possible. Otherwise the code will download an image, cache it after the download, and return the newly downloaded image. But what happens if we enter here twice?\nConsider the following code that uses the ImageDownloader actor from above:\noverride func viewDidLoad() { super.viewDidLoad() Task.detached { await self.downloadImages() } } //... func downloadImages() async { let downloader = ImageDownloader() let imageURL = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part3/3.png\u0026#34;)! async let downloadedImage = downloader.image(from: imageURL) async let sameDownloadedImage = downloader.image(from: imageURL) var images = [UIImage?]() images += [try? await downloadedImage] images += [try? await sameDownloadedImage] } Important Note: As of Xcode 13 Beta 4 (and all the way down to Beta 3), there is a bug that causes your code to deadlock when entering an actor twice from the same Task via async let. Apple is aware of this issue, and it will hopefully be fixed in a later beta. Until this bug is fixed, the workaround is to use Task.detached instead of just Task when using more than one async let binding at the same time. By the time a later Beta comes out, the GM, or the final release comes out, the bug may be fixed. Please keep that in mind as ultimately, normal Tasks and Task.detached calls have different uses.\nWe are entering the actor via two different async let calls. The first call (downloadedImage) will enter the actor and it will execute until it finds the await call on downloadImages. It will suspend, and the second call, sameDownloadedImage will begin executing. Note that downloadedImage reached the await, and since it suspended, it hasn\u0026rsquo;t had any time to download the image yet. And because the image is not in the cache, sameDownloadedImage will also download the image instead of retrieving it from memory. If you are really unlucky, the server may have updated the image behind the same URL, so downloadedImage and sameDownloadedImage may download different things!\nThe problem is we are assuming the program state after the await call. It\u0026rsquo;s like we are telling the program \u0026ldquo;Hey, you will download the image, cache it, and anyone else who access it, will grab the cached version\u0026rdquo;. But in reality, it\u0026rsquo;s impossible to make this guarantee with this code, because there may be different calls attempting to access the actor at the same time, and thus we have this bug that hits the network twice for the same image.\nTo work around this, we can make our actor keep the state of each download, and access that state first-thing before our actor tries to download an image:\nactor ImageDownloader { private enum ImageStatus { case downloading(_ task: Task\u0026lt;UIImage, Error\u0026gt;) case downloaded(_ image: UIImage) } private var cache: [URL: ImageStatus] = [:] func image(from url: URL) async throws -\u0026gt; UIImage { if let imageStatus = cache[url] { switch imageStatus { case .downloading(let task): return try await task.value case .downloaded(let image): return image } } let task = Task { try await downloadImage(url: url) } cache[url] = .downloading(task) do { let image = try await task.value cache[url] = .downloaded(image) return image } catch { // If an error occurs, we will evict the URL from the cache // and rethrow the original error. cache.removeValue(forKey: url) throw error } } private func downloadImage(url: URL) async throws -\u0026gt; UIImage { let imageRequest = URLRequest(url: url) let (data, imageResponse) = try await URLSession.shared.data(for: imageRequest) guard let image = UIImage(data: data), (imageResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.badImage } return image } } This code is similar to the code provided by Apple in the Protect mutable state with Swift actors WWDC2021 session.\nThis looks like a mouthful, but it\u0026rsquo;s very straightforward (and straightforwardness is the power of the new concurrency APIs!). We start by declaring an enum that will hold the state for the current URL. When a URL is downloaded for the first time, we will add this URL to the cache with a .downloading status. If any other call is made to the actor with the same URL at the same time, it will see the image is in the cache, so rather than downloading the image again, it will directly await on it. Calls made in a farther future will likely see an already downloaded image, so they will return immediately. When the image finishes downloading for the first (and) last time. the image is cached with a .downloaded status.\nActor reentrancy prevents deadlocks and guarantees forward progress, but it is necessary that you check your assumptions so as to prevent any other bugs that are not necessarily related to concurrency, such as downloading the same image more than once. Here\u0026rsquo;s a few points to make sure you play with the actor reentrancy concept well:\nMake mutations in synchronous code. You can see that we mutate our cache in the same task, and we are not attempting to update it anywhere else. Know that state can change at any point after you hit an await. You may need to manually check for some state to determine how it has changed so you can respond to it if necessary. Actor isolation Actors are all about isolation. Their main purpose is to isolate their state from others, so they can manage access to their own properties, ensuring that multiple writes are performed at the same time, which could leave your program in an unexpected state.\nImmutable properties can be accessed at any time.\nactor DollMaker { let id: Int var dolls: [Doll] = [] init(id: Int) { self.id = id } } extension DollMaker: Equatable { static func ==(_ lhs: DollMaker, rhs: DollMaker) -\u0026gt; Bool { lhs.id == rhs.id } } In the code above, the == operator compares two types, and it is a static method. static means that this method is \u0026ldquo;outside\u0026rdquo; of the actor (there\u0026rsquo;s no self instance). Combine that with the fact we only access immutable state within the method, and the compiler knows this is a safe thing to do.\nextension DollMaker: Hashable { func hash(into hasher: inout Hasher) { hasher.combine(id) } } On the other hand, this is getting into murky waters. While we also only reference the id field, this method is an instance method. It is supposed to be async to be isolated. Luckily, in this case, we can explicitly mark the method as nonisolated to let the compiler know this is not isolated. The compiler will treat this method as being \u0026ldquo;outside\u0026rdquo; the actor, and move on, as long as you only access immutable properties inside of it. If the hasher was using the dolls property instead of id, this wouldn\u0026rsquo;t work as dolls is mutable.\nThe Sendable Type The concurrency model also introduces Sendable types. Sendable types are those that can be shared concurrently safely. The following are some examples of types that are Sendable:\nValue types (such as structs) Actor types Classes can be Sendable but only if they are immutable or if they provide their own synchronization within themselves. Sendable classes are exceptional.\nIt is recommended that your concurrent code communicates using Sendable types. At some point, Swift will be able to check, at compile time, if you are sharing non Sendable types across functions, but this doesn\u0026rsquo;t appear to be the case as of Xcode 13, Beta 4.\nThe Sendable Protocol You probably guessed it, but the way we make types Sendable is by making our types conform to the Sendable protocol. Just by specifying the conformance, the Swift compiler will do a lot of work for us.\nConsider the following example:\nstruct Videogame: Sendable { var title: String } struct VideogameMaker: Sendable { var name: String var games: [Videogame] } This will compile without an issue, because VideogameMaker is sendable, and so is Videogame.\nFor structs, you can avoid conforming to Sendable, and it will still work:\nstruct Videogame { var title: String } struct VideogameMaker: Sendable { var name: String var games: [Videogame] } But this is not the case with classes.\nclass Videogame { var title: String init(title: String) { self.title = title } } struct VideogameMaker: Sendable { var name: String var games: [Videogame] } You will get an error like this:\nStored property \u0026#39;games\u0026#39; of \u0026#39;Sendable\u0026#39;-conforming struct \u0026#39;VideogameMaker\u0026#39; has non-sendable type \u0026#39;[Videogame]\u0026#39; Sendable and generics A Generic type can be Sendable only if its all properties are Sendable.\nstruct Pair\u0026lt;T, U\u0026gt; { var first: T var second: T } extension Pair: Sendable where T: Sendable, U: Sendable {} Sendable functions For functions that can be passed across actors, they can be made marked as @Sendable.\nWhen it comes to closures, marking them as @Sendable impose some restrictions. They cannot capture mutable variables from their surrounding scope, everything they capture must be Sendable, and finally, they cannot be both asynchronous and actor isolated.\nConclusion A sample project for the image download can be downloaded from here.\nIn this article we explored what actors are and how to use them. We learned that an actor isolates its own state and all write access to its properties must be done through the actor itself. By isolating their own state, actors provide concurrency safety.\nWe also learned about Sendable types and how they are crucial to the new concurrency system in Swift. Sendable types help provide compile-time checks to write concurrent code. As they provide static checking, it\u0026rsquo;s very hard to write incorrect code that breaks the concurrency model or introduces concurrency bugs.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"1b17647b0d05f3ad1e59988c469abd2d","title":"Unstructured Concurrency With Detached Tasks in Swift","link":"/posts/unstructured-concurrency-with-detached-tasks-in-swift/","content":"This article is part of my Modern Concurrency in Swift Article Series.\nThis article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.\nTable of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Task Groups in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks Understanding async tasks is a requirement to read this article. If you don\u0026rsquo;t understand async tasks, you can read the Introduction to Unstructured Concurrency in Swift article from this Article Series\nThroughout this article series, we have explored what async/await is. We have also gotten our feet wet by exploring structured concurrency with async let and Group Tasks. We have explored that sometimes, structured concurrency, while nice, is not going to cover all our cases, so we mentioned the existence of unstructured concurrency and we have explored how to use Task {} blocks to launch unstructured tasks.\nIn this article, we will explore the final method to implement unstructured concurrency by using the most flexible method provided to us by Swift 5.5: Detached tasks.\nIntroducing Detached Tasks Out of all the concurrency options we have explored in the new async/await system, detached tasks offer the most flexibility. They can be launched from anywhere, their lifetime is not scoped, you can cancel them manually (through a Task.Handle) and await them, and they are the one type of tasks that don\u0026rsquo;t inherit anything from the parent tasks. Not even the priority. They are independent from their context.\nDetached tasks are useful when you need to perform a task that is completely independent of the parent task. One example is downloading images from the network, and later caching them to disk (this example is used by Apple in the WWDC2021 Explore Structured Concurrency in Swift talk). The caching operation can happen in a detached task because once we have the image, there is no reason that a cancellation on the download task should cause the caching operation to be cancelled as well.\nfunc storeImageInDisk(image: UIImage) async { guard let imageData = image.pngData(), let cachesUrl = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first else { return } let imageUrl = cachesUrl.appendingPathComponent(UUID().uuidString) try? imageData.write(to: imageUrl) } func downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { let image = try await downloadImage(imageNumber: imageNumber) Task.detached(priority: .background) { await storeImageInDisk(image: image) } let metadata = try await downloadMetadata(for: imageNumber) return DetailedImage(image: image, metadata: metadata) } We have created a storeImageInDisk task. Then we call this method within a Task.detached in downloadImageAndMetadata. Right after the image is downloaded, we will try to cache it.\nIt\u0026rsquo;s really simple, and once you understand Task {}, you can understand Task.detached {}. When launching a detached task, you can specify the priority. In our case, we used background, because it\u0026rsquo;s not a user task that needs to finish with high priority. .userInitiated would mean the user cares about that task, and it needs to have high priority.\nBecause these tasks are unstructured, Task.detached will return a Task handle we can use to cancel the task at any time. Note that, while Task.detached is independent of the task that launched it, all other tasks started within it will still depend on Task.detached, so if you cancel a Task.detached task, all of its children will be marked as cancelled, save for a case in which you run another Task.detached within Task.detached, and so on.\nSummary Task.detached is not too hard to understand once you understand Task {}. They behave almost the same way. The main differences are Task.detached will not inherit anything from the parent context. You can cancel both manually. They are great for running non-dependent tasks at any given time.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"9ba3f59d8cbee19c210b0956c0bfacda","title":"Introduction to Unstructured Concurrency in Swift","link":"/posts/introduction-to-unstructured-concurrency-in-swift/","content":"This article is part of my Modern Concurrency in Swift Article Series.\nThis article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.\nTable of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Task Groups in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks Understanding Structured Concurrency in Swift is a pre-requisite to read this article. If you aren\u0026rsquo;t familiar with that concept, feel free to read the Beginning Concurrency in Swift: Structured Concurrency and async-let and Structured Concurrency With Group Tasks in Swift articles of this series.\nSo far we have focused in exploring Structured Concurrency with the new APIs introduced in Swift 5.5. Structured Concurrency is great to keep a linear flow in our programs, keeping a hierarchy of tasks that is easy to follow. Structured Concurrency helps a lot with keeping task cancellation on track and making error handling as obvious as it would be with no concurrency. Structured concurrency is a great tool to execute various tasks at once, without making our code more difficult to read.\nIntroducing unstructured concurrency. Despite the fact that structured concurrency is really useful, there will be times (although hopefully a minority) in which your tasks will have no structured pattern of any kind at all. For these cases, we can leverage unstructured concurrency which will give us more control over the asks, in exchange for some simplicity. The great news is that Swift 5.5 gives us the tools to do this without having to sacrifice a lot of the simplicity. One example of this is giving users the ability to download images, but also giving them the option to cancel the downloads.\nThere are some situations in which you will feel the need to use unstructured concurrency:\nLaunching tasks from non-async contexts. They can outlive their scopes. Detached tasks, for tasks that won\u0026rsquo;t inherit any information about their parent task. In this article, we will focus on the former.\nLaunching tasks from non-async contexts We have actually done this before, and this time we will explain Task {} blocks in depth. Recall when we began talking about async/await, we mentioned that when you need to await on a task, you need to be within an async context. If you are inside a function that has async in the signature, then you are fine, and you can await without doing anything special.\nThe problem is that Apple\u0026rsquo;s SDKs were not designed to support concurrency from the beginning. Take UIKit as an example. None of the methods that are part of the lifecycle of a view controller are marked as async, such as viewDidAppear. If you need to perform concurrency or simply await on an async task, you can\u0026rsquo;t, unless you use a Task block.\nWe actually did this when we talked about Understanding async/await in Swift. In case you didn\u0026rsquo;t read the original article, by the end of it we ended up with code like this:\n// MARK: - Definitions struct ImageMetadata: Codable { let name: String let firstAppearance: String let year: Int } struct DetailedImage { let image: UIImage let metadata: ImageMetadata } enum ImageDownloadError: Error { case badImage case invalidMetadata } func downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { let image = try await downloadImage(imageNumber: imageNumber) let metadata = try await downloadMetadata(for: imageNumber) return DetailedImage(image: image, metadata: metadata) } func downloadImage(imageNumber: Int) async throws -\u0026gt; UIImage { let imageUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).png\u0026#34;)! let imageRequest = URLRequest(url: imageUrl) let (data, imageResponse) = try await URLSession.shared.data(for: imageRequest) guard let image = UIImage(data: data), (imageResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.badImage } return image } func downloadMetadata(for id: Int) async throws -\u0026gt; ImageMetadata { let metadataUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(id).json\u0026#34;)! let metadataRequest = URLRequest(url: metadataUrl) let (data, metadataResponse) = try await URLSession.shared.data(for: metadataRequest) guard (metadataResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.invalidMetadata } return try JSONDecoder().decode(ImageMetadata.self, from: data) } //... override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) Task { if let imageDetail = try? await downloadImageAndMetadata(imageNumber: 1) { self.imageView.image = imageDetail.image self.metadata.text = \u0026#34;\\(imageDetail.metadata.name) (\\(imageDetail.metadata.firstAppearance) - \\(imageDetail.metadata.year))\u0026#34; } } } In the code above, we have a few methods that can be awaited. We want to call them from viewDidAppear, but because viewDidAppear does not have async as part of the function signature, we can\u0026rsquo;t do so directly. Instead, we need to create an async context using async, and we can await inside of it.\nThe implications of doing this are interesting. First, Task {} actually creates an explicit task. Second, because this launches a new task, anything underneath the Task {} block will continue executing alongside anything inside the Task {} block.\nclass ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. } override func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) async { if let imageDetail = try? await downloadImageAndMetadata(imageNumber: 1) { print(\u0026#34;Image downloaded\u0026#34;) } } print(\u0026#34;Continue execution alongside the async block\u0026#34;) } } If you run this, you will notice that the output is:\nContinue execution alongside the async block Image downloaded Executing linear code is much faster than downloading anything from the network, so you are pretty much guaranteed to receive this output every time you run it. It follows to say that, if you have multiple Task {} blocks, you are launching an async task on each.\nFinally (and this is the most interesting part), using Task this way will actually return you a handle of type Task\u0026lt;T, Error\u0026gt;. You can later store this handle somewhere and use it to explicitly cancel the task explicitly, await its result, and more.\nThis is where the \u0026ldquo;unstructured\u0026rdquo; part comes into play. We can begin a task somewhere, and then we can cancel it from a completely unrelated place.\nFor example, we can begin the download from the tap of a button:\n// You can get the full code at the end of the article. class ViewController: UIViewController { // ... var downloadAndShowTask: Task\u0026lt;Void, Never\u0026gt;? { didSet { if downloadAndShowTask == nil { triggerButton.setTitle(\u0026#34;Download\u0026#34;, for: .normal) } else { triggerButton.setTitle(\u0026#34;Cancel\u0026#34;, for: .normal) } } } func downloadAndShowRandomImage() { let imageNumber = Int.random(in: 1...3) downloadAndShowTask = async { do { let imageMetadata = try await downloadImageAndMetadata(imageNumber: imageNumber) imageView.image = imageMetadata.image let metadata = imageMetadata.metadata metadataLabel.text = \u0026#34;\\(metadata.name) (\\(metadata.firstAppearance) - \\(metadata.year))\u0026#34; } catch { showErrorAlert(for: error) } downloadAndShowTask = nil } } // Inside ViewController @IBAction func triggerButtonTouchUpInside(_ sender: Any) { if downloadTask == nil { // If we have no task going, we have now running task. Therefore, download. Task { await downloadAndShowRandomImage() } } else { // We have a task, let\u0026#39;s cancel it. cancelDownload() } } // ... } And cancel the download when the user wishes to:\nfunc cancelDownload() { downloadAndShowTask?.cancel() } The full program contains a triggerButton whose label changes when downloadAndShowTask\u0026rsquo;s value changes. When it is nil, there\u0026rsquo;s no task going on, so we will use the button to download an image. Otherwise, we will use the button to cancel the action.\ndownloadAndShowTask is of type Task\u0026lt;Void, Never\u0026gt; because the task itself doesn\u0026rsquo;t return anything and it doesn\u0026rsquo;t throw an error. Our button will download the image and set the labels.\nIf you needed to download the images but not process them directly, you may want to define your tasks in such way that they return specific values.\nThe following example is more involved, but it shows you the flexibility you have with Task {} unstructured tasks.\nFirst, we will add @MainActor to the declaration of the view controller. It\u0026rsquo;s possible that other threads other than the main one will want to access the values of the view controller.\n@MainActor class ViewController: UIViewController //... Next, we will change downloadAndShowTask to downloadTask and we will change the signature to Task\u0026lt;DetailedImage, Error\u0026gt;. This will allow us to await on the DetailedImage, or to throw an error from within the task if necessary.\nvar downloadTask: Task\u0026lt;DetailedImage, Error\u0026gt;? { didSet { if downloadTask == nil { triggerButton.setTitle(\u0026#34;Download\u0026#34;, for: .normal) } else { triggerButton.setTitle(\u0026#34;Cancel\u0026#34;, for: .normal) } } } Next, we will create a new method, beginDownloadingRandomImage, which will start an image download and store it in the downloadTask handle. We will create the code that updates the outlets accordingly while we are on it.\nfunc beginDownloadingRandomImage() { let imageNumber = Int.random(in: 1...3) downloadTask = Task { return try await downloadImageAndMetadata(imageNumber: imageNumber) } } func showImageInfo(imageMetadata: DetailedImage) { imageView.image = imageMetadata.image let metadata = imageMetadata.metadata metadataLabel.text = \u0026#34;\\(metadata.name) (\\(metadata.firstAppearance) - \\(metadata.year))\u0026#34; } We will update the implementation of downloadAndShowRandomImage so it makes use of the two new functions.\nfunc downloadAndShowRandomImage() async { beginDownloadingRandomImage() do { if let image = try await downloadTask?.value { showImageInfo(imageMetadata: image) } } catch { showErrorAlert(for: error) } downloadTask = nil } This method will now call beginDownloadingImage, which will assign a value to downloadTask within. Then, we call downloadTask?.value. .value will return us the image when it\u0026rsquo;s done downloading, which is why it\u0026rsquo;s awaited.\ncancelDownload is the same as always. We can cancel (and start) the download at any point.\nTasks created this way also inherit the priority, local values, and the actor. They can outlive their scope and therefore give you more control over their lifetimes.\nSummary We have explored what async actually does. We have used it to create an explicit task that we can later cancel manually and explicitly. We can use Task {} blocks to work with concurrency that doesn\u0026rsquo;t have any kind of structure. This is useful when we want to have more control over the tasks. Being able to cancel tasks when deemed necessary can help improve the user experience, especially if very long-running tasks are involved. These tasks can outlive the original scope they are defined in, enforcing the idea that they create unstructured concurrency.\nThere is a a small project with the last pieces of code that you can explore to better understand Task {}. The program has a Download button that cancels into a Cancel button when a download is in progress. Rapidly tapping the button will show you an alert that says \u0026ldquo;cancelled\u0026rdquo; as you cancelled the task explicitly without giving a change to the image to download.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"80e80e3a5e0cf40e79234c77eba3f581","title":"Structured Concurrency With Task Groups in Swift","link":"/posts/structured-concurrency-with-group-tasks-in-swift/","content":"This article is part of my Modern Concurrency in Swift Article Series.\nThis article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.\nTable of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Task Groups in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Understanding Structured Concurrency and async let is a pre-requisite to read this article. If you aren\u0026rsquo;t familiar with that concept, feel free to read the third part of this article series: Beginning Concurrency in Swift: Structured Concurrency and async-let.\nTask Groups are the second form of structured concurrency in Swift. When we explored async let, we noticed one particular restriction: We cannot run a variable number of tasks at the same time, because when we try to do so, say in a loop, we need to await the results. This won\u0026rsquo;t allow us to, for example, download multiple pictures at once, because we are restricted to waiting on each download.\nTo perform a variable number of tasks, Swift gives us Task Groups.\nTask Groups Task Groups offer more flexibility than async let without giving up the simplicity of structured concurrency.\nA Task Group is a form of structured concurrency designed to provide a dynamic amount of concurrency. With it, we can launch multiple tasks, launch them in a group, and have them execute all at the same time.\nWe have two ways to launch task groups:\nBy calling withThrowingTaskGroup By calling withTaskGroup Like we have seen multiple times through this article series, you have a variant for tasks that may throw errors and one for tasks that won\u0026rsquo;t. Tasks added to a group cannot outlive the scope of the block in which the group is defined. When child tasks are added to a group, they begin executing immediately and in any order, so take care to design your code in such a way that there\u0026rsquo;s no dependencies in your child tasks. When the group goes out of scope, the completion of all the tasks within it will be implicitly awaited.\nStructured concurrency allow us to create async let tasks within groups, and the other way around too - to launch task groups within async let calls.\nIf you try to modify a variable within a task group, like this:\nfunc downloadMultipleImagesWithMetadata(images: Int...) async throws -\u0026gt; [DetailedImage]{ var imagesMetadata: [DetailedImage] = [] try await withThrowingTaskGroup(of: Void.self, body: { group in for image in images { group.async { async let image = downloadImageAndMetadata(imageNumber: image) imagesMetadata += [try await image] } } }) return imagesMetadata } This code is a variant of the one written in Beginning Concurrency in Swift: Structured Concurrency and async-let. This example is based on the Explore structured concurrency in Swift WWDC2021 talk.\nThe compiler will notice that imagesMetadata can potentially be accessed unsafely by multiple tasks at the same time. This would lead to data corruption as multiple variables try to write to it at the same time. Luckily, thanks to the fact that the new concurrency APIs are deeply integrated into Swift itself, the compiler can do some checks statically and prevent you from introducing such data races.\nIf you try to compile that, the compiler will yield the following error:\nMutation of captured var \u0026lsquo;imagesMetadata\u0026rsquo; in concurrently-executing code\nSo, how exactly can Swift perform these checks?\nThe @Sendable closure type To introduce data race safety, Swift implements the concept of a @Sendable closure.\nWhenever you create a Task, the body is a @Sendable closure, and this closure has the following properties:\nCannot capture mutable variables. You should only capture value types, actors, classes, or other objects that implement their own synchronization. We will explore actors in a future article. With this knowledge in mind, we can fix our Task Group above. When you create a Task Group with either withThrowingTaskGroup or withTaskGroup, the task group takes as a parameter the return type your concurrent tasks will create.\nfunc downloadMultipleImagesWithMetadata(images: Int...) async throws -\u0026gt; [DetailedImage]{ try await withThrowingTaskGroup(of: DetailedImage.self, body: { group in for image in images { group.async { async let image = downloadImageAndMetadata(imageNumber: image) return try await image } } }) } The implementation of our method is not complete yet, but going step by step, it has received a few important modifications:\nThe of parameter of withThrowingTaskGroup now specifies that it takes DetailedImages. Instead of appending to an array, group.async will now return an awaited DetailedImage on each run of the loop. Essentially, we are \u0026ldquo;filling the group\u0026rdquo; with DetailedImages that we will eventually return - unless an error occurs. If an error occurs, the child tasks will be cancelled, and the tasks will need to be stopped. Recall from Beginning Concurrency in Swift: Structured Concurrency and async-let that you are responsible for keeping cancellation in mind when designing your code, but luckily it\u0026rsquo;s a one-line call in the case of structured concurrency.\nOur group variable is of type ThrowingTaskGroup\u0026lt;DetailedImage, Error\u0026gt;. And surprise, this is a collection! You can iterate over it or apply functional programming to it such as filter, map, and reduce.\nfunc downloadMultipleImagesWithMetadata(images: Int...) async throws -\u0026gt; [DetailedImage]{ var imagesMetadata: [DetailedImage] = [] try await withThrowingTaskGroup(of: DetailedImage.self, body: { group in for image in images { group.async { async let image = downloadImageAndMetadata(imageNumber: image) return try await image } } for try await image in group { imagesMetadata += [image] } }) return imagesMetadata } The for try await part may throw you for a loop (no pun intended). But alongside all the new concurrency APIs introduced in Swift 5.5, we have a new AsyncSequence type. This protocol is implemented by types that will receive values over time. In our downloadMultipleImagesWithMetadata function, we use group.async to launch a dynamic number of DetailedImage downloads. As the downloads end, they will be delivered to our for in loop, one image at a time, making it safe to modify variables within it, and more.\nNote that the await in the for loop behaves the same way as any other await call. Execution will suspend when reaching that point, and when a new image is delivered, execution will continue. This is important to keep in mind because if you have anything underneath the for-in loop, it will not be executed until all the elements in the group have been sent through it. If you want to download three images, the three images may download concurrently at the same time, but the for loop will only give you one at a time. If you download a considerable number of images, they will all have to be downloaded before executing anything underneath for-in. This also means that shall an error be thrown, your for-in will stop executing (or it may not even execute if the first download fails).\nWe will explore AsyncSequence in depth in a future article.\nWhen we are dealing with Task Groups, we actually have a bit more flexibility. We can for example launch a task asynchronously with a given priority:\ngroup.async(priority: .userInitiated) { //... } Where priority is of type Task.Priority. This gives you more flexible control when dealing with cancellation, as it even has a asyncUnlessCancelled method that can optionally take in the priority as well.\ngroup.asyncUnlessCancelled(priority: nil) { //... } Finally, you can also call cancellAll() in a group. Cancelation will propagate down the tree.\nNote that there\u0026rsquo;s a tiny difference when compared to async let. When the group goes out of scope through a normal exit, cancellation of the tasks is not implicit. They will just be awaited instead. This is to give your other tasks time to finish and to express the Fork-Join Model, which is essentially \u0026ldquo;divide and conquer\u0026rdquo; - in our case, downloading multiple images in as many child tasks as possible.\nSummary In this article, you learned the other way to do structured concurrency in Swift by using Task Groups. Task groups allow us to execute dynamic concurrency, such as when needing to download multiple images in a loop. We briefly mentioned AsyncSequence and how it\u0026rsquo;s used with Task Groups to deliver results over time.\nAs is tradition with this series, here\u0026rsquo;s a small example project you can download. While the UI is the same one as the first few projects, you will have a compilable version of downloadMultipleImagesWithMetadata that you can play with and experiment.\nWith this article, we have finished exploring the two methods to do structured concurrency in Swift:\nWhen you need basic concurrency support, use async let. When you have a dynamic amount of concurrent tasks to perform, use a Task Group. In the next article, we will begin exploring unstructured concurrency. It sounds intimidating, but Swift makes it possible to work with as easily as with structured concurrency.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"f8e4e8ae82fae82c8df949e41c26798e","title":"Structured Concurrency in Swift: Using async let","link":"/posts/structured-concurrency-in-swift-using-async-let/","content":"This article is part of my Modern Concurrency in Swift article series.\nThis article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.\nTable of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Task Groups in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks Understanding async/await is a pre-requisite to read this article. If you aren\u0026rsquo;t familiar with that concept, feel free to read the first part of this article series: Understanding async/await in Swift.\nasync/await are the most important concepts when it comes to the new concurrency system in Swift. Understanding async/await will open you the doors to perform multiple tasks in parallel with a clean syntax and straightforward code.\nThere are actually multiple ways to do this, but the way Apple has given us at WWDC2021 with Swift 5.5 is the safest one to use, and unless you have highly specific needs, probably the one you will use almost exclusively.\nIntroducing Structured Concurrency. In previous articles, we have discussed how callback-based code can be messy to manage when used in concurrent contexts. For that reason, Apple gave us async/await, which is a set of keywords that can help us write concurrent code while keeping a linear flow in our code. This code can be read from top to bottom. However, in Understanding async/await in Swift, we noted that by just using async/await it doesn\u0026rsquo;t mean that we will perform more than one task at once (the tasks we call may do so internally, though). We will now begin executing some code in parallel, and we will start with the concept of Structured Concurrency.\nThe ideas behind structured concurrency are based on the same ideas as structured programming. We write structured code the vast majority of the time, so you never think about it. Structured code can be read from top to bottom, following a linear flow, in a way that outputs are predictable and code is executed in the exact given order. When using variables, they have a well-defined lifetime within the block they are declared in. In callback-based concurrency, you fire off tasks in different threads or contexts as your main thread keeps executing, creating the potential to alter the output of your program every time it\u0026rsquo;s run. If you are writing Objective-C, you need to treat your variables as __block in order to modify them within a block. This creates a labyrinth of code where everything can happen in any order in order to give you the result you want.\nNow, consider the following functions:\nfunc downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { let image = try await downloadImage(imageNumber: imageNumber) let metadata = try await downloadMetadata(for: imageNumber) return DetailedImage(image: image, metadata: metadata) } func downloadImage(imageNumber: Int) async throws -\u0026gt; UIImage { let imageUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).png\u0026#34;)! let imageRequest = URLRequest(url: imageUrl) let (data, imageResponse) = try await URLSession.shared.data(for: imageRequest) guard let image = UIImage(data: data), (imageResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.badImage } return image } func downloadMetadata(for id: Int) async throws -\u0026gt; ImageMetadata { let metadataUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(id).json\u0026#34;)! let metadataRequest = URLRequest(url: metadataUrl) let (data, metadataResponse) = try await URLSession.shared.data(for: metadataRequest) guard (metadataResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.invalidMetadata } return try JSONDecoder().decode(ImageMetadata.self, from: data) } //... struct ImageMetadata: Codable { let name: String let firstAppearance: String let year: Int } struct DetailedImage { let image: UIImage let metadata: ImageMetadata } enum ImageDownloadError: Error { case badImage case invalidMetadata } downloadImageAndMetadata is a function that will download an image alongside its metadata, all wrapped in a DetailedImage object. To perform the download, it will call a downloadImage function which will download the image itself, and a downloadMetadata function which will download the metadata. Let\u0026rsquo;s inspect downloadImageAndMetadata a little bit deeper.\nfunc downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { let image = try await downloadImage(imageNumber: imageNumber) let metadata = try await downloadMetadata(for: imageNumber) return DetailedImage(image: image, metadata: metadata) } The downloads take place sequentially, which is exactly what you want most of the time. The function will download the image first, and the metadata later, one at a time. This is great in many cases, but there are times when the tasks don\u0026rsquo;t have any dependencies with each other and it\u0026rsquo;s therefore possible to execute them concurrently.\nIn this example, the image download and metadata download are two independent tasks, so we can give the function a little push to download both at the same time and therefore finish earlier.\nBefore we move on, think about how you would do this with closure-based code. First, you would need to launch two URLSession data tasks, each with its own completion handler. But then what? How will the tasks coordinate the completion for this task? What happens if the image downloads first? What happens if the metadata finishes first? How are we gonna \u0026ldquo;lock\u0026rdquo; and guarantee access and that the final completion handler is called?\nIn truth, doing this task with pure closure-based code (and even with delegate-based code), it becomes pretty messy real quick. And we are just talking about a measly two tasks at once!\nIn Swift, we have two ways to work with structured concurrency:\nasync let Task groups This article will be limited to async let, but we will cover Task groups in a future article.\nUnderstanding tasks Tasks are the underlying mechanism in which Swift executes your code in parallel. Each task provides a new async context in which it can execute concurrently, alongside other tasks. They will run in parallel automatically as long as it is safe and efficient to do so.\nOur downloadImageAndMetadata function does not actually create any tasks. Both downloads are awaited and this is why they don\u0026rsquo;t run in parallel. We will solve this.\nThese new concurrency features are deeply integrated into Swift, so as you go along writing concurrent code, the compiler will be there to stop you from introducing common concurrency bugs. I imagine this will be frustrating for new programmers as they will be reported as compiler errors, but in reality, Swift is doing its best to protect you and your code from doing anything crazy. After all, concurrency is a very hard problem to solve. If you have read a book on operating systems you have probably seen that there\u0026rsquo;s multiple patterns developers can make use of in order to write safe concurrent code. But writing this code manually is hard, error prone, and depending on the context, hard to test. Having these checks at compile time is a great security feature.\nMarking a function as async does not mean a new task will be created - if anything, by default, when the compiler sees a function marked as async, it expects it to be awaited on each call. Creating tasks is not an automatic process. We can inform the compiler that we want to run concurrent code, but it will be up to it to honor your request. Tasks are always created explicitly.\nStructured concurrency is about a balance between simplicity and flexibility. You will be able to do a lot - if not all - of your concurrency work under these constraints, but always remember that if you need even more flexibility, you will find a lower level API that gives you the control you need, but with less safety. Check out my Multithreading Options on Apple Platforms article to see an overview of the alternatives.\nIntroducing async let Using async let, also called a concurrent binding, will launch a task in parallel.\nasync let result = //... an async function call (without await) When Swift finds an async let, the function to the right side of the equals will begin executing concurrently. That is, where an await call would suspend execution of your program there, an async let will launch the task but it will continue executing the code underneath it until its value is needed.\nConsider the following example:\nfunc downloadImageConcurrentlyWhilePrinting(imageNumber: Int) async throws -\u0026gt; UIImage { print(\u0026#34;One lint prints\u0026#34;) print(\u0026#34;We will begin downloading now\u0026#34;) async let image = downloadImage(imageNumber: imageNumber) print(\u0026#34;Another line prints until we have the image\u0026#34;) print(\u0026#34;Keep on printing\u0026#34;) return try await image } You will notice that all the print statements are executed basically instantly. This is because async let has launched downloadImage as another task. The two print statements prior to the async let call will be executed as you would expect. The other print statements will print just as quickly because downloadImage is not an awaited call. By the time we reach return try await image, we are telling our program to suspend on the return statement until the image is done downloading (or if an error is thrown).\nBecause this is one of the mechanisms that will allow us to execute code concurrently, you can have multiple async let calls at any given point, and the system will execute them concurrently if possible.\nWe can now rewrite our downloadImageAndMetadata function to download both the image and the metadata at the same time.\nfunc downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { async let image = downloadImage(imageNumber: imageNumber) async let metadata = downloadMetadata(for: imageNumber) return try DetailedImage(image: await image, metadata: await metadata) } Note: The session most of this article is based on, Explore structured concurrency in Swift, uses a similar example to this, but you can run and play with this one.\nBy appending async before let and moving the await keyword to the place where we expect values to exist, we have successfully downloaded multiple things at once, using a structured flow. That\u0026rsquo;s really neat!\nAnd that\u0026rsquo;s it. That\u0026rsquo;s how you can execute code concurrently with the new async/await APIs. This article is not over yet, though. Before we are done, we need to explore a very important concept: The Task Tree.\nThe Task Tree Structured Concurrency makes use of a concept called The Task Tree. The task tree is a hierarchy that our structured concurrency code runs on. The task tree influences attributes of our tasks such as cancellation, priority, and local variables. When we jump from one async function to another, the same task is used to execute the new call.\nfunc downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { async let image = downloadImage(imageNumber: imageNumber) async let metadata = downloadMetadata(for: imageNumber) return try DetailedImage(image: await image, metadata: await metadata) } When we call downloadImageAndMetadata, it will inherit all the attributes from the parent task. Each call to async let will create a new task - this task is the child task of the task the current function is running on.\nOur downloadImageAndMetadata function can potentially span two child tasks: One for the image, and one for the metadata, and all this code will (again potentially) be running at the same time.\ndownloadImageAndMetadata will inherit the attributes of whatever task it\u0026rsquo;s running on, and downloadImage and downloadMetadata will in turn inherit the properties from downloadImageAndMetadata.\nIt\u0026rsquo;s important to note that tasks are not children of the functions they are running on, although their lifetimes may be tied to them.\nThe task tree enforces a very important rule: A parent task can only finish its work as long as all the children have finished their work.\nYou can see this enforcement because the await calls won\u0026rsquo;t let the execution continue until they are given the green light to continue. Both downloadImage and downloadMetadata may throw an error or return a value, but in either case, they finish their work before the code that requires them can continue executing.\nThe normal case for downloadImageAndMetadata is that downloadImage and downloadMetadata will both finish successfully. But what happens if one of them throws an error and the other finishes without a hitch?\nThe great thing is that you can see, intuitively, and thanks to the fact that the code is structured and runs from top to bottom, that whenever one of them throws an error, downloadImageAndMetadata will throw the same error. But what happens to the actual execution of the other task? That is, suppose downloadMetadata fails and downloadImage is downloading a big image. What happens to the image download?\nWhen a task fails, Swift will mark the remaining child tasks as cancelled. In this example, since downloadMetadata failed, downloadImage will be marked as cancelled. Marking a task as cancelled does not actually mean that the task is cancelled. Instead, it simply notifies the task that its results are no longer needed. All the child tasks and their descendants will be cancelled when their parent is cancelled.\nBut when do the tasks actually stop their execution? This is a neat property of structured tasks: cancellation is cooperative. Tasks do not stop immediately. Instead, they will do it as soon as they see it is appropriate. If you have network calls going, it may be inappropriate to just stop them the moment they get the cancel notification.\nTasks have to check for cancellation explicitly. You can check for cancellation from anywhere. This makes it your responsibility to design your code with cancellation in mind, especially if you have tasks that can take a very long time to complete.\nThere are two ways to check for cancellation. First, you can call try Task.checkCancellation() when your functions are marked as throws. And second, there is a Task.isCancelled which returns a boolean when your tasks are not running inside throwing contexts.\nfunc downloadImage(imageNumber: Int) async throws -\u0026gt; UIImage { try Task.checkCancellation() let imageUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part3/\\(imageNumber).png\u0026#34;)! let imageRequest = URLRequest(url: imageUrl) let (data, imageResponse) = try await URLSession.shared.data(for: imageRequest) guard let image = UIImage(data: data), (imageResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.badImage } return image } func downloadMetadata(for id: Int) async throws -\u0026gt; ImageMetadata { try Task.checkCancellation() let metadataUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part3/\\(id).json\u0026#34;)! let metadataRequest = URLRequest(url: metadataUrl) let (data, metadataResponse) = try await URLSession.shared.data(for: metadataRequest) guard (metadataResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.invalidMetadata } return try JSONDecoder().decode(ImageMetadata.self, from: data) } func downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { async let image = downloadImage(imageNumber: imageNumber) async let metadata = downloadMetadata(for: imageNumber) return try DetailedImage(image: await image, metadata: await metadata) } // NEW FUNCTION func downloadMultipleImagesWithMetadata(images: Int...) async throws -\u0026gt; [DetailedImage]{ var imagesMetadata: [DetailedImage] = [] for image in images { print(image) async let image = downloadImageAndMetadata(imageNumber: image) imagesMetadata += [try await image] } return imagesMetadata } In the example above, we have added a cancellation check at the beginning of downloadImage and downloadMetadata. We have also added a function that will try to download multiple images (although not concurrently - we will learn how perform a variable number of concurrent tasks when we talk about Task Groups). If any image or metadata download fails, the children tasks will be notified of the cancellation, and if they have a chance to cancel - i.e. if they haven\u0026rsquo;t started downloading their images or metadata - they will stop their execution.\nSummary We have finally started exploring the world of actual concurrent execution using the new async/await APIs. You learned what structured concurrency is, and a way to implement it with async let. You also learned about the task tree and how cancellation is cooperative and how it works.\nYou may have noticed that our newest function, downloadMultipleImagesWithMetadata, will not download all three images at the same time, because it is necessary to await the result before we can append it to the array. We will learn how to execute a variable number of concurrent tasks when we begin talking about Task Groups.\nIn the meantime, take your time to analyze the contents of this article, and as usual, here is the sample project you can play around with to better understand the concepts of this article.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"cf83c43ae74be0fe7ca057c67ee0e3d2","title":"Converting closure-based code into async/await in Swift","link":"/posts/converting-closure-based-code-into-async-await-in-swift/","content":"This article is part of my Modern Concurrency in Swift article series.\nThis article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.\nTable of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Task Groups in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks To better benefit from this article, you should be familiar with async/await. If you aren\u0026rsquo;t, feel free to read the first part of this article series: Understanding async/await in Swift.\nI was debating whether this article should be its own or if its contents should be appended to Introducing async/await in Swift. I decided to make the previous article shorter in an attempt to not overload the articles with information, and to hopefully make it easier to understand these API with smaller articles.\nLast week, we had a long discussion on async/await. We contrasted how it compares to callbacks, and we showed examples that hopefully convinced you async/await is really neat.\nWe are just one step away from actual concurrency. Before we dive into concurrency - with structured concurrency - next week, I want to show you how you can convert closure-based and delegate-based code into async/await code. The idea behind this article is to give you all the tools so that you can start adopting async/await in your projects, baby steps at a time.\nIf you are a library vendor, you will be able to provide async/await code for all your closure-based APIs, so not only will you be able to start using it for your uses, you will be able to ship async/await to your users.\nIf you are not a library vendor, but you do have an app in production, it\u0026rsquo;s likely that your own app is using asynchronous code that notifies you via callbacks. If you want to start migrating that project, you can start by implementing async versions of your async methods. If you are using a third party library that is not offering async/await versions of their calls, you can easily provide your own.\nUnderstanding Continuations If you have read the first part of this article series, you may remember what a Continuation is, but let\u0026rsquo;s have a quick refresher before we move on.\nA continuation is simply what happens after an async call. When you are using async/await, the continuation is easy to understand: Everything below an await call, is a continuation.\nConsider the following example:\nfunc downloadMetadata(for id: Int) async throws -\u0026gt; ImageMetadata { let metadataUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(id).json\u0026#34;)! let metadataRequest = URLRequest(url: metadataUrl) let (data, metadataResponse) = try await URLSession.shared.data(for: metadataRequest) guard (metadataResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.invalidMetadata } return try JSONDecoder().decode(ImageMetadata.self, from: data) } In this example, the keyword await will (may) trigger a data download task in a different thread. Everything underneath await (that is, starting on the line with a guard), is a continuation.\nContinuations are not limited to the async/await APIs. When you are using closure-based async APIs, a continuation is everything called within your completion handlers.\nlet metadataUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).json\u0026#34;)! let metadataTask = URLSession.shared.dataTask(with: metadataUrl) { data, response, error in guard let data = data, let metadata = try? JSONDecoder().decode(ImageMetadata.self, from: data), (response as? HTTPURLResponse)?.statusCode == 200 else { completionHandler(nil, ImageDownloadError.invalidMetadata) return } let detailedImage = DetailedImage(image: image, metadata: metadata) completionHandler(detailedImage, nil) } metadataTask.resume() This is a closure version of the code above. Once again, the continuation starts at the guard. The main difference is the completion handler version has a flow that is harder to follow.\nIntroducing explicit continuations Swift provides a few methods we can use to convert callback-based code into async/await: withCheckedContinuation and withCheckedThrowingContinuation. The difference between the two is the latter is used for code that throws errors. I call these methods explicit continuations.\nSuppose you have a completion handler version of the downloadMetadata(for:) method declared above:\n// MARK: - Definitions struct ImageMetadata: Codable { let name: String let firstAppearance: String let year: Int } struct DetailedImage { let image: UIImage let metadata: ImageMetadata } enum ImageDownloadError: Error { case badImage case invalidMetadata } // MARK: - Functions func downloadImageAndMetadata( imageNumber: Int, completionHandler: @escaping (_ image: DetailedImage?, _ error: Error?) -\u0026gt; Void ) { let imageUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).png\u0026#34;)! let imageTask = URLSession.shared.dataTask(with: imageUrl) { data, response, error in guard let data = data, let image = UIImage(data: data), (response as? HTTPURLResponse)?.statusCode == 200 else { completionHandler(nil, ImageDownloadError.badImage) return } let metadataUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).json\u0026#34;)! let metadataTask = URLSession.shared.dataTask(with: metadataUrl) { data, response, error in guard let data = data, let metadata = try? JSONDecoder().decode(ImageMetadata.self, from: data), (response as? HTTPURLResponse)?.statusCode == 200 else { completionHandler(nil, ImageDownloadError.invalidMetadata) return } let detailedImage = DetailedImage(image: image, metadata: metadata) completionHandler(detailedImage, nil) } metadataTask.resume() } imageTask.resume() } And suppose you are not the original author of it, and it\u0026rsquo;s closed source, preventing you from modifying it directly. If you wanted to start your async/await migration with this method, the simplest way to do it would be by wrapping a call to downloadImageAndMetadata(for:imageNumber:completionHandler) inside the withCheckedThrowingContinuation method.\nfunc downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { return try await withCheckedThrowingContinuation({ (continuation: CheckedContinuation\u0026lt;DetailedImage, Error\u0026gt;) in downloadImageAndMetadata(imageNumber: imageNumber) { image, error in if let image = image { continuation.resume(returning: image) } else { continuation.resume(throwing: error!) } } }) } The magic behind this function occurs inside the withCheckedThrowingContinuation part. This function will give us a CheckedContinuation\u0026lt;T, E\u0026gt; where E: Error object that provides us with methods we need to call. In this example, the original version of downloadImageWithMetadata passes us a DetailedImage or an error, and we need to call the right resume method depending on what we get. If this method called us with a Result\u0026lt;DetailedImage, Error\u0026gt;, we could call .resume(with:) and pass it the result directly.\nContinuations must be called exactly once, therefore there must be a continuation call within every branch of withCheckedThrowingContinuation. If you forget to call .resume, things could go awry. Luckily, Swift will let you know.\nNote: Or at least, it is supposed to. This article is based on the last few minutes of the Meet async/await in Swift session. At least as of Beta 1, I was able to have code with branches that don\u0026rsquo;t call resume.\nAnd just like that, we have converted closure-based code into something prettier! Using the async/await version of this function is as easy as:\nTask { if let imageDetail = try? await downloadImageAndMetadata(imageNumber: 1) { self.imageView.image = imageDetail.image self.metadata.text = \u0026#34;\\(imageDetail.metadata.name) (\\(imageDetail.metadata.firstAppearance) - \\(imageDetail.metadata.year))\u0026#34; } } If you want to see and run a program using this, you can download a sample project from here.\nConverting delegate-based code into async/await. Up to now we have seen how you can convert callback-based code into async/await. You can also do this with delegate-based code. While delegate-based APIs have mostly disappeared in favor of callbacks, it is still common to encounter them, especially if the APIs in question are event-driven (Bluetooth, Location, etc). As such, you may benefit from knowing you can also bridge these to async/await.\nSuppose you have an UIKit app that lets users choose contacts in a ViewController. In its simplest form, it may look similar to this:\nclass ViewController: UIViewController, CNContactPickerDelegate { @IBOutlet weak var contactNameLabel: UILabel! override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. } @IBAction func chooseContactTouchUpInside(_ sender: Any) { showContactPicker() } func showContactPicker() { let picker = CNContactPickerViewController() picker.delegate = self present(picker, animated: true) } func contactPicker(_ picker: CNContactPickerViewController, didSelect contact: CNContact) { self.contactNameLabel.text = contact.givenName picker.dismiss(animated: true, completion: nil) } } Pressing a \u0026ldquo;choose contact\u0026rdquo; button will call showContactPicker, displaying the actual picker and, when the user selects the contact, the system will notify us of the event through the contactPicker(_:contact) method.\nBut we can do better. We can instead create an object that will wrap all this Contacts stuff for us. We can then create async methods that will let us know when a user has selected a contact. With this, we will be able to keep linearity in our program and keep a flow that is easier to follow.\nWe can declare ContactPicker as follows:\n@MainActor class ContactPicker: NSObject, CNContactPickerDelegate { private typealias ContactCheckedContinuation = CheckedContinuation\u0026lt;CNContact, Never\u0026gt; // 1 private unowned var viewController: UIViewController private var contactContinuation: ContactCheckedContinuation? // 2 private var picker: CNContactPickerViewController init(viewController: UIViewController) { self.viewController = viewController picker = CNContactPickerViewController() super.init() picker.delegate = self } func pickContact() async -\u0026gt; CNContact { // 3 viewController.present(picker, animated: true) return await withCheckedContinuation({ (continuation: ContactCheckedContinuation) in self.contactContinuation = continuation }) } func contactPicker(_ picker: CNContactPickerViewController, didSelect contact: CNContact) { contactContinuation?.resume(returning: contact) // 4 contactContinuation = nil picker.dismiss(animated: true, completion: nil) } } What you need to understand here is:\nWe are typealiasing CheckedContinuation\u0026lt;CNContact, Never\u0026gt; so it\u0026rsquo;s easier to refer to. Since we can\u0026rsquo;t get an error, the error parameter is Never. private var contactContinuation: ContactCheckedContinuation? will hold a reference to the continuation itself. This continuation is given to us in the withCheckedContinuation handler. It‚Äôs an optional because we will set it to nil after the first call to avoid it being called more than once. pickContact is async, as it will return the CNContact to us. We call withCheckedContinuation here. When the contact is picked, we will call the continuation with resume. And then, to use this:\n@IBAction func chooseContactTouchUpInside(_ sender: Any) { async { let contactPicker = ContactPicker(viewController: self) let contact = await contactPicker.pickContact() self.contactNameLabel.text = contact.givenName } } But, note that our implementation has a flaw. If you have used the ContactsUI framework before, you may have caught it.\nThe UI presented gives our users the option to cancel without choosing a contact. Earlier we said that when dealing with continuations, you need to call the continuation exactly once. In the program above, we are not implementing the contactPickerDidCancel(_) method, and therefore our continuation is not getting called when users cancel.\nTo solve this, we have two options: We can throw an error when users cancel, or we can pass in a nil contact. It doesn\u0026rsquo;t make much sense to throw an error in this case, so we will modify the code to take a nil contact instead.\nclass ContactPicker: NSObject, CNContactPickerDelegate { private typealias ContactCheckedContinuation = CheckedContinuation\u0026lt;CNContact?, Never\u0026gt; private unowned var viewController: UIViewController private var contactContinuation: ContactCheckedContinuation? private var picker: CNContactPickerViewController init(viewController: UIViewController) { self.viewController = viewController picker = CNContactPickerViewController() super.init() picker.delegate = self } func pickContact() async -\u0026gt; CNContact? { return await withCheckedContinuation({ (continuation: ContactCheckedContinuation) in self.contactContinuation = continuation viewController.present(picker, animated: true) }) } func contactPicker(_ picker: CNContactPickerViewController, didSelect contact: CNContact) { contactContinuation?.resume(returning: contact) contactContinuation = nil picker.dismiss(animated: true, completion: nil) } func contactPickerDidCancel(_ picker: CNContactPickerViewController) { contactContinuation?.resume(returning: nil) contactContinuation = nil } } //... // in ViewController @IBAction func chooseContactTouchUpInside(_ sender: Any) { async { let contactPicker = ContactPicker(viewController: self) let contact = await contactPicker.pickContact() self.contactNameLabel.text = contact?.givenName } } This is much better. We will now call resume in all possible paths, our program will always be in a valid state, and, while we did write more code, there will be cases in which going the extra mile to preserve linearity will benefit the structure of the program in the long run. *\nYou can download a full version of the contact picker app here. It\u0026rsquo;s a UIKit app with a simple button and labels that shows you the given name of the contact you selected. Hopefully it will help you better understand the contents of this article.\nSummary In this article we have explored how we can bridge from callback-based code or delegate-based code into async/await. We learned how to use checked continuations to do so, and we enforced the idea of what a continuation actually is.\nWith this, you should now understand all the essentials of async/await. You are now ready to tackle actual concurrency, and next week we will start talking about that, starting with structured concurrency. You will learn how to run many tasks in parallel and how to process such results.\nNotes *: You should always stop and think if going that extra mile is actually worth it or if it is overkill. Over-engineering is a real and common problem in software engineering.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"95d5a70ea0b4c58134ffac8e93dadaaa","title":"Understanding async/await in Swift","link":"/posts/understanding-async-await-in-swift/","content":"This article is part of my Modern Concurrency in Swift article series.\nThis article was originally written creating examples using Xcode 13 beta 1. The article, code samples, and provided sample project have been updated for Xcode 13 beta 3.\nTable of Contents Modern Concurrency in Swift: Introduction Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Group Tasks in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks Before you try to dive in with concurrency in Swift, you need to understand async/await. There\u0026rsquo;s no way around it. While async/await are not the only concurrency options, Apple\u0026rsquo;s SDKs are starting to make heavy use of them. There is no doubt that third-party library providers will start offering these as well.\nThis article will explore async/await and nothing else. Once you understand these concepts, we will start moving on to more advanced articles where we cover structured concurrency, unstructured concurrency, SwiftUI, and more.\nIf you have been writing callback-based concurrency, keep in mind that the implementation for async/await is very different from anything you have seen before in Apple\u0026rsquo;s technologies. It basically throws what you know about concurrent programming out the window. It\u0026rsquo;s important to keep that in mind as you read this article.\nIn this article, we will write a function that downloads an image and then its metadata using a different network call. We will show you how doing this with callback-based concurrency can become hard to manage quickly, and how async/await solves this problem beautifully.\nRefreshing Concepts A Refresher on Procedural Programming When you write any normal program with no exceptional needs such as networking and/or I/O, your program executes in the order your code is written, calling procedures as needed, and returning content to the caller if necessary.\nConsider the following code:\nfunc sayHi() { print(\u0026#34;Hi\u0026#34;) } func multiply(_ x: Int, _ y: Int) -\u0026gt; Int { x * y } func sayBye(result: Int) { print(\u0026#34;Bye \\(result)\u0026#34;) } func performCoolStuff() { sayHi() let x = 10 let y = 5 let result = multiply(x, y) sayBye(result: result) } // Calling performCoolStuff() performCoolStuff() When you call performCoolStuff(), your code is executed as follows:\nIt will first call sayHi() It will declare two variables, x and y. It will call multiply passing in the values for x and y. It will call sayBye with the result of the multiplication There\u0026rsquo;s nowhere to get lost here. Your code is called in the same order it was given. Functions that call other functions are placed in the call stack exactly as they appear, unwinding back as they return values to the main callers. As calls happen, the function give back control to the caller through the use of return. When we call multiply, we assign control to it, and when it returns us a result, it gives us back control through return.\nYou don\u0026rsquo;t think much about procedural programming. Chances are you do it daily, and it always works the way you expect it to *.\nA refresher on callback-based concurrency code. Things are a bit more complicated when it comes to code that may run in parallel with other code. Consider the following example that will download an image through a network call and the metadata through a different network call (you can copy and paste this code in a view controller of a new project - it contains everything you need to run it). The download takes place at the same time as the main thread\u0026rsquo;s execution:\nstruct ImageMetadata: Codable { let name: String let firstAppearance: String let year: Int } struct DetailedImage { let image: UIImage let metadata: ImageMetadata } enum ImageDownloadError: Error { case badImage case invalidMetadata } func sayHi() { print(\u0026#34;Hi\u0026#34;) } func multiply(_ x: Int, _ y: Int) -\u0026gt; Int { x * y } func sayBye(result: Int) { print(\u0026#34;Bye \\(result)\u0026#34;) } func downloadImageAndMetadata( imageNumber: Int, completionHandler: @escaping (_ image: DetailedImage?, _ error: Error?) -\u0026gt; Void ) { let imageUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).png\u0026#34;)! let imageTask = URLSession.shared.dataTask(with: imageUrl) { data, response, error in guard let data = data, let image = UIImage(data: data), (response as? HTTPURLResponse)?.statusCode == 200 else { completionHandler(nil, ImageDownloadError.badImage) return } let metadataUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).json\u0026#34;)! let metadataTask = URLSession.shared.dataTask(with: metadataUrl) { data, response, error in guard let data = data, let metadata = try? JSONDecoder().decode(ImageMetadata.self, from: data), (response as? HTTPURLResponse)?.statusCode == 200 else { completionHandler(nil, ImageDownloadError.invalidMetadata) return } let detailedImage = DetailedImage(image: image, metadata: metadata) completionHandler(detailedImage, nil) } metadataTask.resume() } imageTask.resume() } func performMessyStuff() { sayHi() let x = 10 downloadImageAndMetadata(imageNumber: 1) { image, error in DispatchQueue.main.async { print(\u0026#34;We got results\u0026#34;) } } let y = 5 let result = multiply(x, y) sayBye(result: result) } performMessyStuff() Note: Apple used a similar example in the Meet async/await in Swift session at WWDC2021. This example is based on that, but I created a compilable version you can use.\nThis is what happens:\nThe method calls sayHi() normally. We create a variable x and assign it a value. downloadImageAndMetadata is called, which internally will set up the first variables it needs for its execution (imageUrl). We create a variable, once again synchronously, that will hold a dataTask and provide it with a completion handler that will be called after it\u0026rsquo;s done downloading. We call resume() on the task to begin the download. The contents of the completion handler will not be executed immediately. Instead, while the downloads happen, the program continues its execution. The program may, or may not, print \u0026quot;We got results\u0026quot;. In the case of a network download, it will always take a while, but if this were a faster asynchronous operation, it may be called at this point. The program will create a variable y. If both downloads have finished successfully, the program may print \u0026quot;We got results\u0026quot;. Otherwise it creates the result variable and calls multiply, which may or may not finish before the downloads. If the downloads have finished successfully, the program will print \u0026quot;We got results\u0026quot;, otherwise it will call sayBye. Somewhere above there and at any point, the program may start the metadata download task after the image task has downloaded. This flow of execution is messy, because downloading data from the network is asynchronous and all its work happens somewhere else. Anything else may happen on the main thread while the downloads take place. Whatever the console prints may have a different output on each run **. The downloads spawn from the main thread onto another thread, but the program will continue executing the code in the main thread without any issue. This makes it hard to think procedurally, because we rely on the completionHandler to let us know when it has finished its work. If there are tasks that can be performed in the main thread, but they depend on an image and/or its metadata, we have to do all that work in the completion handler (while rerouting the work to the main thread with DispatchQueue.main.async whenever relevant).\nIn the case of callback-based asynchronous code, control is given back whenever completion handlers are executed.\nAnd as you may imagine, these calls can become more and more complex and nested.\nIntroducing async/await If I had to explain async/await in few words, I\u0026rsquo;d say this:\nasync/await is like a hybrid between procedural programming and callback-based closures.\nBefore we explain why, let\u0026rsquo;s keep two things in mind:\nProcedural code runs from top to bottom. Control is given back to the caller through return Callback-based concurrency will create asynchronous tasks, but it will continue executing the current thread without an issue, even if those tasks are running. Control is given back to the caller through completion handlers. Let\u0026rsquo;s take a few minutes to discuss the async and await keywords individually.\nasync async has two uses:\nTo tell the compiler when a piece of code is asynchronous. To spawn asynchronous tasks in parallel. To mark a function as async, simply put the keyword after the function\u0026rsquo;s closing parenthesis and before the arrow, like this:\nfunc downloadImage(id: Int) async -\u0026gt; UIImage? { ... } Or:\nfunc downloadImage(id: Int) async throws -\u0026gt; UIImage { ... } You can already see a huge advantage here. The completion handler is gone, and our function signature is very clear with its purpose. We can tell at first glance if it is async and what it returns.\nasync code can only run in concurrent contexts. That is to say, within other async functions, or when manually dispatched via Task {}. We will explore Task {} in a bit.\nawait await is where the magic happens. Whenever the program finds the await keywords, it has the option of suspending the function. It may or may not do so, and the decision is up to the system.\nIf the system does suspend the function, await will return control, not to the caller, but to the system. The system will then use the thread to perform other work until the suspended function is done. The statements below await will not be executed until it has finished. The system decides what\u0026rsquo;s important to execute, and at some point, it will return control back to you after it sees the awaited function has finished.\nYou can think of it as a traffic light. If you are driving down the road and you find a red light, chances are you will stop. But if it is 4 AM in the morning and there\u0026rsquo;s no cars coming you may just run it. ***\nWhat you need to understand about await is that, if it does choose to suspend, nothing below it will execute until the system tells it to, and the system will use the thread to do other work.\nEvery call to an async function, must be marked as await.\nTo better understand this, we will rewrite our downloadImageAndMetadata function, this time using async and using await within the body.\nfunc downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { // Attempt to download the image first. let imageUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).png\u0026#34;)! let imageRequest = URLRequest(url: imageUrl) let (imageData, imageResponse) = try await URLSession.shared.data(for: imageRequest) guard let image = UIImage(data: imageData), (imageResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.badImage } // If there were no issues, continue downloading the metadata. let metadataUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).json\u0026#34;)! let metadataRequest = URLRequest(url: metadataUrl) let (metadataData, metadataResponse) = try await URLSession.shared.data(for: metadataRequest) guard (metadataResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.invalidMetadata } let detailedImage = DetailedImage(image: image, metadata: try JSONDecoder().decode(ImageMetadata.self, from: metadataData)) return detailedImage } This is a long function, but it\u0026rsquo;s already much better than the pyramid version of it. Let\u0026rsquo;s highlight the important parts first:\nThe program procedurally creates imageUrl and imageRequest. The program reaches a call to an async call, URLSession.shared.data(for:). The program will make a decision on suspending the function or continuing it. In this case, it\u0026rsquo;s likely it will suspend due to the nature of networking, but don\u0026rsquo;t get used to taking that for granted. We will assume the program suspends the function. This will give control back to the system. The system may do other work that is not relevant to this task while the download awaits. Anything under the first await will not be executed. It will not reach the guard, it will not create the variables for the metadata, it will do nothing until the awaited function finishes. After some time, the system will give control back to you, after the awaited function has finished. The guard statement is reached, throwing an error if necessary. The program will repeat steps 2-8 but for the metadata task. The program will return a new DetailedImage. As you can see, it is a pretty linear flow, and the way await suspends the rest of the execution until the system deems it necessary makes it behave very much like procedural programming.\nWe can separate that function into different functions as well:\nfunc downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { let image = try await downloadImage(imageNumber: imageNumber) let metadata = try await downloadMetadata(for: imageNumber) return DetailedImage(image: image, metadata: metadata) } func downloadImage(imageNumber: Int) async throws -\u0026gt; UIImage { let imageUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(imageNumber).png\u0026#34;)! let imageRequest = URLRequest(url: imageUrl) let (data, imageResponse) = try await URLSession.shared.data(for: imageRequest) guard let image = UIImage(data: data), (imageResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.badImage } return image } func downloadMetadata(for id: Int) async throws -\u0026gt; ImageMetadata { let metadataUrl = URL(string: \u0026#34;https://www.andyibanez.com/fairesepages.github.io/tutorials/async-await/part1/\\(id).json\u0026#34;)! let metadataRequest = URLRequest(url: metadataUrl) let (data, metadataResponse) = try await URLSession.shared.data(for: metadataRequest) guard (metadataResponse as? HTTPURLResponse)?.statusCode == 200 else { throw ImageDownloadError.invalidMetadata } return try JSONDecoder().decode(ImageMetadata.self, from: data) } As long as we mark the functions as async, this is possible to do.\nIt is important to note the linearity of this. The metadata and image are not being downloaded at the same time. It will download the image first, and the metadata later. We can make it download both the image and metadata at the same time, but this article is not about actual concurrency just yet. We will explore how to do both tasks at the same time when we learn about structured concurrency.\nIf you want to see the function suspension in action, simply put some print statements before and after await code. You will see that the print statements will be executed slowly, as the system suspends the download tasks, perform other tasks, and gives control back to you.\nfunc downloadImageAndMetadata(imageNumber: Int) async throws -\u0026gt; DetailedImage { print(\u0026#34;Will download image\u0026#34;) let image = try await downloadImage(imageNumber: imageNumber) print(\u0026#34;Has downloaded image\u0026#34;) print(\u0026#34;Will download metadata\u0026#34;) let metadata = try await downloadMetadata(for: imageNumber) print(\u0026#34;Has downloaded metadata\u0026#34;) return DetailedImage(image: image, metadata: metadata) } If your internet is a bit too speedy to appreciate the slow prints, Apple provides us a neat method: Task.sleep. This function solely exists to sleep the thread for a given number of time, and you can use it to explore async/await.\nNote: Unfortunately Task.sleep appears to crash as of Xcode 13 Beta 1. await Task.sleep(2 * 1_000_000_000) . One final important note about await: It\u0026rsquo;s not guaranteed that the same thread that executed the code above it is the same one that will execute the code below it (commonly called the continuation). This has important implications when dealing with UI. If you use await in a context that needs the main thread such as a ViewController, make sure you mark the functions with await with the @MainActor attribute, or add the attribute to the entire class declaration. If you want a complete tour behind how the new concurrency works in Swift, check out the Swift concurrency: Behind the scenes WWDC2021 session talk.\n\u0026ldquo;Bridging\u0026rdquo; between the sync and async worlds with Task We can create a \u0026ldquo;bridge\u0026rdquo; between the sync and async worlds creating a Task. To understand why this is necessary, consider the following piece of code:\nfunc performDownload() { let imageDetail = try? await downloadMetadata(for: 1) } The compiler will protect us from erroneously running this, showing the following error:\n\u0026lsquo;async\u0026rsquo; call in a function that does not support concurrency Add \u0026lsquo;async\u0026rsquo; to function \u0026lsquo;performDownload()\u0026rsquo; to make it asynchronous\nThe compiler is suggesting we mark performDownload as async.\nfunc performDownload() async { let imageDetail = try? await downloadMetadata(for: 1) } But this is not always possible. What if performDownload is in a view controller or in another place that can\u0026rsquo;t give you an asynchronous context?\nTo fix this, we can bridge this synchronous function to the asynchronous world using Task {}.\nfunc performDownload() { Task { let imageDetail = try? await downloadMetadata(for: 1) } } We are explicitly creating an asynchronous context, and it will behave as such. We can now call perform download from any sync context without an issue.\nget async To make things even better, properties that are read-only can be awaited.\nSuppose you have the following wrapper object:\nstruct Character { let id: Int } We can get its image and metadata by calling downloadImageAndMetadata, but you could also give this object two calculated properties to get its image and/or metadata independently.\nstruct Character { let id: Int var metadata: ImageMetadata { get async throws { let metadata = try await downloadMetadata(for: id) return metadata } } var image: UIImage { get async throws { return try await downloadImage(imageNumber: id) } } } And we can use it as such:\nlet metadata = try? await character.metadata Summary This was a long introduction to async/await, but hopefully the included examples and discussion will help you understand how this works. async/await are the heart of the new concurrency system, so you need to have a fine grasp of them. Future articles may not be as long. Generally, covering the basics of something requires a lot of effort as it\u0026rsquo;s important to not miss any details. Hopefully this article will be of use to you.\nI have created a sample project that makes use of the downloaded image and metadata in a UIKit project. You can download it from here.\nWhen ran, the program will simply download the contents and display them like this:\nOn the viewDidAppear method, you will find the following code:\noverride func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) // MARK: METHOD 1 - Using Async/Await Task { if let imageDetail = try? await downloadImageAndMetadata(imageNumber: 1) { self.imageView.image = imageDetail.image self.metadata.text = \u0026#34;\\(imageDetail.metadata.name) (\\(imageDetail.metadata.firstAppearance) - \\(imageDetail.metadata.year))\u0026#34; } } // MARK: METHOD 2 - Using async properties // Task { // let character = Character(id: 1) // if // let metadata = try? await character.metadata, // let image = try? await character.image{ // imageView.image = image // self.metadata.text = \u0026#34;\\(metadata.name) (\\(metadata.firstAppearance) - \\(metadata.year))\u0026#34; // } // } // MARK: Method 3 - Using Callbacks // downloadImageAndMetadata(imageNumber: 1) { imageDetail, error in // DispatchQueue.main.async { // if let imageDetail = imageDetail { // self.imageView.image = imageDetail.image // self.metadata.text = \u0026#34;\\(imageDetail.metadata.name) (\\(imageDetail.metadata.firstAppearance) - \\(imageDetail.metadata.year))\u0026#34; // } // } // } } You can comment and uncomment everything under MARK: - Method x to fill the outlets with the data provided by the different methods of getting the data. Hopefully you can play around with this to get a better hang of how async/await work in Swift.\nI want to revisit these two points I made earlier:\nProcedural code runs from top to bottom. Control is given back to the caller through return Callback-based concurrency will create asynchronous tasks, but it will continue executing the current thread without an issue, even if those tasks are running. Control is given back to the caller through completion handlers. We can now append one more thing to summarize:\n3 async/await will run in order just like procedural programming. When it finds an await call, the job will suspend and will give control back to the system instead of the caller. Unlike callback-based concurrency, it will not continue execution of the statements under it until it has finished. The system will make use of the thread to perform other work, and when it decides it\u0026rsquo;s time to revisit your function, it will, and execution will resume linearly.\nWhen you are ready, you can proceed to the third article in the series, Converting Closure-based code into async/await in Swift to learn more about continuations, explicit continuations, and how to bridge closure-based and delegate-based code into async/await.\nNotes *: Well, except when you put bugs in.\n**: This is not obvious in this example, but there exists asynchronous code that is much faster than a network call and it may finish much faster than expected, altering the output of the console on each run.\n***: Drive responsibly.\n","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"7b1c5a687b0c2de2d7cad6842daa5885","title":"Modern Concurrency in Swift: Introduction","link":"/posts/modern-concurrency-in-swift-introduction/","content":"Introduction This article series was originally written creating examples using Xcode 13 beta 1. The articles in the series, code samples, and provided sample projects have been updated for Xcode 13 beta 3.\nThis is a tutorial series focused on the new async/await APIs Apple introduced in WWDC2021. I do not know how many articles it is going to have yet, but they will be posted in the upcoming weeks.\nThe WWDC2021 session videos do a great job explaining these new APIs, but I feel they can still be overwhelming for newcomers and long-time developers alike. My intention with this series is to talk about the new concurrency APIs, one step a time, covering a few concepts on each article, until you can feel confident with your understanding of these APIs. When I see it necessary, I may use or modify Apple\u0026rsquo;s provided snippets. I will explicitly mark this external code as such.\nThe knowledge you will see throughout the series is knowledge I have obtained from the WWDC2021 sessions (the relevant sessions will be linked in each article), playing around with them myself, and other sources. I do not claim to know everything about the new await/async APIs, and while the Evolution proposal was approved ahead of WWDC2021, I am building this series with the knowledge I have as I did not explore the proposal before WWDC2021\nFor that reason, please do point out inaccuracies if you find them so I can fix them. It is very important for me that this series is as clear and accurate as it can be. Please keep an eye out on typos and report anything odd you find, either via E-mail or Twitter.\nBefore we explore the new APIs, let\u0026rsquo;s talk about the current concurrency implementations and their problems. By the end of this introductory article, you will be convinced that the new APIs are worth investing your time in.\nConcurrency and its Problems with Current Implementations In WWDC2021, Apple introduced a new way for developers to implement concurrency in their apps. I will refer to them as the \u0026ldquo;async/await APIs\u0026rdquo;, as these two words are at the core of it all.\nAs developers, we have used concurrency, oftentimes without knowing. Almost every call that takes a closure in the iOS SDK has such signature because it is an asynchronous call. If you have been an iOS developer for a while, you know that UI code runs in the so-called Main Thread. Because UI manipulation takes place here, if anything takes a very long time to finish, the system may decide your app has frozen, and it will kill it, but not before your users realize your app is in a hanged state. The need for concurrency in software in general will, more often than not, be about spawning concurrent tasks to get some job done, or to speed up something. When it comes to Apple technologies, the need for concurrency is the same, but we also need to keep an eye out for the main thread to not get blocked by anything.\nCalls that have the potential to freeze our main thread are all over Apple\u0026rsquo;s SDKs. This is why Apple provides us with different tools to delegate work to different threads and keep our main thread free.\nBefore moving on, remember that these new APIs are guaranteed to become the standard, but they are not the only ones used for concurrency. I have a full article on the alternatives if you find the async/await APIs don\u0026rsquo;t cover your needs.\nCallback-based concurrency for API for consumers Take the URLSession API as an example. Prior to WWDC2021, if you needed to make some sort of networking call, you would call something like this:\n// ... (1) let task = URLSession.shared.dataTask(with: ...) { data, response, error in // ... (2) } task.resume() // ... (3) Anything that goes inside the callback closure - that is, everything within the braces {}, is code that will be called asynchronously after the download has taken place and there\u0026rsquo;s no guarantee on what order it will be called in. We know it will be called after (1), but that\u0026rsquo;s about it.\nIn the snippet above, we have code that executes before the network call (1). But (2) will not be executed immediately. Instead, execution may continue for (3), and when the download has finished (2) will be executed. The execution order for (2) and (3) is not guaranteed. In this particular example, we can say that \u0026ldquo;obviously\u0026rdquo; a network call is slower than the linear execution of a program, but don\u0026rsquo;t take this for granted - there\u0026rsquo;s plenty of APIs that don\u0026rsquo;t hit the network that are asynchronous in nature.\nThis works, and this old-style API is not going anywhere. But what if we need to later parse some JSON, or do more network calls based on the response? This becomes painful and we arrive at what we call a pyramid of doom.\nlet task = URLSession.shared.dataTask(with: ...) { data, response, error in let taskThatNeedsPreviousResponse = URLSession.shared.dataTask(with: ...) { data, response, error in let evenMoreNestedNetworking = URLSession.shared.dataTask(with: ...) { data, response, error in /// We can finally do more work here } evenMoreNestedNetworking.resume() } taskThatNeedsPreviousResponse.resume() } task.resume() As the calls get nested and nested (and nested), it can become a problem when it comes to readability. You can take action and move every \u0026ldquo;pyramid floor\u0026rdquo; into its own function, but that\u0026rsquo;s more of a patch than a real solution as you end up polluting your scope.\nCallback-based concurrency for API Designers Now suppose you were tasked with creating a function that downloads an image and resizes it to create a thumbnail. You may end up writing something like this:\nfunc fetchThumbnail(for id: String, completion: @escaping (UIImage?, Error?) -\u0026gt; Void) { let request = thumbnailURLRequest(for: id) let task = URLSession.shared.dataTask(with: request) { data, response, error in if let error = error { completion(nil, error) } else if (response as? HTTPURLResponse)?.statusCode != 200 { completion(nil, FetchError.badID) } else { guard let image = UIImage(data: data!) else { return // (1) } image.prepareThumbnail(of: CGSize(width: 40, height: 40)) { thumbnail in guard let thumbnail = thumbnail else { return // (2) } completion(thumbnail, nil) } } } task.resume() } (This code was taken directly as-is from Apple\u0026rsquo;s Meet async/await in Swift session)\nThe first thing you will notice is that this code is a mouthful. Just sit down and appreciate how long it is. It begins by downloading an image, and then it tries to resize it. Both the network call and the thumbnail resizing call are asynchronous calls. Not only that, but your call needs to pass in its own completion handler as well.\nThis code has bugs too, and they may be hard to find. Remember that if you write a callback-based function, you need to call the passed callback regardless of what happens. The developer calling your function can find cases in which their callback is never called. In the example above, there\u0026rsquo;s two places where this can happen. I have marked those places as (1) and (2). As you are not calling the completion handler in these places, you will leave the API caller waiting for a response that will never arrive - at the very least you won\u0026rsquo;t be blocking the thread, though.\nSo, the first problem we can find here is that you are responsible for calling the callback when you are done with your job. This isn\u0026rsquo;t too bad for small functions, but it can become overwhelming when you realize there\u0026rsquo;s many edge cases you need to think of.\nBut one thing I have always disliked about callback-based APIs is that all the information about the \u0026ldquo;return\u0026rdquo; type and the error are part of the closure you are given. Because of this, you cannot have a clean API that states its return type and whether it can yield an error not. There\u0026rsquo;s no such thing as throwing an error. With these APIs. You have to provide the error in the callback. While static typing does not disappear, it does get more abstracted (not to mention autocomplete isn\u0026rsquo;t as useful, as there times it decides not to work when making such calls). And as a cherry on top, your API consumers may decide to discard the error if they so choose - this is not necessarily a bad thing, but there\u0026rsquo;s times when you want them to really take some action.\nCombine? The Combine framework solves many of the problems above beautifully through the use of pipelines, but we will not be talking much about Apple\u0026rsquo;s reactive framework in this series, and there\u0026rsquo;s a few reasons for that.\nFirst, I just feel Combine\u0026rsquo;s future is uncertain. I love the framework myself, and while at the beginning of WWDC2021 I was skeptic about whether these new APIs could take its place, I changed my opinion after I watched some more sessions on the topic.\nSecond, I feel it\u0026rsquo;s not used enough. Combine was introduced in 2019 and it has(had?) a big role driving the existence of SwiftUI. But I just get the feeling that it hasn\u0026rsquo;t seen much adoption in the few years it has been out in the wild. There\u0026rsquo;s no evidence people are adopting it to replace their callback-based code, and both the lack of community resources (a few exist, and are awesome) and lack of updates on the framework make it seem that it may not be wise to invest much time on it until we know what Apple\u0026rsquo;s plans for it are.\nCombine will not be mentioned much throughout this tutorial series unless it\u0026rsquo;s relevant. In general, I no longer consider it a candidate to replace callback-based code - I was a huge fan of wrapping asynchronous code in Futures, though.\nA new way of thinking Finally, before diving in to the articles below, I recommend you try to throw your current knowledge of concurrency out the window, because the implementation for async/await is very different, and it\u0026rsquo;s important to understand this mindset before you truly understand how it works. Once you understand async/await, the rest of the toolset is easier to understand.\nI am not saying your current concurrency knowledge will be irrelevant. Far from it, but it\u0026rsquo;s interesting how imposing an easier to write concurrency code requires us to rethink how we have been thinking about concurrency in Apple\u0026rsquo;s platforms in the past decades. I actually think async/await is easier to understand for people who have never seen asynchronous code before, because it\u0026rsquo;s so similar to procedural programming.\nWithout further ado\u0026hellip; The table of contents below list the articles of this series. They are designed to be independent of each other, so you don\u0026rsquo;t need to read the early articles if you just need the last ones. That said if you are new to async/await, you should read them all in order.\nMany of the articles contain code that you can run. Feel free to copy and paste it or download the sample projects when available to aid your learning.\nTable of Contents Understanding async/await in Swift Converting closure-based code into async/await in Swift Structured Concurrency in Swift: Using async let Structured Concurrency With Task Groups in Swift Introduction to Unstructured Concurrency in Swift Unstructured Concurrency With Detached Tasks in Swift Understanding Actors in the New Concurrency Model in Swift @MainActor and Global Actors in Swift Sharing Data Across Tasks with the @TaskLocal property wrapper in the new Swift Concurrency Model Using AsyncSequence in Swift Modern Swift Concurrency Summary, Cheatsheet, and Thanks ","tags":["swift","apple","programming","ios","concurrency","async","await","ios","macos","ipados","watchos","wwdc2021","multithreading"]},{"id":"3cb783e05ecbf2aa3953446f1b592498","title":"Strategies For Asking Users to Rate Your App","link":"/posts/strategies-asking-users-rate-your-app/","content":"Having our apps have good reviews is generally a good thing. After all, many users look into how many stars an app has before deciding on downloading it. Apps with a general poor rating may not get many downloads (unless they are \u0026ldquo;essential\u0026rdquo; apps of any kind, such as companion app to another service).\nWe all as developers have experienced that users are quick to give a one-star review when something doesn\u0026rsquo;t work right, but they are never inclined to rate 5 stars when they are satisfied with an app.\nLuckily for us, Apple has given us the SKStoreReviewController.requestReview() API. Introduced in iOS 13, we can call this method (rather, its non-deprecated sibling, SKStoreReviewController.requestReview(scene:)) to prompt users to rate our app.\nRequest Rating Review\nOf course the ability to ask for ratings does come with some restrictions. First, users can turn off this prompt completely at the system level, and second, while you can call this method as many times as you like, it will only be displayed to your user at most 3 times per year. So it\u0026rsquo;s not a good idea to go around willy nilly calling it everywhere. Instead, you need to think of ways to call this method without being annoying and without wasting the alert\u0026rsquo;s presentation.\nIn this article we will talk about the do\u0026rsquo;s, don\u0026rsquo;ts, and other strategies you can use to decide when you should attempt to show a review prompt to your users. We are not going to talk about the technicalities of the API as it is almost literally a one-line call - I say almost, because on the non-deprecated version of the method you do need to get a scene to call the alert on. So we before we dive in, allow me to give you this barebones piece of code that you can use to quickly get a scene and call the review prompt on it.\nfunc showReviewPrompt() { if let scene = getScene() { SKStoreReviewController.requestReview(in: scene) } } func getScene() -\u0026gt; UIWindowScene? { if let iPadScene = getIPadScene() { return iPadScene } else { return getIPhoneScene() } } func getIPadScene() -\u0026gt; UIWindowScene? { UIApplication.shared.connectedScenes.first(where: { $0.activationState == .foregroundActive }) as? UIWindowScene } func getIPhoneScene() -\u0026gt; UIWindowScene? { UIApplication.shared.connectedScenes.first as? UIWindowScene } What you should NOT do Before we dive into a couple of strategies I have used in the past with good success, let\u0026rsquo;s talk about what you shouldn\u0026rsquo;t do. I want to kick off this article with the don\u0026rsquo;ts because it\u0026rsquo;s a mistake I see a lot of developers make.\nAttempting to show the prompt on launch Many developers decide to call the review prompt when an app launches and call it a day. This is not really a good strategy for two reasons:\nUsers may not mind giving apps a rating, but they may have a sense of urgency using your app and they are not interested in seeing the prompt first thing. You will likely show the prompt before the user has had a chance to use your app. In the best scenario, users will dismiss the prompt and move on. You will have wasted one of your three displays in a year, but no harm will be done. Worst case scenario, users will give you a 1-star rating if they see your prompt when launching your app.\nShowing the prompt too soon, before users have a chance to use your app. Probably the downside of the requestReview API is that you need to manually code all the checks in order to control if the system will attempt to show the alert or not. Many times I download an app and it either asks me for a review as soon as I launch it the second time or after a few minutes of use. I tend to dismiss all the prompts that occur too soon because I simply don\u0026rsquo;t know what rating an app deserves. They will show the prompt three times and I will end up dismissing them all. The app then loses my rating.\nIn my case, I dismiss the prompt and move on. Beware of users who will happily give you a one-star review for being persistent.\nAt the very least, you should prevent the alert from being shown on the same day the user installs the app. I\u0026rsquo;d program a timer to start asking for ratings after at least one week has passed.\nShowing the prompt upon any generic action. Ideally, you should look for an action users perform often enough that has some value to them, and attempt to prompt a rating after the user has done it. Launching the app and opening a screen are just too random to ask for a rating. In generally if users feel satisfied and they feel a specific action has given them value, they will be more likely to rate your app with a positive score.\nStrategies for getting the best out of review prompts I can\u0026rsquo;t stress this enough, but you have three opportunities to ask your users for a rating in a 365-day cycle. You should avoid wasting these opportunities at all costs. Actually having an strategy that governs your review prompt display can yield many positive results.\nLook for specific satisfying actions to make the call on If you do not want to spend much time thinking on a strategy for your review prompt, spend a few hours thinking on the key areas or your app that bring value to your users, and attach the call to those actions. Don\u0026rsquo;t blindly put your calls when launching your app and call it a day.\nPiggyback on existing score prompts to call the review prompt At my day job, I maintain the iOS app for a bank, and one of the things we do, is to ask users what their experience was like after doing a transfer. We ask them every 14 days after the last transfer. This prompt is not linked to the App Store prompt. Instead, it\u0026rsquo;s linked to our internal analytics database.\nIf you have something like that, feel free to piggy back on it and show a review prompt if the user has given a positive score to your previous prompt. In general, users who had a positive experience and are likely to say they had a good experience with something, they are likely to do it again even if they were just asked a second ago. Very few users may still give you 1-star reviews, but the vast majority of them who are satisfied will not.\nImplement a weight-based system to govern the display of your prompt If you have an app that is designed to be used for long periods of time, or if you have an app that may have users performing multiple actions in a short session, you can implement a weigh based system.\nThe idea behind this system is that you assign a weight - a number - to different actions a user may perform. For example, suppose you wanted to implement this system on the Twitter app:\nOpening a Tweet has a weight of 1 point. Loving a tweet has a weight of 3 points. Creating a tweet has a weight of 5 points. You then decide on a threshold, and when this threshold is reached, you show the prompt.\nIn this way, suppose you have a threshold of 40. Your users can open the app and perform the following actions before the prompt is shown:\nUser launches the app. User likes 3 recent tweets of their favorite celebrity. (+9 points) User opens two celebrity tweets to check the replies. (+11) User decides to reply with one tweet to their favorite celebrity, and another reply to a random commenter in the twitter thread. (+10) User closes the app for the day. The next day, the user makes a random tweet (+5) The user likes two tweets from another celebrity (+6) After all these actions take place, weight will reach 41. The prompt is displayed, and since it\u0026rsquo;s established your user likes the app, they are likely to give it a good rating.\nYou can play around and mix and match any other constraints to this prompt. For example, you may want to avoid showing the prompt until at least one week has passed since your user first used your app.\nConclusion Apple gives us the tools to aid us improve the rating of our app. This can have long-term implications, make your app more popular, and more. But you have to use this tool very effectively, because it\u0026rsquo;s very limited, and if you are not careful, it may actually backfire on you.\n","tags":["swift","apple","programming"]},{"id":"b693e863a183f5f044a7e405649f8bfa","title":"My WWDC 2021 Wishlist","link":"/posts/my-wwdc-2021-wishlist/","content":"WWDC is undoubtly my favorite event of the year, and it has been for the past 11 years. This week I\u0026rsquo;m taking a break from writing technical articles and I want to talk about my personal wishlist, both for features and developers tools.\nWriting Actual ViewControllers for the Settings App The iOS Settings.app was supposed to be a place where you as a user, have a centralized place to configure all your settings for all your apps. I have always liked the idea of having this central area for settings instead of having to have a dedicated settings screen within each app.\nUnfortunately, as it has been the case for many years now, there is not really much you can do when you attempt to integrate with the settings app as it is now. You can create a Settings bundle, but it is all managed by a plist. You cannot have any more complex settings that would allow users to login to dedicated service accounts or do anything else remotely complex.\nBack when I played around writing jailbreak tweaks, one of my favorite things to do was to write an entire Settings screen from scratch. You could add a view controller and therefore manage complex settings there. I used this in Sideswitch Toggles to dynamically load bundles in a Settings screen and in Cecrecy to load all user apps.\nHaving such feature would help me achieve my dream of having a centralized settings place for settings.\nDedicated Debugging Tools for SwiftUI SwiftUI is my favorite framework introduced in the past few years, but when it comes to debugging issues with it, it can sometimes be more complicated than I\u0026rsquo;d like. From performance issues to broken animations and unexpected view refreshes (or expected view refreshes that don\u0026rsquo;t take place), sometimes SwiftUI throws you off the curve. While the framework is intuitive enough and you understand that views get rebuilt on state change, sometimes tracking down a state change is not easy as you could swear upon your family that you are not changing a given variable.\nMore UIKit Components Represented in SwiftUI. WWDC2020 got us many nice improvements over SwiftUI. Lazy grids and lazy stacks, pinned views in Scroll Views, the new SwiftUI lifecycle. Everything is beautiful, but the framework is still missing a lot of common and native functionality that users would expect. We cannot (easily) do pull to refresh, we cannot badge items in tab bar items, there is no search bar that support Search Tokens (introduced in WWDC2019)\u0026hellip; There\u0026rsquo;s a lot of stuff in UIKit that doesn\u0026rsquo;t exist in SwiftUI yet. We can create a lot of it, arguably without much effort, but SwiftUI should have as much UIKit functionality as possible.\nHomescreen \u0026ldquo;Mini Apps\u0026rdquo; Now hear me out on this one - When Apple introduced the first version of Widgets back in iOS 8, they said widgets are not \u0026ldquo;Mini Apps\u0026rdquo; and shouldn\u0026rsquo;t be used as such. Despite that, some helpful widgets were exactly mini apps and they worked fine and where a beautiful convenience to have at times. From calculators to tip calculators, it was great being able to do some quick action without having to open a full app.\nFast forward to iOS 14, and Apple introduced a new widget system. While I love these widgets and actually use them constantly, they are mostly info widgets and you can\u0026rsquo;t do much with them. Shall a widget be able to perform actions, they will launch the app. You cannot do much with them.\nWith the advent of M1 iPads, Apple has to do an amazing effort to convince us that putting a desktop-grade CPU in a tablet was worth every bit of the effort. For the first time ever, Apple tells us how much RAM is in each iPad, with the bigger storage models having way more RAM. This RAM has to be exploited somehow, and while we could argue it\u0026rsquo;s all reserved for \u0026ldquo;pro\u0026rdquo; apps that don\u0026rsquo;t exist yet, I believe any average consumer could make use of it, and what better way to do that than to have a bunch of mini apps on the iPad\u0026rsquo;s homescreen.\nWidgets on the iOS/iPadOS Homescreens If there\u0026rsquo;s one thing I\u0026rsquo;d love to have is to put my favorite widgets in the lockscreen. While Face ID is crazy cast, it\u0026rsquo;s still not better than simply having the info I care about at a glance on the lockscreen. I have wanted this for a long time, and I\u0026rsquo;d really like it to happen. The feature could support the privacy feature where notification contents are not visible until the device scans your face, similar to how Messages won\u0026rsquo;t show anything about a message\u0026rsquo;s notification without having to unlock the device, if you have such feature enabled.\nSwiftUI Support for Notifications Extensions You can customize the look of your notifications UI by using Notification Content Extensions. You can add any UI you want and customize the user actions for them.\nCurrently, you need to use MVC for this, and while I think SwiftUI is perfect for this kind of tasks, it\u0026rsquo;s just not supported yet.\nBeing Able to Write Your own SwiftUI Result Wrappers We saw our first taste of result wrappers - then called Property Wrappers - with the introduction of SwiftUI in 2019. While you can write your own property wrapper for anything, I haven\u0026rsquo;t been able to find a way to write a property wrapper that works with SwiftUI in a way we can get the same behavior as @State, for instance. If you have a property wrapper to store keychain values and you update them, there\u0026rsquo;s no way for SwiftUI to notice the change and rebuild your views as necessary.\n","tags":["apple","wwdc2021","wwdc"]},{"id":"503d49bff5aab708f7a4b011874db2e1","title":"Quick Tip: Notifying Users of App Updates - For Free","link":"/posts/quick-tip-notifying-users-app-updates-for-free/","content":"This may sound surprising to you, but even though we have app autoupdate on iOS now (and we have had it for a very long time), many people don\u0026rsquo;t have it on, or the system simply doesn\u0026rsquo;t prioritize app updates because users don\u0026rsquo;t prioritize it enough. In fact, in my day job, in which I maintain a user-facing banking app, the vast majority of users are not even in the latest version. The most used version is the one we released in April, and we average one release per week for bug fixes alone, and about monthly for major new features.\nWe are bank and we really have no reason to do this for free, but my intention with the last paragraph was to tell you that your users may not be updating as often as you believe. If you login to App Store Connect and check your analytics, you may be surprised by how many people are not in your latest version. So in this article, I will show you how you can push users to update more often, and how you can do it for free.\nThe Main Idea The way to achieve is to simply store, somewhere, the latest app version that you have released to the public, and to have your app check against that version every so often, maybe on every lunch, or every 24 hours, the criteria is up to you.\nMy particular approach involves hosting a JSON File on GitHub, which you can do for free. As a simple example, your JSON can look like this:\n{ \u0026#34;latestVersion\u0026#34;: \u0026#34;5.2.9\u0026#34; } You have two choices here: You can either store your build number there, which would make it very simply to check against the build number inside your bundle, or you can store the short (aka \u0026ldquo;marketing\u0026rdquo;) version of your app here, which requires a bit more work to parse the value.\nStoring your build number may sound like a good idea but it depends on how you use build numbers in general. For my own apps, I always bump the build number for every version I upload to the App Store. For my jobby-job app, the build number gets reset for every new version. We only bump the build number when we need to modify the app before App Review and we need to do last minute changes, or when we deal with rejection and need to upload a new build.\nIn general, I prefer it when the build number keeps going up, so the approach I will show you here will use the Short Version.\nShort Version Parser When you want to prompt users to update your app, you may need to consider if you want to simply let them know there is an ew version, or you may want to force them to update the app before using it. You may need to keep both situations in mind. For my jobby-job, we never force users to update unless we find critical bugs that affect the functionality of our apps. For new features, we won\u0026rsquo;t force updates, as we try to keep older iOS versions in check.\nA good strategy to have is you may want to force users to update when a new major version is available, and optionally prompt them when the minor version is bumped. You need to keep this in mind as you may just use the JSON file without the version altogether to set a flag and force users to update to any version any way.\nTo parse the version number and start doing checks, I have a AppVersion while which takes an app version as a string, and then you can compare it to other AppVersion objects or you can compare just each component - the major version, the minor version, or the patch version. The class looks like this:\nclass AppVersion { let appShortVersionString: String let appBundleVersionString: String public var major: Int { if let major = appShortVersionString.split(separator: \u0026#34;.\u0026#34;).first { return Int(major) ?? 0 } return 0 } public var minor: Int { let splat = appShortVersionString.split(separator: \u0026#34;.\u0026#34;) if splat.count \u0026gt; 1 { return Int(splat[1]) ?? 0 } return 0 } public var patch: Int { let versions = appShortVersionString.split(separator: \u0026#34;.\u0026#34;) if let patch = versions.last, versions.count \u0026gt; 2 { return Int(patch) ?? 0 } return 0 } public var buildNumber: Int { return Int(appBundleVersionString) ?? 0 } init(shortVersionString: String, bundleVersionString: String) { appShortVersionString = shortVersionString appBundleVersionString = bundleVersionString } static let shared = AppVersion( shortVersionString: Bundle.main.object(forInfoDictionaryKey: \u0026#34;CFBundleShortVersionString\u0026#34;) as? String ?? \u0026#34;\u0026#34;, bundleVersionString: Bundle.main.object(forInfoDictionaryKey: \u0026#34;CFBundleVersion\u0026#34;) as? String ?? \u0026#34;\u0026#34; ) var appShortVersion: String { appShortVersionString } var appBundleVersion: String { appBundleVersionString } } extension AppVersion: Equatable { static func == (lhs: AppVersion, rhs: AppVersion) -\u0026gt; Bool { lhs.major == rhs.major \u0026amp;\u0026amp; lhs.minor == lhs.minor \u0026amp;\u0026amp; lhs.patch == lhs.patch } static func === (lhs: AppVersion, rhs: AppVersion) -\u0026gt; Bool { lhs.major == rhs.major \u0026amp;\u0026amp; lhs.minor == rhs.minor \u0026amp;\u0026amp; lhs.patch == rhs.patch \u0026amp;\u0026amp; lhs.buildNumber == rhs.buildNumber } } extension AppVersion: Comparable { static func \u0026lt; (lhs: AppVersion, rhs: AppVersion) -\u0026gt; Bool { if lhs.major == rhs.major { if lhs.minor == rhs.minor { if lhs.patch == rhs.patch { return false } return lhs.patch \u0026lt; rhs.patch } return lhs.minor \u0026lt; rhs.minor } return lhs.major \u0026lt; rhs.major } } A few things are worth pointing out:\nEasy access to the major, minor, and patch versions of the version. We conform to Equatable and add two comparing methods. === will compare the short and bundle version before deciding they are the same, and == only checks the short version number. By conforming to Comparable, we will be able to compare two versions to see if one is more recent or not - note that comparable only requires you to implement \u0026lt;, as the others can be synthesized for you. The shared property (which may make sense to rename to current) will give you the current app version. With this, you now have a nice clean way to check for app versions, stored somewhere, and you can show UI and/or block functionality based on it.\nConclusion Users don\u0026rsquo;t update their apps as often as we would like, so you may find it useful to let them know a new version is available without being invasive. Luckily, being able host simple data for free is really useful for this purpose, and version checking isn\u0026rsquo;t that complicated either.\n","tags":["swift","programming","apple","ios","ipados"]},{"id":"292722aba6e39254f74ff254188884d6","title":"Integrating FaceID/TouchID with SwiftUI","link":"/posts/integrating-face-id-touch-id-swiftui/","content":"As SwiftUI is still relatively new, and it is not clear yet for many people how to use MVVM on iOS, I decided to write this short article in which I explain how one would integrate Face ID/Touch ID with SwiftUI.\nLet\u0026rsquo;s remember that SwiftUI uses the MVVM design pattern over the traditional MVC, and this can be confusing for people who are migrating to the new pattern for the first time. That said, the main takeaway from this article is to understand that views get destroyed and rebuilt very often in SwiftUI, and therefore the right place to write this kind of logic is in the ViewModel\nNote: This article will explain how to use the basic local authentication APIs to show a practical example of how it can be done. Don\u0026rsquo;t use this in a real sensitive application. If you need to add actual security, you can make use of what you learn in this article alongside my other article titled Using the iOS Keychain with Biometrics to integrate the authentication APIs with the Keychain APIs.\nProject Setup The first thing you need to do is to add the NSFaceIDUsageDescription key to your Info.plist with a string explaining why your app needs Face ID. If you don\u0026rsquo;t set this key, your app is going to crash before your app has a chance to show the authorization prompt.\nThe Authorization Code If you have been googling to use Face ID/Touch ID in your app, you have likely come across similar code to this:\nfunc requestBiometricUnlock() { let context = LAContext() var error: NSError? = nil let canEvaluate = context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: \u0026amp;error) if canEvaluate { if context.biometryType != .none { print(\u0026#34;We got a biometric\u0026#34;) context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: \u0026#34;To access your data\u0026#34;) { (success, error) in if success { print(\u0026#34;Authenticated successfully!\u0026#34;) } } } } } And you have tried to integrate it in your SwiftUI just to find out that it doesn\u0026rsquo;t work or it behaves very erratically. Remember that SwiftUI uses MVVM and it relies on state management to do anything useful.\nThe good news is that this very same code works with SwiftUI, with some modifications.\nCreating the View We are going to create a very simple app. We are going to simulate a simple app with sensitive data and we will add another screen prompting users to login.\nThe first screen will consist of a tab bar. and some secret data.\nstruct MainApp: View { var body: some View { TabView { Text(\u0026#34;Secret Page one\u0026#34;) .tabItem { Label(\u0026#34;My Secrets\u0026#34;, systemImage: \u0026#34;lock.doc\u0026#34;) } Text(\u0026#34;Secret page two\u0026#34;) .tabItem { Label(\u0026#34;Your secrets\u0026#34;, systemImage: \u0026#34;lock.square\u0026#34;) } } } } Go to your main app file (the one with your WindowGroup), and call include your view in the hierarchy.\n@main struct Touch IDswiftuiApp: App { var body: some Scene { WindowGroup { MainApp() } } } When you build and run your app, you should see this:\nWith this, we have a full functional app without Face ID login. We are going to add the Face ID part now, and we will start by designing a simple Face ID screen.\n// Face IDLoginView.swift struct Face IDLoginView: View { @Binding var appUnlocked: Bool var body: some View { VStack(spacing: 24) { Image(systemName: \u0026#34;Face ID\u0026#34;) .resizable() .frame(width: 150, height: 150) Button(action: { print(\u0026#34;Prompt Face ID login\u0026#34;) }, label: { HStack { Spacer() Text(\u0026#34;Login now\u0026#34;) .fontWeight(.bold) Spacer() } .padding(10) .background(Color.blue) .foregroundColor(.white) .clipShape(RoundedRectangle(cornerRadius: 12)) }) } .padding() } } These are the only two views we need for this simple. We will now setup the logic to allow Face ID to unlock the app later. We will also add a very temporary logic to ensure our login view looks properly when running it on the simulator.\nWe will use that @Binding variable (appUnlocked) to control a boolean passed from somewhere else. For now, make your button change the value of this variable to true.\nButton(action: { appUnlocked = true // Unlocking the app by tapping a button. }, label: { HStack { Spacer() Text(\u0026#34;Login now\u0026#34;) .fontWeight(.bold) Spacer() } .padding(10) .background(Color.blue) .foregroundColor(.white) .clipShape(RoundedRectangle(cornerRadius: 12)) }) Now, go back to your @main and make it look like this:\n@main struct Touch IDswiftuiApp: App { @State var appUnlocked = false var body: some Scene { WindowGroup { ZStack { if appUnlocked { MainApp() } else { Face IDLoginView(appUnlocked: $appUnlocked) .background(Color.white) } } } } } What we are doing here is to conditionally show the main app view or the login view depending on the status of the appUnlocked variable.\nNote: You may have noticed that I have a ZStack rather than just switching the view directly within the WindowGroup. The reason for this is that, I don\u0026rsquo;t know if this is a SwiftUI bug, but even in a ZStack, the tab bar of MainApp will show up in Face IDLoginView, which is not something we want here. I\u0026rsquo;m keeping the ZStack to give you space to animate transitions between the views.\nIf you run the app now you will notice that you can tap the button and the views will swap. This is a very good starting point, and we can work on top of this to add the Face ID integration.\nThe View Model We can finally integrate the ViewModel, which will handle the Face ID logic for us. You have basically two ways of doing this:\nYou can create a ViewModel for the Face IDLoginView view and update the binding inside your view with a completion handler. Create a ViewModel for the App itself (I\u0026rsquo;d call it AppContext), and pass the context itself to any views that need it, either as an @EnvironmentObject or @ObservedObject and have the Login view modify the state within it. I prefer this approach as I\u0026rsquo;d consider appUnlocked to be global state, and many views could, presumably could depend on it. I will go with the second approach is it makes more sense with our particular context.\nThis is what our AppContext looks like:\n// AppContext.swift import Foundation import SwiftUI import LocalAuthentication class AppContext: ObservableObject { @Published var appUnlocked = false @Published var authorizationError: Error? func requestBiometricUnlock() { let context = LAContext() var error: NSError? = nil let canEvaluate = context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: \u0026amp;error) if canEvaluate { if context.biometryType != .none { context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: \u0026#34;To access your data\u0026#34;) { (success, error) in DispatchQueue.main.async { self.appUnlocked = success self.authorizationError = error } } } } } } We will move our appUnlocked state from the App itself into our topmost ViewModel called AppContext. requestBiometricUnlock() is the same method I showed you above, but I have tweaked it a bit to fit MVVM better. I have also added a authorizationError variable. We are not going to use it in this article, but feel free to use if you want to react or simply show any error that occurs to your users.\nNow, we need to do some modifications to Face IDLoginView to call the context\u0026rsquo;s requestBiometricUnlock() method and modify our appUnlocked variable accordingly. Once this variable is updated, so will our view hierarchy.\nstruct Face IDLoginView: View { @ObservedObject var appContext: AppContext var body: some View { VStack(spacing: 24) { Image(systemName: \u0026#34;Face ID\u0026#34;) .resizable() .frame(width: 150, height: 150) Button(action: { appContext.requestBiometricUnlock() }, label: { HStack { Spacer() Text(\u0026#34;Login now\u0026#34;) .fontWeight(.bold) Spacer() } .padding(10) .background(Color.blue) .foregroundColor(.white) .clipShape(RoundedRectangle(cornerRadius: 12)) }) } .padding() } } Finally, modify your app\u0026rsquo;s entry point to use the AppContext as a @StateObject and pass in this object to Face IDLoginView.\n@main struct Touch IDswiftuiApp: App { @StateObject var appContext = AppContext() var body: some Scene { WindowGroup { ZStack { if appContext.appUnlocked { MainApp() } else { Face IDLoginView(appUnlocked: $appContext.appUnlocked) .background(Color.white) } } } } } You could use an @EnvironmentObject instead of @ObservedObject, but I prefer to use @EnvironmentObject when there is a deep hierarchy of views spread across different files. Since in this case we only have one level \u0026ldquo;deep\u0026rdquo;, I decided to use @ObservedObject, but feel free to experiment with @EnvironmentObject if you want.\nAnd with this, our app works. We can login with Face ID without an issue now. On the simulator, feel free to go to Hardware \u0026gt; Face ID to simulate Face ID and successful face reads. It\u0026rsquo;s useful when testing apps that require on biometric unlock on iOS.\nSample Project. You can delete a sample project from here. It has a little bonus, which is transition animations when the Face ID scan is successful.\nConclusion Integrating SwiftUI with Face ID and Touch ID is not at all complicated. Really, once you understand MVVM and how it plays out in the SwiftUI world, you will be able to integrate almost anything with SwiftUI. If you are still struggling to understand how MVVM works, maybe my Using CoreLocation with SwiftUI article will help you.\n","tags":["faceid","touchid","swiftui","swift","programming","apple","ios","ipados"]},{"id":"bfb74364b6a371817e7b87899da92656","title":"The NSDateInterval Object","link":"/posts/the-nsdateinterval-object/","content":"Somehow, this shiny new object, which was actually introduced in iOS 10, flew past my radar. Today I want to take a few minutes to talk about the NSDateInterval object. This object allows us to quickly calculate the time interval (represented as a NSTimeInterval) between dates, it allows us to check if two dates overlap, and it allows us to check if a given date is within a certain interval.\nThe NSDateInterval Class This small object is made of a handful of property and functions.\nTo create a NSDateInterval, you can provide either a closed range with the start and end date, or you can provide the start date with a duration. In the example below we will use two dates, seven days apart.\nlet now = Date() let components = DateComponents(day: 7) if let sevenDaysAhead = Calendar.current.date(byAdding: components, to: now) { let interval = DateInterval(start: now, end: sevenDaysAhead) } Our internal variable now has a couple of handful properties. You can get the startDate and endDate, but perhaps most interesting the duration, which contains the number of seconds between both dates.\nHaving the duration can be useful on its own, but what\u0026rsquo;s even more useful is that we can now compare and check if said date intervals intersect, or if a date is part of a certain date interval.\nComparing Date Intervals To compare two DateIntervals, simply call compare(_) on one of them and pass it the second interval. This operation will return a ComparisonResult which will let you know which one is \u0026ldquo;bigger\u0026rdquo; than the other.\nlet now = Date() let components = DateComponents(day: 7) if let sevenDaysAhead = Calendar.current.date(byAdding: components, to: now) { let interval = DateInterval(start: now, end: sevenDaysAhead) // Let\u0026#39;s create a differemt but similar interval, but eight months ago let eightMonthsAgoComponents = DateComponents(month: -8) if let eightMonthsAgo = Calendar.current.date(byAdding: eightMonthsAgoComponents, to: now), let eightMonthsAgoPlus7Days = Calendar.current.date(byAdding: DateComponents(day: 7), to: eightMonthsAgo){ let interval8MonthsAgo = DateInterval(start: eightMonthsAgo, end: eightMonthsAgoPlus7Days) let comparison = interval.compare(interval8MonthsAgo) switch comparison { case .orderedAscending: print(\u0026#34;orderedAscending\u0026#34;) case .orderedDescending: print(\u0026#34;orderedDescending\u0026#34;) case .orderedSame: print(\u0026#34;orderedSame\u0026#34;) } } } This is a bit of a mouthful, but essentially what it does is:\nCreate an interval between the current day and the date seven days in the future. Create a date 8 months in the past, create a date 7 days after that day in the past, and create an interval with the two. Compare them. The result will be .orderedDescending, since the left side of the operation (interval) is more recent than interval8MonthsAgo. When comparing, the framework takes into account the startDate and the duration if necessary. The documentation on comparing intervals has more info.\nEquality of DateIntervals We can check if two intervals are equal by using the == operator (the documentation incorrectly states that there is a isEqual function, but I wasn\u0026rsquo;t able to access it.\nTwo DateIntervals are considered equal when their startDate and duration properties are the same.\nlet equalIntervals = interval == interval8MonthsAgo // false The take away from the last two sections is that equality and comparison takes into account the startDate and duration properties in order to do their calculations. If you need to see if two date ranges are the same duration, but they don\u0026rsquo;t overlap or have any relation with each other, use Calendar\u0026rsquo;s Calendar.current.dateComponents((_from:to:) method instead.\nlet difference = Calendar.current.dateComponents([.day], from: now, to: eightMonthsAgo) // -242 days ago (feel free to use abs() for the absolute value Checking Interval Intersections You can check if two DateIntervals intersect by calling the intersects(_) method in one of them.\nlet now = Date() if let sevenDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 7), to: now), let sixDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 6), to: now), let eightDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 8), to: now), let ninetDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 9), to: eightDaysAhead){ let sevenDayInterval = DateInterval(start: now, end: sevenDaysAhead) let sixDayInterval = DateInterval(start: now, end: sixDaysAhead) let eightDaysInterval = DateInterval(start: now, end: eightDaysAhead) let sevenAndSixIntersect = sevenDayInterval.intersects(sixDayInterval) // true let sevenAndEightIntersect = sevenDayInterval.intersects(eightDaysInterval) // true let farAwayInterval = DateInterval(start: eightDaysAhead, end: ninetDaysAhead) let sevenDaysIntervalIntersectsFarAwayInterval = sevenDayInterval.intersects(farAwayInterval) // false } And, you can also find the interval at which two date intervals intersect, by calling intersection(with:) on either one.\nimport Foundation let now = Date() if let sevenDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 7), to: now), let sixDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 6), to: now), let eightDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 8), to: now), let ninetDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 9), to: eightDaysAhead){ let sevenDayInterval = DateInterval(start: now, end: sevenDaysAhead) let eightDaysInterval = DateInterval(start: now, end: eightDaysAhead) if let intersectionInterval = sevenDayInterval.intersection(with: eightDaysInterval) { print(\u0026#34;The intervals intersect starting on \\(intersectionInterval.start) and ending on \\(intersectionInterval.end)\u0026#34;) } } Checking if a date exists within an interval. Finally, the last useful thing we can do is to check if a single date fits in an interval. For this, simply call contains(_).\nlet now = Date() if let sevenDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 7), to: now), let sixDaysAhead = Calendar.current.date(byAdding: DateComponents(day: 6), to: now), let sevenDaysAndASecondAhead = Calendar.current.date(byAdding: DateComponents(day: 7, second: 1), to: now) { let intervalSevenDaysAhead = DateInterval(start: now, end: sevenDaysAhead) let containsSixDaysAhead = intervalSevenDaysAhead.contains(sixDaysAhead) let containsSevenDaysAndASecondAhead = intervalSevenDaysAhead.contains(sevenDaysAndASecondAhead) } Conclusion If there is one thing Apple likes to do, is to make dealing with dates a simple affair for us. All their date-related APIs are packed with functionality to make calculation and manipulation of time-related data really easily. 5 years ago, Apple added NSDateInterval to their collection of date tools, and it\u0026rsquo;s amazing how simple it is to work date intervals with it.\n","tags":["swift","apple","programming","foundation","nsdate"]},{"id":"e4b296be92acee553e9764b3f5734056","title":"Swift's print in Depth","link":"/posts/swift-print-in-depth/","content":"Ah, print. Probably the most known, the most used, the most popular debugging tool, and probably the most loved line of code of all time. You have undoubtedly used print before, if not in Swift, in other languages. The vast majority of programmers have started their software building skills with a print or equivalent somewhere.\nWe have all used print before, but this short article is about using the function to the max - it actually has a secret or two you might not know about.\nNote this article is about print - There are actually other useful functions for printing text in Swift (such as debugPrint), but this article is not about them.\nCustom Separators and Terminators The first small thing you can do with print is to change the default separators and terminators.\nSeparator In case you haven\u0026rsquo;t noticed, print takes a variable number of parameters as its first argument. You can use it to print multiple objects at once. For example:\nprint(1, 2, 3, 4) // prints // 1 2 3 4 By default, the separator is an empty space, but you can customize it to be anything else.\nprint(1, 2, 3, 4, separator: \u0026#34;,\u0026#34;) // prints // 1,2,3,4 Changing the separator can be useful, as we will see later on.\nTerminators By default, when print is done printing your text, it will append a newline character to each line, so further print sequences start on their own line.\nprint(1, 2, 3, 4) print(5, 6, 7, 8) This will print:\n1 2 3 4 5 6 7 8 We can provide any terminator we want:\nprint(1, 2, 3, 4, terminator: \u0026#34;|\u0026#34;) print(5, 6, 7, 8, terminator: \u0026#34;|\u0026#34;) 1 2 3 4|5 6 7 8| And of course, you can use a combination of both separator and terminator.\nprint(1, 2, 3, 4, separator: \u0026#34;,\u0026#34;, terminator: \u0026#34;|\u0026#34;) print(5, 6, 7, 8, separator: \u0026#34;,\u0026#34;, terminator: \u0026#34;|\u0026#34;) 1,2,3,4|5,6,7,8| Redirecting Output with the output: parameter The last thing I want to tell you about is probably my favorite print feature. By default, print sends all its output to the standard output, which is going to be Xcode\u0026rsquo;s console most of the time. But that doesn\u0026rsquo;t stop us from changing this and printing somewhere else. The last optional parameter we can pass in to print, is to output:, which is an inout parameter of an object that conforms to TextOutputStream.\nTextOutputStream has a single requirement you need to implement:\nmutating func write(_ string: String) { } As you can see, we need to implement a mutating func that will give us a string.\nThis is interesting, because there is actually a lot we can do here. you can continue sending text to the standard output after mutating it here (by simply calling print again), or you can redirect the output somewhere entirely different.\nTo show you content mutation, I will reuse the EmojiFormatter I wrote for my Writing Custom NSFormatters in Swift article. This formatter will find ASCII emoticons and convert them into emojis. For example, :-) will get converted into üôÇ.\nclass EmojiFormatter: Formatter { // MARK: - User facing methods public func rawString(for emojiString: String) -\u0026gt; String? { var formattedEmojiStringContainer: AnyObject? getObjectValue(\u0026amp;formattedEmojiStringContainer, for: emojiString, errorDescription: nil) return formattedEmojiStringContainer as? String } // MARK: - Emoji Mapping let emojiMapping = [ \u0026#34;:-)\u0026#34;: \u0026#34;üôÇ\u0026#34;, \u0026#34;:-|\u0026#34;: \u0026#34;üòê\u0026#34;, \u0026#34;:-(\u0026#34;: \u0026#34;‚òπÔ∏è\u0026#34;, \u0026#34;;-(\u0026#34;: \u0026#34;üò¢\u0026#34; ] func replaceAsciiWithEmoji(in string: String) -\u0026gt; String { var rawString = string emojiMapping.forEach { rawString = rawString.replacingOccurrences(of: $0, with: $1) } return rawString } func replaceEmojiWithAscii(in string: String) -\u0026gt; String { var rawString = string emojiMapping.forEach { rawString = rawString.replacingOccurrences(of: $1, with: $0) } return rawString } // MARK: - Overriden methods override func string(for obj: Any?) -\u0026gt; String? { if let string = obj as? String { return replaceAsciiWithEmoji(in: string) } return nil } override func getObjectValue(_ obj: AutoreleasingUnsafeMutablePointer\u0026lt;AnyObject?\u0026gt;?, for string: String, errorDescription error: AutoreleasingUnsafeMutablePointer\u0026lt;NSString?\u0026gt;?) -\u0026gt; Bool { obj?.pointee = replaceEmojiWithAscii(in: string) as AnyObject return true } } We will now create a simple TextOutputStream that will mutate our strings, replace some emojis and print them into the standard output:\nstruct EmojiLogger: TextOutputStream { let formatter = EmojiFormatter() mutating func write(_ string: String) { print(formatter.string(for: string)!) } } var logger = EmojiLogger() print(\u0026#34;Hi, I\u0026#39;m happy to meet you :-)\u0026#34;, to: \u0026amp;logger) This will print:\nHi, I\u0026#39;m happy to meet you üôÇ Of course, the true power of this is lies in the fact that we can make it do something entirely different. We could, for example, create a simple logging functionality where everything we print will be recorded on a file on disk.\nTo show you how this is done, I took a Logger class from StackOverflow (always take precautions when using third party code in your projects), and we are now going to integrate it into a FileLogger.\nclass Logger { static var logFile: URL? { guard let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return nil } let formatter = DateFormatter() formatter.dateFormat = \u0026#34;dd-MM-yyyy\u0026#34; let dateString = formatter.string(from: Date()) let fileName = \u0026#34;\\(dateString).log\u0026#34; return documentsDirectory.appendingPathComponent(fileName) } static func log(_ message: String) { guard let logFile = logFile else { return } let formatter = DateFormatter() formatter.dateFormat = \u0026#34;HH:mm:ss\u0026#34; let timestamp = formatter.string(from: Date()) guard let data = (timestamp + \u0026#34;: \u0026#34; + message + \u0026#34;\\n\u0026#34;).data(using: String.Encoding.utf8) else { return } if FileManager.default.fileExists(atPath: logFile.path) { if let fileHandle = try? FileHandle(forWritingTo: logFile) { fileHandle.seekToEndOfFile() fileHandle.write(data) fileHandle.closeFile() } } else { try? data.write(to: logFile, options: .atomicWrite) } } } The FileHandler implementation now looks like this:\nstruct FileLogger: TextOutputStream { func write(_ string: String) { Logger.log(string) } } var logger = FileLogger() print(\u0026#34;This is getting written to a file.\u0026#34;, to: \u0026amp;logger) The first thing you will notice is that once we run this, it will not print anything to the console. This is because, this time, we are redirecting the output of text to a completely different place. This is really neat, as it allows you to create custom print functions that you can choose where to send their output to, whether you want to keep default console printing on, and more.\nConclusion print can be more powerful than we give it credit here. It having a native way to let us customize or completely redirect output is nothing short of amazing. Using TextOutputStream, we can customize many aspects about our print calls.\n","tags":["swift","apple","programming"]},{"id":"81127dd66457e0f2c3751d9f7dceb866","title":"Raw Strings in Swift","link":"/posts/raw-strings-swift/","content":"We have all worked with strings before. Printing a piece of text, or displaying some information to users in a label, can all be done in strings. But regardless of how popular strings are, they actually have a lot of complex or unknown functionality that can help developers, but they struggle to see the light of day.\nIn this article, we will explore a very interesting aspect of strings in Swift: Raw Strings, what they are, and how they can be helpful to your every day job.\nIntroducing Raw Strings Raw strings (denoted by starting and ending pound symbols (#) before and after the quotation marks), allow us to create strings that will print exactly what you see. As you know, there are certain escape sequences that can make our strings print differently. For example, writing a \\n will cause your string to break your string in separate lines. If you want to actually print or use a \\ character, you need to write it twice. All this functionality of strings is there to help us create memorable text. But sometimes, this behavior if not wanted.\nConsider the following example:\nlet message = \u0026#34;Hey there cowboy! \\n In reverse land, the current date is 2020\\01\\10!\u0026#34; The first obvious problem is that your program won\u0026rsquo;t compile at all, because \\1 and \\0 are not valid escape sequences. If you want to get this to compile, you have to add an extra backslash to each existing one:\nlet message = \u0026#34;Hey there cowboy! \\n In reverse land, the current date is 2020\\\\01\\\\10!\u0026#34; This now compiles, and shall you print it you will get:\nHey there cowboy! In reverse land, the current date is 2020\\01\\10! This is all cool and dandy, but that extra backslash was just annoying. If we make this a raw string, it will prevent Swift from executing escape sequences:\nlet message = #\u0026#34;Hey there cowboy! \\n In reverse land, the current date is 2020\\01\\10!\u0026#34;# We now have a valid string whose escape sequences have not been executed. If you print the string you will get the following output:\nHey there cowboy! \\n In reverse land, the current date is 2020\\01\\10! We no longer need to escape our backslashes twice, but we have lost the line break, which you may have wanted. We have not lost completely the ability to use escape sequences. Instead, every backslash you use now, that you want to be executed as a escaping sequence, must be followed by a # and then the sequence you want to execute.\nlet message = #\u0026#34;Hey there cowboy! \\#n In reverse land, the current date is 2020\\01\\10!\u0026#34;# print(message) Hey there cowboy! In reverse land, the current date is 2020\\01\\10! This also means that if you intend to use string interpolation, you will need to follow the backslash with a pound.\nlet age = 29 let string2 = #\u0026#34;This year I turn \\(age) years old\u0026#34;# print(string) //... let string2 = #\u0026#34;This year I turn \\#(age) years old\u0026#34;# print(string2) This year I turn \\(age) years old // string This year I turn 29 years old // string2 Finally, you can also use raw strings with multiline strings.\nlet badPoem = #\u0026#34;\u0026#34;\u0026#34; This year \\ I shall turn \\ \\#(age) years old \u0026#34;\u0026#34;\u0026#34;# print(badPoem) This year \\ I shall turn \\ 29 years old Keep in mind that everything you can do with raw strings, can be done without, so this is not a mandatory tool in your toolbox, but it is nice to have, especially when working with Regex.\nConclusion Raw strings are useful and good to have in your toolbox. While most of its uses are not immediately visible, you will know when you can use them, so it\u0026rsquo;s good to keep them in mind.\n","tags":["swift","apple","programming"]},{"id":"17cd1049f1e24f1f215434c5217ddcb9","title":"JavaScriptCore and Swift","link":"/posts/javascriptcore-and-swift/","content":"JavaScriptCore and Swift\nRegardless how you feel about JavaScript as a programming language, there is one simple fact: JavaScript is pretty ubiquitous, and its uses have expanded beyond web scripting. It has become a pretty popular language for a vast array of domains. For this reason, making languages interoperate with it is pretty important, and both Swift and Objective-C are no exception. We can work with JavaScript, not only by executing JavaScript code directly from our Swift code, but we can even expose code from Swift and Objective-C to JavaScript. That\u0026rsquo;s how important this language is, and these features open a world of possibilities.\nJavaScriptCore will help us execute basic JavaScript code and export our Swift and Objective-C code to JavaScript. For the bunch of possibilities JavaScriptCore opens to us, it\u0026rsquo;s actually a very simple framework with only a few symbols. In this article we will explore some common tasks we may want to perform with this framework.\nExecuting JavaScript with JSContext The most basic thing we can do with the framework is hand it over some JavaScript, evaluate it, and return its value. For this, we use JSContext.\nlet context = JSContext() let sumValue = context?.evaluateScript(\u0026#34;1 + 2 + 3\u0026#34;) if let sum = sumValue?.toInt32() { print(\u0026#34;\\(sum)\u0026#34;) } JSContext is a JavaScript execution environment. It has some neat uses:\nEvaluate basic (or complex) JavaScript code from Swift or Objective-C. Make native Objective-C and Swift code available to JavaScript. After calling evaluateScript, we will receive a JSValue object back. We can then use JSValue to pass data between JavaScript and Swift/JavaScript. In the example above, we performed a simple addition, converted the result to an Int32, and printed it.\nJSContext has other interesting features as well. We can query the currently executing JSContext instance by calling the current() static method. We can even get the current callee by calling the currentCallee static method. Even more interesting we can get what \u0026ldquo;this\u0026rdquo; refers to by calling JSContext.currentThis. Finally, we can retrieve the current arguments by calling JSContext.currentArguments.\nJSVirtualMachine All JavaScript code execution has a JSVirtualMachine somewhere behind this scenes. We can use this class directly when we need to support concurrent JavaScript execution and to manage memory when bridging between JavaScript and Swift/Objective-C.\nEvery JSContext is associated to a JSVirtualMachine, which you can get by calling the virtualMachine property, although one virtual machine can contain multiple contexts. Each Virtual Machine is its own world and its own environment, so while contexts within the same virtual machine can see each other, contexts belonging to different virtual machines are not aware of each other.\nJavaScript is a concurrent affair. Any and all calls to JavaScript will be concurrent. If you need to execute JavaScript concurrently, simply create different JSVirtualMachine instances and execute them in different threads.\nExporting Swift to JavaScript. If we want our Swift (or Objective-C) objects to be available to JavaScript, we simply need to adopt the JSExport protocol. By adopting this protocol, we will be able to export our entire classes, instance methods, class methods, and properties to JavaScript. Many Foundation types automatically support this behavior, such as NSString.\nDiscussing JavaScript in-depth is not the topic of this article, so just be aware that in JavaScript, Object-Oriented Programming is supported through the use of Prototype Objects, and your own classes are exported to JavaScript as such.\n@objc class Doll: NSObject, JSExport { dynamic var name: String dynamic var maker: String dynamic var existence: Int init(name: String, maker: String, existence: Int) { self.name = name self.maker = maker self.existence = existence } let makeDoll: @convention(block) (String, String, Int) -\u0026gt; Doll = { name, maker, existence in return Doll(name: name, maker: maker, existence: existence) } } In order to export code to JavaScript, the first thing we need to keep in mind is that our objects must bridge to Objective-C - JavaScriptCore was introduced way before Swift was a thing. Second, we need to manually choose what properties and methods will be exported. In the case of properties, we need to provide a @convention(block) property that will bridge our code. This will export our functions with the right parameters and internally our Swift code will be called.\nFor properties, marking them as dynamic will ensure they are exported.\nFinally, we can pass it to JavaScript by calling the setObject(_:forKeyedSubscript) method.\ncontext?.setObject(Doll.self, forKeyedSubscript: \u0026#34;Doll\u0026#34;) Conclusion JavaScript is big, and due to its huge community support you can find a lot of libraries for it. You may come to a point in which it may be easier to use JavaScript than Native Swift to solve a particular problem. It\u0026rsquo;s also just a pretty cool feature in general that doesn\u0026rsquo;t hurt to have in your toolbox.\n","tags":["apple","swift","xcode","javascript","programming"]},{"id":"8c61657f262d3b87c7f2df8e2cd75cbc","title":"Xcode New File Templates","link":"/posts/xcode-new-file-templates/","content":"As you work on projects, you may notice that there\u0026rsquo;s one thing that can be really improved: Creating new files. Every single developer has gone to the File \u0026gt; New File screen on Xcode to create files before. Whether to create new view controllers, data models, or whatever else, it is one of the most common places you may use in your day to day life as an iOS developers.\nWhen you create a new file, chances are you have a template ready to work on top of rather than creating everything from scratch (unless, of course, you are creating a new empty file). Think about all the boilerplate that is ready for you when you create a new view controller. You don\u0026rsquo;t have to implement the most common or required method as the template will at the very least provide the declarations for you.\nIn this article, we will explore how we can tap into the power of Xcode templates by creating our own.\nTemplate Format Template are simple directory structures stored in the ~/Library/Developer/Xcode/Templates/File Templates/Custom Templates directory. This directory does not exist by default, so you will need to create it when you want to start using custom templates. Within this directory, you need more directories whose names will vary depending on the context of your template.\nThe next directory will be the platform name for which this template is available. Name it iOS to make it available on iOS.\nThe next directory is one of the four tabs at the top of the \u0026ldquo;New File\u0026rdquo; option.\nSo, if you want a User Interface template, name the directory User Interface. If you want a Source template, write Source.\nIn order to create a new template, create a new directory within that directory, give it the .xctemplate extension, and store the following files within:\nTemplateIcon.png/TemplateIcon@2x.png: Optional thumbnails that will be visible in the New File Xcode window. TemplateInfo.plist: Use this file to provide basic template information, such as a summary and a description. We will explore the basic configurations for this file, but whenever you are lost, you can take a look at one of Xcode\u0026rsquo;s provided templates (stored in /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File Templates) for inspiration. Base template file: This is the base template file. If you name it ___FILEBASENAME___.swift, the new file will have the same name the user entered in the New File window. We can force a suffix by adding anything after the last set of underscores __, like ___FILEBASENAME___Product.swift. If you were building UI templates, you could also provide ___FILEBASENAME___.storyboard and so forth. The fascinating thing about Xcode\u0026rsquo;s templates is that they can be very complex. If you browse the /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File Templates/Source/Cocoa Touch Class.xctemplate directory, you will see that, other than the files we mentioned above, it has many directories, each with multiple files. This is because when we use that template we can provide a Cocoa Touch class to subclass from. This example is overkill, so we will create something much simpler, but know you can reference it as your need for complex templates grows.\nIn this article we will create a template for Products, so, the full directory structure looks like this:\n~/Library/Developer/Xcode/Templates/File Templates/Custom Templates/iOS/Source/Product.xctemplate TemplateInfo.plist The TemplateInfo can be pretty wild. You will use it to define how simple or complex your template will end up being.\nThis is a simple starting point.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;SupportsSwiftPackage\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;Kind\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Xcode.IDEFoundation.TextSubstitutionFileTemplateKind\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Description\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;A Product subclass.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Summary\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;A product for representing items available in store.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;SortOrder\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;2\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;DefaultCompletionName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;MyProduct\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Platforms\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;com.apple.platform.iphoneos\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; The Description and Summary will be immediately visible, the other parameters will have other implications. For example, DefaultCompletionName will be the default name the file will be in the name field.\nWe are now going to create an options array on our template and this is where it gets interesting, because when the user creates the file, we can prompt a vast array of different options of different types. We can force those options to be mandatory or not.\nThe options consist of:\nIdentifier: A unique identifier for our option. We can later refer to the value of the option by referencing the identifier as a variable, like this: ___VARIABLE_productType___ Required: A boolean indicating whether this item should be mandatory or not. Description: A Description of the option (the the user sees) Type: The type of option this is. You can choose between checkbox, text, combo, static, or popup. Your plist should be looking like this:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;SupportsSwiftPackage\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;Kind\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Xcode.IDEFoundation.TextSubstitutionFileTemplateKind\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Description\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;A Product subclass.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Summary\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;A product for representing items available in store.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;SortOrder\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;2\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;DefaultCompletionName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;MyProduct\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Platforms\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;com.apple.platform.iphoneos\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;Options\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Identifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;productType\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Required\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;Name\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Product Type\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Description\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;New Product Prefix\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Type\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;text\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Not Persisted\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; You can provide an arbitrary number of options to make your templates flexible and configurable.\nWith this, we can provide a productType. But let\u0026rsquo;s make it more interesting so users can provide a bit more info.\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;SupportsSwiftPackage\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;Kind\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Xcode.IDEFoundation.TextSubstitutionFileTemplateKind\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Description\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;A Product subclass.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Summary\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;A product for representing items available in store.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;SortOrder\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;2\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;DefaultCompletionName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;MyProduct\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Platforms\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;com.apple.platform.iphoneos\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;Options\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Identifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;productName\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Required\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;Name\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Product Name\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Description\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;New Product Prefix\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Type\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;text\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Not Persisted\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Identifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;productType\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Required\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;Name\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Product Type\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Description\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;New Product Prefix\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Type\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;text\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;Not Persisted\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; Users can now provide a product type and a product name. Note that productName is a \u0026ldquo;special\u0026rdquo; variable Xcode will use to name the file itself, so think of it as a reversed variable. The prompt looks like this:\n![/img/](/new_file_prompt_template 2.png)\nBuilding the Template Our template will help users create subclasses of this class:\n/// This is an abstract class for all products. open class Product { public let name: String public let cost: Double public init(name: String, cost: Double) { self.name = name self.cost = cost } public func calculateTotalCost(itemQuantity: Int) -\u0026gt; Double { return cost * Double(itemQuantity) } public func itemsInStock() -\u0026gt; Int { fatalError(\u0026#34;Requires implementation\u0026#34;) } } ___FILEBASENAME___Product.swift:\nThis file has the Product suffix because we want all classes created with this template to be properly suffixed. If the product is Computer, we want its full name to be ComputerProduct.\nThe template is below:\n// ___FILEHEADER___ import Foundation class ___FILEBASENAME___Product: Product { let brand: String let productType = \u0026#34;___VARIABLE_productType___\u0026#34; init(name: String, cost: Double, brand: String) { self.brand = brand super.init(name: name, cost: cost) } override func itemsInStock() -\u0026gt; Int { \u0026lt;#Return the amount #\u0026gt; } } In this example we can appreciate a few things:\n___FILEHEADER___, which will autogenerate the default header for us. class ___FILEBASENAME___, so our class name can be ComputerProduct, or FruitProduct. You may be thinking that this is wrong and it should be ___FILEBASENAME___Product. This is not the case, because the filename on disk defines the ___FILEBASENAME___ variable in your template. ___VARIABLE_productType___, where we grab the value of the productType identifier in the plist. \u0026lt;#Return the amount #\u0026gt;, we can use code placeholders normally. Conclusion You can download this sample template here.\nThe Templates feature is incredibly complete and it can look intimidating, but it\u0026rsquo;s really powerful when you understand how it works. Creating templates for common files you create can save you a lot of time, although the initial configuration can take a while. I recommend you invest the time into learning how to create your own File Templates (fun fact - you can even create your own Project Templates) if you find yourself doing a lot of repetitive work that can\u0026rsquo;t be easily abstracted.\n","tags":["apple","swift","xcode","templates","programming"]},{"id":"b7086b46d9c649414e85a5bbe47569a3","title":"Using NSMeasurement For Working with Dimensions and Units","link":"/posts/using-nsmeasurement-for-working-with-dimensions-and-units/","content":"Software development can be an easy thing, as it can be a very complex thing. And one of those complex things is keeping in mind all the different languages, locations, and standards users may use in their daily lives. This makes working with certain information. From different date formats to entirely different measuring system, software is challenging, especially when working with anything that requires localization. The situation is just so bad that a lot of software just make assumptions about their users environment and don\u0026rsquo;t let you change any settings.\nFor many localization needs, we can make use of NSFormatter. When it comes to dealing with different units for any daily-life measurement - speed, weight, area, acceleration, etc -, we can make use of NSMeasurement. Introduced in iOS 10, this class and its friend, NSMeasurementFormatter, allow us to work with different units in any system, perform calculation with them, and ultimately display them to our users.\nIn this article, we will explore how NSMeasurement works, and how to pair it NSMeasurementFormatter so users using your app can always expect to see their preferred units in your app.\nDimension and Units are Everywhere If you thought these APIs were useful only for writing unit converter apps, I got some rough news for you. Units are actually used in many, many places. All the way from measuring time to the length of an object, users have apps that keep track of this data without thinking about it.\nFor this reason, it is important to work correctly with units, because they can show app even in shopping list apps, and even games. One particular annoying thing from my childhood - although very minor - was playing Need for Speed and only seeing the units in Imperial units when that\u0026rsquo;s not what I use. It did help me to learn and understand different countries and people use different units for something I had for granted, but that\u0026rsquo;s not what I wanted when I wanted my shiny new car to win races are escape the scope in Need for Speed: Most Wanted.\nIn the same vein, if you took a physics class in school and you studied in the United States, you may remember the fun times you had to convert between units all the time because science uses metric.\nWhat I\u0026rsquo;m trying to tell you here is that even games can make good use of operating on generic units and presenting them to your users in the way they expect. The need for displaying the right units is basically everywhere.\nSupported Units Enough chatter for now, and let\u0026rsquo;s get into the point of the article.\nThe need for units is so important that NSMeasurement supports many of them, including ones you may have never heard of.\nFor the common uses, you can work with length, mass, duration, acceleration, and many more. Trying to cover them all would probably require a small book, so I will only use examples that uses dimensions we are all familiar with. If you want a more complete reference, take a look at the Dimension docs. This page also lists the base unit for each.\nIt\u0026rsquo;s worth noting that the base units for dimensions appear to prefer metric units, so the base unit for length is meters; the base unit for mass is kilograms; the base unit for duration is seconds, and the base unit for acceleration is m/s^2.\nSample Units To create a NSMeasurement, you need to provide it with value and a unit.\nlet weight = Measurement(value: 2.0, unit: UnitMass.kilograms) One of the beauties of this API is that you can create any measurement in any compatible unit and operate on them. In the example below, we will add a weight in kilograms and another one in grams:\nlet weight = Measurement(value: 2.0, unit: UnitMass.kilograms) let weightInGrams = Measurement(value: 1500, unit: UnitMass.grams) print(weight + weightInGrams) The API will convert the result to the base units before showing the result. This, this will print 3.5 kg.\nAnd don\u0026rsquo;t worry about adding incompatible types. If you try to add different dimensional units, the generic will protect you at compile time.\nlet weight = Measurement(value: 2.0, unit: UnitMass.kilograms) let speed = Measurement(value: 1000, unit: UnitSpeed.kilometersPerHour) print(weight + speed) // Won\u0026#39;t compile You can easily convert between different units by calling the converted(to:) method.\nlet weight = Measurement(value: 2.0, unit: UnitMass.kilograms) let weightInGrams = Measurement(value: 1500, unit: UnitMass.grams) let totalWeight = weight + weightInGrams let totalWeightInPounds = totalWeight.converted(to: .pounds) print(totalWeightInPounds) // prints \u0026#34;7.716185470643222 lb\u0026#34; Finally, you can actually compare between two NSMeasurement very easily using the standard operators you know.\nif weight \u0026gt; weightInGrams { print(\u0026#34;Got more in kgs\u0026#34;) } The amount of work this object does to help you work with units is nothing less than mind blowing.\nUsing NSMeasurementFormatter For User Facing Units Everything we did so far is great if we don\u0026rsquo;t need to show anything to the user. While printing to the console does append a measurement, the right way to show users a value is by using a formatter.\nThe formatter will do more than just displaying the value correctly to the user. You can configure it with many more parameters.\nI will force the locale to use a metric system instead of Imperial, as that makes more sense to me (my simulator is set in the USA and therefore the formatter uses Imperial units). I can do this by setting the locale of the formatter.\nlet formatter = MeasurementFormatter() formatter.locale = Locale(identifier: \u0026#34;es_BO\u0026#34;) Some Formatter Configs unitOptions If you set the unitOptions (UnitOptions), you can choose the behavior of what to do with the provided unit. If you use .providedUnit, the formatter will format and display the measurement with the unit you used to create it.\nlet weightInGrams = Measurement(value: 1500, unit: UnitMass.grams) let formatter = MeasurementFormatter() formatter.locale = Locale(identifier: \u0026#34;es_BO\u0026#34;) formatter.unitOptions = .providedUnit; print(formatter.string(from: weightInGrams)) // prints \u0026#34;1,500 g\u0026#34; Using .naturalScale will cause the value to be formatted into a \u0026ldquo;bigger\u0026rdquo; unit if possible. For example, if you have a measurement in grams, that can be represented into kilograms, the formatter will do that conversion for you.\nlet weightInGrams = Measurement(value: 1500, unit: UnitMass.grams) let formatter = MeasurementFormatter() formatter.locale = Locale(identifier: \u0026#34;es_BO\u0026#34;) formatter.unitOptions = .naturalScale print(formatter.string(from: weightInGrams)) // prints \u0026#34;1,5 kg\u0026#34; (note that in Bolivia we use a comma to separate decimals, not thousands). unitStyle Setting the unitStyle (UnitStyle) will change how the unit is spelled out.\n// 1,5 kilogramos formatter.unitStyle = .long // 1,5 kg formatter.unitStyle = .medium // 1,5kg formatter.unitStyle = .short I have willingly left my country\u0026rsquo;s units there as they perfectly show why using a formatter and the right unit for users is important.\nNumberFormatter You can pass an entire NSNumberFormatter to choose how your number will be formatted. This is useful if your locale settings don\u0026rsquo;t cover very specific cases or personal user preference.\nA particular preference for me is that I don\u0026rsquo;t use commas for decimals like we do in my country. I like using periods instead, so I can keep using my locale and just set the decimal separator by setting the numberFormatter\nformatter.unitStyle = .short formatter.numberFormatter.decimalSeparator = \u0026#34;.\u0026#34; print(formatter.string(from: weightInGrams)) // prints 1.5kg Conclusion Once again we find ourselves talking about formatters, but this time with measurements included. Many people have different uses for measurements and despite locale expectations, users may need to work with units differently. NSMeasurement and NSMeasurementFormatter provide us with many tools to quickly work with different units, all the way from operations to displaying them, in a quick and efficient manner.\n","tags":["nsformatter","swift","programming","apple","ios","ipados"]},{"id":"dfb6c960d73c256c6d90a4950c49ec3a","title":"Using CoreLocation With SwiftUI","link":"/posts/using-corelocation-with-swiftui/","content":"SwiftUI forces us to change our way of thinking when building iOS apps. It makes us change from writing our apps in MVC to MVVM.\nIn this article, we will explore how SwiftUI can be used with certain frameworks that aren\u0026rsquo;t \u0026ldquo;SwiftUI ready\u0026rdquo;. While this article uses CoreLocation as an example, keep in mind that you can use what you learn from this to integrate almost any other framework with SwiftUI, whether it is provided by Apple or not.\nUnderstanding the Complexities If you have tried to use SwiftUI with CoreLocation or similar frameworks that make use of a delegate, you may have found it to be very hard. Specifically, you may have found it that your core locations keep getting called over and over again with no clear reason.\nOne thing to keep in mind is that SwiftUI continuously creates and destroys views. When there is a state change, all views depending on it will be destroyed and recreated. This happens quite aggressively throughout the lifecycle of our SwiftUI apps.\nTo workaround this, SwiftUI provides us with specific property wrappers that store their values somewhere else rather than on the views directly. Two of such wrappers are @StateObject and @ObservedObject. What we need to do is to create a ViewModel that conforms to ObservableObject, and store all the relevant state there.\nWriting the ViewModel We will create our view model for one view. This ViewModel will be responsible for receiving core location events. In turn, our ViewModel will expose @Published properties that our Views can observe and update accordingly.\nWe will start with a very barebones implementation, and we will call it LocationViewModel.\nclass LocationViewModel: NSObject, ObservableObject, CLLocationManagerDelegate { @Published var authorizationStatus: CLAuthorizationStatus private let locationManager: CLLocationManager override init() { locationManager = CLLocationManager() authorizationStatus = locationManager.authorizationStatus super.init() locationManager.delegate = self locationManager.desiredAccuracy = kCLLocationAccuracyBest locationManager.startUpdatingLocation() } } For now, we will just expose the authorizationStatus as a @Published property. We will use this to manipulate our View depending on the authorization status.\nI have written this tiny view to deal with the authorization status for location.\nIf you are following along, feel free to use this starting code.\nstruct ContentView: View { @StateObject var locationViewModel = LocationViewModel() var body: some View { switch locationViewModel.authorizationStatus { case .notDetermined: AnyView(RequestLocationView()) .environmentObject(locationViewModel) case .restricted: ErrorView(errorText: \u0026#34;Location use is restricted.\u0026#34;) case .denied: ErrorView(errorText: \u0026#34;The app does not have location permissions. Please enable them in settings.\u0026#34;) case .authorizedAlways, .authorizedWhenInUse: TrackingView() .environmentObject(locationViewModel) default: Text(\u0026#34;Unexpected status\u0026#34;) } } } struct RequestLocationView: View { @EnvironmentObject var locationViewModel: LocationViewModel var body: some View { VStack { Image(systemName: \u0026#34;location.circle\u0026#34;) .resizable() .frame(width: 100, height: 100, alignment: .center) .foregroundColor(/*@START_MENU_TOKEN@*/.blue/*@END_MENU_TOKEN@*/) Button(action: { print(\u0026#34;allowing perms\u0026#34;) }, label: { Label(\u0026#34;Allow tracking\u0026#34;, systemImage: \u0026#34;location\u0026#34;) }) .padding(10) .foregroundColor(.white) .background(Color.blue) .clipShape(RoundedRectangle(cornerRadius: 8)) Text(\u0026#34;We need your permission to track you.\u0026#34;) .foregroundColor(.gray) .font(.caption) } } } struct ErrorView: View { var errorText: String var body: some View { VStack { Image(systemName: \u0026#34;xmark.octagon\u0026#34;) .resizable() .frame(width: 100, height: 100, alignment: .center) Text(errorText) } .padding() .foregroundColor(.white) .background(Color.red) } } struct TrackingView: View { @EnvironmentObject var locationViewModel: LocationViewModel var body: some View { Text(\u0026#34;Thanks!\u0026#34;) } } Requesting Permission One important thing to always remember is that SwiftUI is all about updating state. So our ViewModel should update the variables our View is observing. It is not the case with CoreLocation, but for frameworks that have an asynchronous way to request permission, your ViewModel should handle all the asynchronous tasks and simply update state variables when it\u0026rsquo;s done.\nTo request location access, start by adding these two methods to LocationViewModel:\nfunc requestPermission() { locationManager.requestWhenInUseAuthorization() } func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) { authorizationStatus = manager.authorizationStatus } Next, our Views should call requestPermission. It is perfectly acceptable to do this as a call to onAppear, but in this specific example we are prompting our user to tap a button, so we will call it as a response to a button action.\nIf you are following my code, cmd + f the word allowing perms and replace that print call with locationViewModel.requestPermission().\nButton(action: { locationViewModel.requestPermission() }, label: { Label(\u0026#34;Allow tracking\u0026#34;, systemImage: \u0026#34;location\u0026#34;) }) Now, when users tap our Allow tracking button, they will see the system prompt asking for permission. At this point, your plist file needs to be properly setup, so don\u0026rsquo;t forget to add the NSLocationWhenInUseUsageDescription key to it with a string explanation your user why they need to grant you permission.\nIf you deny it, the view will automatically show the view explaining them the error. As you can see, this happens as soon as you tap a button on the system prompt. The delegate call, locationManagerDidChangeAuthorization(_ manager: CLLocationManager), updates our @Published variable, which, since our View is updating, results in our view being rebuilt.\nIf you then change the permission in Settings to something else, the view will be rebuilt next time you launch the app. (Note: for some reason, the simulator was not showing my app in Settings, this may also happen to you).\nFor now, if you are running this code in the simulator, you can reset the permission settings running the following command on your Terminal, as explained in my Getting to Know the Simulator Better article:\nxcrun simctl privacy booted reset all Next time you relaunch the app, the permission will be reset and you will be able to see the prompt again.\nWhen you see the prompt, give the app permission. You will simply see a text that says \u0026ldquo;Thanks!\u0026rdquo;, but we will implement the rest of the logic there now. We are not going to do anything complex, for now will just show some text with GPS data.\nShowing Coordinates Now that you have implemented the permission, implementing other methods is exactly the same thing. To show the coordinates in real time, create a @Published property in your ViewModel where you will store the CLLocation objects, and simply read them in your view.\n@Published var lastSeenLocation: CLLocation? @Published var currentPlacemark: CLPlacemark? // ... // Methods func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { lastSeenLocation = locations.first fetchCountryAndCity(for: locations.first) } func fetchCountryAndCity(for location: CLLocation?) { guard let location = location else { return } let geocoder = CLGeocoder() geocoder.reverseGeocodeLocation(location) { (placemarks, error) in self.currentPlacemark = placemarks?.first } } Then we can update TrackingView to show some data and update it in real time as we move around:\nstruct TrackingView: View { @EnvironmentObject var locationViewModel: LocationViewModel var body: some View { VStack { VStack { PairView( leftText: \u0026#34;Latitude:\u0026#34;, rightText: String(coordinate?.latitude ?? 0) ) PairView( leftText: \u0026#34;Longitude:\u0026#34;, rightText: String(coordinate?.longitude ?? 0) ) PairView( leftText: \u0026#34;Altitude\u0026#34;, rightText: String(locationViewModel.lastSeenLocation?.altitude ?? 0) ) PairView( leftText: \u0026#34;Speed\u0026#34;, rightText: String(locationViewModel.lastSeenLocation?.speed ?? 0) ) PairView( leftText: \u0026#34;Country\u0026#34;, rightText: locationViewModel.currentPlacemark?.country ?? \u0026#34;\u0026#34; ) PairView(leftText: \u0026#34;City\u0026#34;, rightText: locationViewModel.currentPlacemark?.administrativeArea ?? \u0026#34;\u0026#34; ) } .padding() } } var coordinate: CLLocationCoordinate2D? { locationViewModel.lastSeenLocation?.coordinate } } As you move around, the coordinates, your speed, and altitude will update in real time through the ViewModel.\nThe code that gets the city name and country - fetchCountryAndCity is an asynchronous bit of code. I included it to show you that it doesn\u0026rsquo;t really matter if the code is asynchronous, code-based, delegate based, or anything else. It all boils down to understanding how to separate your code from your View into a ViewModel. Avoid using asynchronous code in your views directly, and always use them in a view model instead.\nThe final product looks like this (I have manually censored it to avoid giving information about my current location):\nThe completed sample projected can be downloaded from here.\nConclusion SwiftUI forces us to think differently. In this article we explored how we can integrate CoreLocation with SwiftUI, but what we learned here can be used with other frameworks that are either delegate or closure based. Keep this in mind when you want to interact with other frameworks (CoreBluetooth, photo, etc).\nThe most important takeaway from this article is learn and understand when to use a ViewModel. If you are able to grasp the contents of this article, you will be able to integrate anything else (including Firebase!) in SwiftUI.\n","tags":["apple","swift","programming","swiftui","ios"]},{"id":"e945c6a5e595509164989b739341e043","title":"Getting to Know the Simulator Better","link":"/posts/getting-to-know-the-simulator-better/","content":"Every iOS developer has used the simulator. Alongside Xcode, it\u0026rsquo;s probably one of the most used tool by us all. We use the simulator to test our iOS, iPadOS, and watchOS apps without having to run them in an iOS device.\nBut other than helping us test our apps, the simulator actually has many nice features that can help make our job a little bit easier. With the use of these features we can avoid using physical devices until it\u0026rsquo;s time to do an actual test run or one.\nIn this article, we will explore the Simulator features provided to us by Xcode and the xcrun simctl tool.\nsimctl Basics Before we get into the good stuff, let\u0026rsquo;s explore some basic functionality offered by simctl. You can, after all, use this to write some automation for your work with the simulator and it can save you some trips to Xcode\u0026rsquo;s GUI.\nListing Simulator Devices You can list the available simulator runtimes by simply running the list subcommand.\nxcrun simctl list This will print a lot of stuff, but among the data, you will find the name of the emulated device and the OS version is currently emulating.\n== Devices == -- iOS 13.2 -- iPad Pro (9.7-inch) (5FB75994-26F5-4455-80E7-14D00CBACA81) (Shutdown) iPad (7th generation) (7055FC4A-DC49-433B-8005-13E9AC2CDCF7) (Shutdown) iPad Pro (11-inch) (1st generation) (8D50B34C-FABE-41D0-807E-6AB5CAD73E41) (Shutdown) iPad Pro (12.9-inch) (3rd generation) (FD578FA9-987A-40A9-8317-695E40D2D52C) (Shutdown) -- iOS 14.4 -- iPhone 11 Pro Max (0DD83491-914D-4EB9-9B8A-00A3191199B7) (Shutdown) iPhone SE (2nd generation) (9C8A6939-9AC5-4D7D-AA46-9E8DA7F22725) (Shutdown) iPhone 12 mini (0F59FD9B-DC0C-4812-99EF-E88236667AB9) (Booted) iPhone 12 (31891A98-684F-4C82-9767-EF09FD91F678) (Shutdown) It even lists device pairs, which are used when you are working with an Apple Watch companion app to your iPhone app:\n== Device Pairs == 3A322BC4-879B-49B8-B60D-6C7647B2C567 (active, disconnected) Watch: Apple Watch Series 5 - 40mm (000B4763-2096-434E-97E4-74154DD72B4E) (Shutdown) Phone: iPhone 12 mini (0F59FD9B-DC0C-4812-99EF-E88236667AB9) (Booted) AFB5C78F-8C41-4851-98F7-39D5A49F8E5C (active, disconnected) Watch: Apple Watch Series 5 - 44mm (EF2AD5C2-16B5-41D9-AE75-3EE657F0630F) (Shutdown) Phone: iPhone 12 (31891A98-684F-4C82-9767-EF09FD91F678) (Shutdown) All the devices have a unique (UUID) identifier associated to them. When using simctl, you specify the UUID you want the command to act upon.\nBooting Devices Use xcrun simctl boot YOUR_UUID_ID to boot a device.\nHere, I\u0026rsquo;m booting my iPhone 11 Pro Max simulator running iOS 14.4.\nxcrun simctl boot 0DD83491-914D-4EB9-9B8A-00A3191199B7 Note that this command will send the boot up signal to the simulator and return immediately return. In other words, there\u0026rsquo;s no way to \u0026ldquo;wait\u0026rdquo; until the device is ready for use and is fully booted up.\nEarlier, we said that simctl takes an UUID on its commands. After a device is booted, you can pass in the word booted instead of the UUID and the simulator will automatically choose the currently booted device to execute the commands on. If you are running multiple simulators and you pass in booted, the command line tool will select one of the booted simulators, so if you have multiple simulators open, it\u0026rsquo;s best to keep passing the respective UUIDs.\nOnce a simulator is booted, their status on simctl list will change to (Booted) instead of (Shutdown).\n-- iOS 14.4 -- iPhone 7 (4C1A1BE4-82D0-428F-9B22-0CC1FC776821) (Shutdown) iPhone 8 (4A3B434B-1EAA-4D30-BD4C-4C03906CA6E6) (Shutdown) iPhone 8 Plus (1A3195D3-2557-4B8C-85C8-C6C49E0350BC) (Shutdown) iPhone 11 (03BBFEB2-7DCB-41D1-A49D-18AB55AB3C0F) (Shutdown) iPhone 11 Pro (726B8086-CBF5-4FE4-B0BB-DFE2100D95F0) (Shutdown) iPhone 11 Pro Max (0DD83491-914D-4EB9-9B8A-00A3191199B7) (Booted) \u0026lt;-------- This is just bash, so you can combine other shell commands through piping. For example, we can choose to list only the devices that are currently booted:\nxcrun simctl list | grep \u0026#34;(Booted)\u0026#34; iPhone 11 Pro Max (0DD83491-914D-4EB9-9B8A-00A3191199B7) (Booted) iPhone 12 mini (0F59FD9B-DC0C-4812-99EF-E88236667AB9) (Booted) simctl with JSON You can make the list and other subcommands print in json by adding the --json (-j for short) flag.\nxcrun simctl list --json \u0026#34;runtimes\u0026#34; : [ { \u0026#34;bundlePath\u0026#34; : \u0026#34;\\/Library\\/Developer\\/CoreSimulator\\/Profiles\\/Runtimes\\/iOS 13.2.simruntime\u0026#34;, \u0026#34;buildversion\u0026#34; : \u0026#34;17B102\u0026#34;, \u0026#34;runtimeRoot\u0026#34; : \u0026#34;\\/Library\\/Developer\\/CoreSimulator\\/Profiles\\/Runtimes\\/iOS 13.2.simruntime\\/Contents\\/Resources\\/RuntimeRoot\u0026#34;, \u0026#34;identifier\u0026#34; : \u0026#34;com.apple.CoreSimulator.SimRuntime.iOS-13-2\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;13.2.2\u0026#34;, \u0026#34;isAvailable\u0026#34; : true, \u0026#34;name\u0026#34; : \u0026#34;iOS 13.2\u0026#34; }, { \u0026#34;bundlePath\u0026#34; : \u0026#34;\\/Applications\\/Xcode.app\\/Contents\\/Developer\\/Platforms\\/iPhoneOS.platform\\/Library\\/Developer\\/CoreSimulator\\/Profiles\\/Runtimes\\/iOS.simruntime\u0026#34;, \u0026#34;buildversion\u0026#34; : \u0026#34;18D46\u0026#34;, \u0026#34;runtimeRoot\u0026#34; : \u0026#34;\\/Applications\\/Xcode.app\\/Contents\\/Developer\\/Platforms\\/iPhoneOS.platform\\/Library\\/Developer\\/CoreSimulator\\/Profiles\\/Runtimes\\/iOS.simruntime\\/Contents\\/Resources\\/RuntimeRoot\u0026#34;, \u0026#34;identifier\u0026#34; : \u0026#34;com.apple.CoreSimulator.SimRuntime.iOS-14-4\u0026#34;, \u0026#34;version\u0026#34; : \u0026#34;14.4\u0026#34;, \u0026#34;isAvailable\u0026#34; : true, \u0026#34;name\u0026#34; : \u0026#34;iOS 14.4\u0026#34; }, Shutting Down And Clearing Simulators You can close all simulators and even clear their contents and settings with two simple commands:\nxcrun simctl shutdown SIMULATOR_UUID xcrun simctl erase SIMULATOR_UUID Opening URLs in the Simulator If you have been using Safari to try out your custom URL schemes, you can stop doing that now. There is a command that will prompt the simulator to open a URL and it will route the request to the appropriate app.\nxcrun simctl openurl (SIMULATOR_UUID|booted) maps:// This is not limited to schemes, as it can open normal HTTP links as well in the default browser.\nxcrun simctl openurl (SIMULATOR_UUID|booted) \u0026#34;https://www.andyibanez.com\u0026#34; Screenshots and Videos You can take screenshots from the simulator in two ways:\nPress Cmd + S Using the xcrun simctl io SIMULATOR_UUID|booted screenshot FILE_NAME.png You can also record video with the following command:\nxcrun simctl io booted SIMULATOR_UUID|booted recordVideo FILE_NAME.mp4 This will begin recording indefinitely. Press Ctrl + C on the console when you are done recording, and the video will be saved on your Mac.\nYou can pass in some additional flags to recordVideo. We can, for example, change the codec altogether and even the device mask.\nxcrun simctl io booted recordVideo --codec h264 --mask ignored myVid.mp4 Capturing Video on External Displays The simulator can simulate external displays. If your app supports them, you can choose whether to capture from the main device or an external device.\nTo quickly test this, we can use the Photos app.[^]\nGo to I/O \u0026gt; External Displays on the Simulator menu to explore the different options you have.\nAdding Media to the Photos.app There\u0026rsquo;s two ways you can add media to the Photos.app\nThe first one is the following command:\nxcrun simctl addmedia SIMULATOR_UUID|booted ~/path/to/file/pic.jpg This is a great way to script and automate the addition of new media.\nBut if you just need to quickly add media to the simulator, you can now simply drag and drop the media from anywhere in your Mac to the simulator.\nTo capture from an external display:\nxcrun simctl io booted recordVideo --display external externalVid.mp4 Privacy As you know, on iOS we don\u0026rsquo;t have free access to all the areas on the operating system as Apple takes user privacy very seriously. Instead, when an app needs access to data deemed private, the user will see a prompt asking them if it\u0026rsquo;s OK to grant your app that data. This data includes, but is not limited to, contacts, calendar, and health.\nWe can quickly grant access to this personal data on the simulator to your app by running:\nxcrun simctl privacy SIMULATOR_UUID|booted grant APP_NAME YOUR_APP_BUNDLE_ID Where:\nAPP_NAME is the name of the data with private data you want to access, such as contacts, calendar, health, wallet, and more. If you want to grant access to everything, you can simply write all. YOUR_APP_BUNDLE_ID is the bundle ID of the app that will have access to this data. Granting and revoking is equally easy. To revoke permissions, replace grant with revoke in the command above.\nOn iOS, permissions normally have three states: undefined, granted, and denied. The prompt is shown only when the state is undefined. After a user grants or denies a permission, the prompt will show.\nYou can reset all the permission settings to the \u0026ldquo;undefined\u0026rdquo; state and force the system to show a prompt for your app by running:\nxcrun simctl privacy SIMULATOR_UUID|booted reset all Just like above, you can replace all with specific apps.\nDevice Specific Features iPadOS The iPadOS simulator allows you to test the mouse integration with your app. By clicking the \u0026ldquo;Capture Pointer\u0026rdquo; button on the simulator, you will be able to simulate using a mouse in your app:\nWhen you want to exit, press the Esc key.\nA lot of this is actually customizable. If you need to do something with the Esc key on your iPadOS app, you can configure a different key to stop capturing your mouse. For this, go to Simulator \u0026gt; Preferences and choosing another option for Stop capture shortcut.\nNewly-added Features on iOS 14. Xcode 12 and iOS 14 and the rest of the OS family bring a few new features to the simulator, most notably:\nCreating new Simulators without Xcode You can go to File \u0026gt; New Simulator... to create a new simulator quickly and painlessly. You will be asked for a name, type, and OS version.\nPush Notifications New (and very exciting) to Xcode 12, we can send push notifications to the simulator without having to use a server.\nTo trigger the notifications, you can do it in two ways:\nWith the simctl push command: xcrun simctl push SIMULATOR_ID|booted YOUR_APP_BUNDLE_ID PAYLOAD_JSON_FILE.json You must specify the bundle ID of your app in order for the command to know what App triggered the request.\nThe PAYLOAD_JSON_FILE.json parameter is a file that contains a JSON in the same format as push notifications.\nIt looks like this:\n{ \u0026#34;aps\u0026#34; : { \u0026#34;badge\u0026#34; : 1, \u0026#34;alert\u0026#34; : { \u0026#34;title\u0026#34; : \u0026#34;New Message\u0026#34;, \u0026#34;body\u0026#34; : \u0026#34;Sakura: Hey I just captured a new card!\u0026#34; } } } This is a simple payload you can use, but Apple documents all the possible fields here.\nModifying the Status Bar. With the simulator, we can even modify the status bar. This is useful when preparing screenshots for the App Store or other marketing material. You may know Apple always show 9:41 in all its screenshots when the status bar clock is visible - this is because the first iPhone was shown to the world for the first time at this time.\nBut that\u0026rsquo;s not all, you can also make it show full signal, full battery, full Wi-Fi bars, or customize any of these parameters to your liking.\nSimply run the status_bar subcommand with any or all of the following flags:\nxcrun simctl status_bar booted override --time 07:00 --cellularBars 3 --dataNetwork LTE --wifiMode failed If you need to override these settings, simply run:\nxcrun simctl status_bar booted clear If you run the status_bar subcommand without any arguments, you will be able to see all the possible flags you can modify. It\u0026rsquo;s very powerful and flexible, as you can even modify the operatorName:\nxcrun simctl status_bar At the time of this writing, this printed:\nSet or clear status bar overrides Usage: simctl status_bar \u0026lt;device\u0026gt; [list | clear | override \u0026lt;override arguments\u0026gt;] Supported Operations: list List existing overrides. clear Clear all existing status bar overrides. override \u0026lt;override arguments\u0026gt; Set status bar override values, according to these flags. You may specify any combination of these flags (at least one is required): --time \u0026lt;string\u0026gt; Set the date or time to a fixed value. If the string is a valid ISO date string it will also set the date on relevant devices. --dataNetwork \u0026lt;dataNetworkType\u0026gt; If specified must be one of \u0026#39;wifi\u0026#39;, \u0026#39;3g\u0026#39;, \u0026#39;4g\u0026#39;, \u0026#39;lte\u0026#39;, \u0026#39;lte-a\u0026#39;, or \u0026#39;lte+\u0026#39;. --wifiMode \u0026lt;mode\u0026gt; If specified must be one of \u0026#39;searching\u0026#39;, \u0026#39;failed\u0026#39;, or \u0026#39;active\u0026#39;. --wifiBars \u0026lt;int\u0026gt; If specified must be 0-3. --cellularMode \u0026lt;mode\u0026gt; If specified must be one of \u0026#39;notSupported\u0026#39;, \u0026#39;searching\u0026#39;, \u0026#39;failed\u0026#39;, or \u0026#39;active\u0026#39;. --cellularBars \u0026lt;int\u0026gt; If specified must be 0-4. --operatorName \u0026lt;string\u0026gt; Set the cellular operator/carrier name. Use \u0026#39;\u0026#39; for the empty string. --batteryState \u0026lt;state\u0026gt; If specified must be one of \u0026#39;charging\u0026#39;, \u0026#39;charged\u0026#39;, or \u0026#39;discharging\u0026#39;. --batteryLevel \u0026lt;int\u0026gt; If specified must be 0-100. Keychain Management You can certificates to the device\u0026rsquo;s keychain with the keychain command:\nxcrun simctl keychain booted add-root-cert myCert.cer You can also simply drag and drop your certs.\nKeep in mind that you will have to trust the certificate manually, as neither of these options will do that for you.\n","tags":["apple","simulator","ios","ipados","watchos","tvos"]},{"id":"0ad0b962443e0ffc802132fe7f8100cd","title":"What I Learned From Selling an App","link":"/posts/what-i-learned-from-selling-an-app/","content":"What I Learned From Selling an App\nA few weeks ago, I sold and transferred my app, Next Anime Episode, to another developer.\nIn this article, I will discuss the reasons I transferred my app, and what I learned along the way in the process of transferring it.\nWhy I Sold My App As a developer who works a full time job and work on indie apps as a hobby, there are many ideas I want to work on. Having apps on the App Store is actually a really big responsibility. You have to maintain it and add features at least every so often to it in order to keep interested. If the app becomes popular enough, the pressure just grows, because you have to start dealing with negative reviews of all kinds. Sometimes justified, sometimes people don\u0026rsquo;t understand the purpose of your app, sometimes they just insult it and give no feedback whatsoever to improve it.\nThe mental strain grows.\nIf you are an indie dev with an app on the App Store, you know there\u0026rsquo;s a lot of implicit responsibility you have to take upon your shoulders. And eventually, you may come to realize you are just not as passionate about that project as you used to be when you first started it. You want to move on to other projects, and keep working on you career. It happens to all of us, and sometimes, we really just want to move on.\nI got lucky because I wasn\u0026rsquo;t actively trying to sell my app, but the offer landed on my lap and I heavily considered it. I pondered for weeks and I realized the best course of action was to hand over the app to someone who was going to maintain more often than me, fix bugs, add features, and overall, give users the treatment they deserve. I was only releasing about one update every 8 months on the app, and I sincerely thought users deserved better, so I handed it over.\nGoodbye, Small Developer Program My app wasn\u0026rsquo;t a one-million dollar idea. If anything I got much, much less than that. I am not going to disclosure the full amount, but I was going to make the amount I got from that sale in about five to seven years at the rate it was picking up this year. If you are an indie, you know we need to make $150 to get paid, and my app barely made one payment each year, so you can imagine that my sale wasn\u0026rsquo;t exactly gigantic.\nDespite how small the sale is, I got removed from the Small Business Problem as one of the conditions for staying on it are to not transfer an app. All my sales are going to give Apple a 30% commission for the rest of the year. I am hoping I will be able to apply to the program again so I can go back to the 15% rate (which I wasn\u0026rsquo;t able to enjoy).\nNot Keeping Analytics is a Double-Edged Sword. Because of all the privacy rules that are popping up all over the world (starting by the GRDP), and the fact I am a small indie developer as a hobby and not a lawyer, I take measures in my app to prevent getting into legal trouble for collecting data.\nSo first, I outright do not collect any data. None of my apps currently use any analytics frameworks of any kind. Despite how useful they are and they can be used without leaking user data, I decided to never use them.\nThese had two important implications in the sale of my app:\nBecause I do not collect any data on that app whatsoever, I did not have to do anything regarding disclosure of data transferring hands. Depending on the jurisdictions of your users, if their data is going to a new company, you are legally required to disclose that. My app interacted with an API, but there were never user accounts involved, and it simply performed HTTP requests. Not having any user data made the transfer easier in a way, so much to the point that, if my app was an app with user accounts and it did store user data in a server, I would not have sold it simply because I am not a lawyer and I do not know how to handle personal data switching hands. Before you transfer an app, you are required to remove all TestFlight testers, so the new owners do not even get that. This is the other side of the coin, but also not having analytics made the sale of the app a bit more complicated. When the potential buyers were appraising the app, they asked a lot of questions regarding analytics frameworks and the data I had. They wanted to have more detailed information over what Apple provides. Despite that, my app was climbing the ranks on its own, so it was clear to see it was doing well without any kind of analytics framework. Not Using Paid Services Makes Transfers Easier My app used a public API and nothing more. In the earlier versions, my app used a server with custom software in order to send notifications to users. After the API I was working with was upgraded to v2, their API started returning more data and the data I had was enough to queue the notifications locally. Not using any paid Push Notification Services helped me sell the app as that did not represent any ongoing costs to the new developers.\nNo Contracts Involved I have never sold an app before and I do not know how common it is these days, but I sold the app under no contracts whatsoever. Both the buyers and myself followed a series of steps to ensure we would all get what we wanted:\nI would transfer the app from App Store Connect. After transferring the app, they would make the deposit (international wire transfer) into my bank account. After I received the deposit, I sent the source code to the new developers. And that was it. If you have enough failsafes you can transfer your app risk-free. The people I sold the app to were trustworthy, but in retrospect, since there were no contracts involved, it probably would have been a good idea to add some sort of kill switch into the app in case they didn\u0026rsquo;t transfer the money and I never sent the source code. It\u0026rsquo;s probably better to sign some sort of contract, but my own experience was smooth.\nYou Will Always Receive Lowball Offers Be certain of the value of your app. Many offers can be lowball and if you are certain of the value of your product you can easily get much more than the original offer.\nEverything for the Road Ahead I have never sold an app before, and it did felt a little bit weird, perhaps nostalgic, having to sold something you wrote yourself like this. When I communicated these to my users, some told me the news were bittersweet, but overall they were excited I was going to be able to dedicate more times to other projects.\nOn the other hand, I am really happy I built something that someone else was interested in buying. It made me realize that what I was doing was really worth it, and I\u0026rsquo;m happy I was able to finish that sale.\n","tags":["apple","app transfer"]},{"id":"79a01f4728b276d86d445af5bcb266ea","title":"Multithreading Options on Apple Platforms","link":"/posts/multithreading-options-on-apple-platforms/","content":"We have reached the point in which computers are really fast. Especially Apple\u0026rsquo;s, as they have control of both the hardware and software, so, oftentimes, some tasks that could be sped up with multithreading, are not necessary anymore. But, for those cases when you do need multithreading, we have many options available.\nOn Apple\u0026rsquo;s platforms there is a surprising amount of concurrency tools. You are likely familiar with the most used one, the Grand Central Dispatch, DispatchQueue, which is pretty good and it covers the vast majority of use cases. But there are some tasks that can be done easier with other tools.\nIn this article, we will explore and introduce the concurrency options that we can use:\nThe NSOperationQueue APIs Grand Central Dispatch (GCD) NSThreads pthreads Along with a quick discussion on when you may prefer to use a tool over another tool.\nI have sorted the tools by their \u0026ldquo;level\u0026rdquo; in terms of high-level or low-level APIs, where the higher level ones show up first.\nThis article assumes you are familiar with concurrency and why it\u0026rsquo;s important in the context of iOS, macOS, watchOS, and tvOS apps.\nThe NSOperationQueue APIs NSOperation and its related APIs are actually one of my favorite set of tools we have for concurrency, not only on Apple\u0026rsquo;s platforms, but overall.\nThese APIs are very high level, and as such they offer us some features that don\u0026rsquo;t exist, or are harder to implement in other concurrency technologies.\nNSOperationQueue and co. allow us to easily set tasks that depend on others, so you can easily start a concurrent task after another concurrent task has finished. It also allows you easily cancel other tasks.\nYou submit operations to a NSOperationQueue in the form of blocks, so it even offers really high level syntax.\nI won\u0026rsquo;t be talking much about these APIs here - despite the fact that I love NSOperationQueue -, because I have dedicated a whole article to it which you can find here: Exploring the NSOperation APIs for Apple\u0026rsquo;s Platforms\nIn general, I like using these APIs when I have to setup dependencies between tasks and I want an easy way to cancel them. Think of an app that can batch-download pictures and apply a filter to them without freezing your main thread.\nThe Grand Central Dispatch Whether you know the Grand Central Dispatch (we will simply call it GCD from now on) by its name or not, you have undoubtedly used it in many of your apps, especially if you used Apple-provided APIs that return their result in a different thread (such as URLSession). Does this line look familiar to you?\nDispatchQueue.main.async { // Do something on the main thread } I\u0026rsquo;d be familiar if you never saw that particular line of code before.\nThe GCD is a set of concurrency APIs, developed by Apple themselves, which make it easy to support multi-core processors and other types of symmetric processing systems.\nI want you to pay particular attention to that definition, because the GCD was built for multi-core processors, not just Apple\u0026rsquo;s, and this is where one of its biggest advantages come into play. The GCD is actually open source, so if you learn to use it on Apple\u0026rsquo;s technologies, you are likely to find implementations of it on other entirely different platforms of all shapes and sizes, as long as they can run C, C++, Objective-C, or Swift.\nThe GCD is also a great little tool to make quick concurrent tasks easily, quickly, and without writing any ugly code. One of the most common uses for it among Apple platform developers is dispatching UI-updating tasks into the main thread after using asynchronous APIs such as URLSession.\nOne other common use is to delay the current execution of the thread for a definitive amount of time, which can sometimes be useful. In Swift in particular, this has a very nice syntax.\nDispatchQueue.main.asyncAfter(deadline: .now() + .seconds(5)) { // This will be executed in the main thread after five seconds. } The block above will execute some code in the .main thread after five seconds.\nAnother great feature of the GCD is that it allows us to specify the priority of each task when submitting them into a queue. This way we can help the queue execute important task fasters by providing a QOS (quality of service) parameter.\nDispatchQueue.global(qos: .userInteractive).async { // Any user-initiatied or user-interactive task has higher priority. } DispatchQueue.global(qos: .utility).async { // Tasks with uility QoS have lower priority. } The GCD provide us with a ready to use global queue where we can submit tasks to (and yes, you can create your own queues). There are multiple QoS flags you can provide depending on the perceived priority of the task:\n@available(macOS 10.10, iOS 8.0, *) case background @available(macOS 10.10, iOS 8.0, *) case utility @available(macOS 10.10, iOS 8.0, *) case `default` @available(macOS 10.10, iOS 8.0, *) case userInitiated @available(macOS 10.10, iOS 8.0, *) case userInteractive case unspecified In the future, I may write a dedicated article to the GCD. In the meantime, keep in mind the GCD is great to use when:\nYou need a quick way to \u0026ldquo;switch between\u0026rdquo; threads. You need to specify priorities in your tasks and you want the system to prioritize them depending on a QoS flag. You are potentially interested in using this amazing multithreading technology outside of Apple provided technologies. NSThreads and pthreads I\u0026rsquo;m lumping these two together because they are both really low level, they have much more flexibility, and because their application is very similar: When you need direct control over thread creation and concurrency.\nThe GCD and NSOperation APIs have one thing in common: They handle all the actual thread management for you. When you are working with the GCD and NSOperation APIs, the system will choose when to create threads, when to destroy, when to dispatch them, and even where to dispatch them - see, NSOperation is particularly smart, and it won\u0026rsquo;t actually do multithreading if it finds itself in a situation where not leaving the current thread is fine.\nSometimes though, computer smartness ain\u0026rsquo;t actually smart, and you may find yourself in situations (although very rarely) in which you just aren\u0026rsquo;t getting the behavior you want with the GCD or NSOperation*. For those cases, we can manually take control of threading with NSThreads and pthreads.\npthreads are the lowest-level APIs. They are POSIX threads, meaning you can create and use pthread in any POSIX system. They are implemented in pure C. I won\u0026rsquo;t be mentioning them much do their extremely niche use cases, but be aware they exist, and have the documentation shall you be the one in a million dev who needs to drop down to such levels.\nNSThreads, on the other hand, are bit more useful to most developers, even though they will not be touched by the vast majority of them. I think NSThreads have one particular advantage, and that is that the interface is very similar to Java threads. If you have worked with threads in Java, NSThread has a similar enough interface to make it easy to move among both languages. NSThread is a Foundation object, so it\u0026rsquo;s good to keep that in mind.\nUse NSThread when you need to have full control over concurrency, including thread creation and management (and as long as you are going to be responsible with your resource usage).\nNSThread docs\nConclusion Multithreading is complicated and to this day it is a hard problem to solve. Apple provides us with many options to deal with multithreading. NSOperation is great and high level, but GCD gets the job done very often. Balancing your options is important to become a better iOS developer.\n","tags":["swift","programming","apple","ios","macos","tvos","watchos","ipados","multithreading","nsoperation","gcd","grand central dispatch"]},{"id":"6c244cde2b48c3aefd13c9e12875e9bc","title":"OptionSet in Swift","link":"/posts/optionset-in-swift/","content":"Creating configurable APIs for other developers can be a fun task. But depending on what languages and tools you are using, you may sometimes create customizable APIs that are more pleasant than others.\nIn today\u0026rsquo;s article, we will explore a tiny feature in Swift that allows us to create configurable APIs easily that are a joy to use by other developers: OptionSet.\nIntroducing OptionSet Like its name implies, an OptionSet gives us a group of options. These options are pre-defined for our users, and when create an OptionSet, our users are constrained to using the values we are providing within.\nOptionSet Throughout Apple\u0026rsquo;s APIs We will create our own OptionSets soon, but before we do, let\u0026rsquo;s explore a few areas you may have seen them being used across Apple\u0026rsquo;s frameworks. It\u0026rsquo;s very likely you have used them without noticing it.\nNSJSONSerialization If you have been parsing JSON before Codable was a thing, it\u0026rsquo;s possible you have used the NSJSONSerialization object. For example, to create an object from Data:\nlet json = JSONSerialization.jsonObject(with: data, options: .allowFragments) Focusing on the options parameter (of type JSONSerialization.ReadingOptions), it is simply a struct with the following values:\npublic static var mutableContainers: JSONSerialization.ReadingOptions { get } public static var mutableLeaves: JSONSerialization.ReadingOptions { get } public static var fragmentsAllowed: JSONSerialization.ReadingOptions { get } @available(iOS, introduced: 5.0, deprecated: 100000, renamed: \u0026#34;JSONSerialization.ReadingOptions.fragmentsAllowed\u0026#34;) public static var allowFragments: JSONSerialization.ReadingOptions { get } The thing about OptionSet is that it can take either none, one, or many options. You may think, looking at the syntax, that it can only use one at a time (in the example above, we are using .allowFragments), but an option set can actually take multiple values if you pass in an array-like value.\nlet json = JSONSerialization.jsonObject(with: data, options: [.allowFragments, .mutableContainers, .mutableContainers]) Finally, if you don\u0026rsquo;t want to pass in any options, you need to specify an empty array.\nlet json = JSONSerialization.jsonObject(with: data, options: []) It\u0026rsquo;s hard to know at first glance if you are using an option set or just passing in some random enumerators, so the documentation across Apple\u0026rsquo;s frameworks will come in handy.\nCreating your own OptionSet Of course, OptionSets wouldn\u0026rsquo;t be half as interesting unless you were able to create your own.\nTo create your own option set, you need to conform to the OptionSet protocol and specify. The protocol will constrain you to requiring a rawValue property.\nstruct Currency: OptionSet { let rawValue: Int static let bolivianBoliviano = Currency(rawValue: 1 \u0026lt;\u0026lt; 0) static let argentinianPeso = Currency(rawValue: 1 \u0026lt;\u0026lt; 1) static let chileanPeso = Currency(rawValue: 1 \u0026lt;\u0026lt; 2) static let usd = Currency(rawValue: 1 \u0026lt;\u0026lt; 3) static let canadianDollar = Currency(rawValue: 1 \u0026lt;\u0026lt; 4) static let mexicanPeso = Currency(rawValue: 1 \u0026lt;\u0026lt; 5) } For the sake of efficiency, the raw value is an Int. These Ints are increasing in powers of 2, and library will internally optimize storage for the option set. If you try to use a different datatype for the raw value, you will likely encounter an error saying that your OptionSet must conform to SetAlgebra. We will explore SetAlgebra a little bit later.\nYou can even go ahead and create option combinations for popular options. In the example above, we can create groupings for South American currencies and North American currencies.\nstatic let southAmericanCurrencies: [Currency] = [.bolivianBoliviano, .argentinianPeso, .chileanPeso] static let northAmericanCurrencies: [Currency] = [.usd, .canadianDollar, .mexicanPeso] static let all: [Currency] = Self.southAmericanCurrencies + Self.northAmericanCurrencies The final declaration looks like this:\nstruct Currency: OptionSet { let rawValue: Int static let bolivianBoliviano = Currency(rawValue: 1 \u0026lt;\u0026lt; 0) static let argentinianPeso = Currency(rawValue: 1 \u0026lt;\u0026lt; 1) static let chileanPeso = Currency(rawValue: 1 \u0026lt;\u0026lt; 2) static let usd = Currency(rawValue: 1 \u0026lt;\u0026lt; 3) static let canadianDollar = Currency(rawValue: 1 \u0026lt;\u0026lt; 4) static let mexicanPeso = Currency(rawValue: 1 \u0026lt;\u0026lt; 5) static let southAmericanCurrencies: [Currency] = [.bolivianBoliviano, .argentinianPeso, .chileanPeso] static let northAmericanCurrencies: [Currency] = [.usd, .canadianDollar, .mexicanPeso] static let all: [Currency] = Self.southAmericanCurrencies + Self.northAmericanCurrencies } The Necessity of SetAlgebra If you tried making your OptionSet have a different raw value that isn\u0026rsquo;t an Int, you have likely found yourself being yelled at by the compiler for not conforming to SetAlgebra.\nIf you don\u0026rsquo;t understand the Set data structure found in Swift and virtually all common libraries of other languages, I recommend you read my article on sets. The advantages of having an option set conform to SetAlgebra is that we can do set operations in order to grab the OptionSet data when we need to operate with it.\nYou can, for example, do the simplest operation, which is checking if a set contains a given option:\nCurrency.southAmericanCurrencies.contains(.bolivianBoliviano) To more complex set operations, such as joins, checking set membership in bigger sets, and more.\nUsing your Own OptionSets Finally, to use your OptionSet you just treat it as a set. When a method takes a Currency, it\u0026rsquo;s taking a set. You can use that set to perform operations based on the values provided for said set.\nfunc convertUSDTo(_ currencies: Currency, value: Double) -\u0026gt; [CurrencyPair] { // Grab the values of the set and operate on it if currencies.contains(.bolivianBoliviano) { // calculate bob } if currencies.contains(.chileanPeso) { // Calculate } //... } Conclusion Building configurable APIs is not necessarily a challenge, but it can always be improved. OptionSet provides us with a way to let user configure their calls to our APIs and internally they are essentially sets.\n","tags":["apple","swift","programming","optionset"]},{"id":"7ebcfb2f4e229c0427ccb740cb6dc6eb","title":"Intercepting iOS Network Request Calls with Proxyman","link":"/posts/intercepting-ios-network-request-calls-proxyman/","content":"Intercepting iOS Network Request Calls with Proxyman\nWorking with network APIs can be tricky, especially when debugging. You oftentimes have to ask yourself if your app is sending and receiving the expected information. You also often worry about whether the web service returns whatever it promises it will return. Working with APIs is both easy and tricky due to all the implications behind the scenes. What happens if the service goes down and sends unexpected responses? Or if your app loses internet connection? Using a proxy to intercept network calls will help us answer these questions.\n------ Full Disclosure\nI was reached out by the team at Proxyman and they gave me a full year license. In turn I\u0026rsquo;d write at least one article about the program.\nI think that proxy tools are important, and while we have some established tools, I genuinely like Proxyman.\nIf you need to intercept network calls and you can\u0026rsquo;t or don\u0026rsquo;t want to pay, there are some alternatives available. Including mitmproxy, for which I have an article on here. mitmproxy is a free and open source alternative to Proxyman. I personally find Proxyman easier to use, but mitmproxy is not a bad alternative by any means.\nOn andyibanez.com, I make the promise to disclose whenever I have been asked to write about a certain product, and I will only write about said product if I like it. I also make the promise that, shall this become a more common occurrence in the future, my website will see two new posts weekly: One post for the product, and my usual weekly article.\nInstalling Proxyman Proxyman is available through Homebrew, so if you already have Homebrew installed, you simply need to type the following in a Terminal window:\nbrew install proxyman Otherwise you can get it from here.\nSetting up When you launch Proxyman, you will see a window that shows all the network calls going on in your system. We will first set it up to work with the iOS Simulator.\nFor this article, I will be proxying my own app, Next Anime Episode. Feel free to use your own app, or you can use this one when install it on your phone.\nIn this case of Next Anime Episode, we will intercept calls that come from the Anilist domain.\nThe basic use for a proxy tool like this is we want to observer the requests we do, and the requests we make. To the bottom-left we have views where we can choose if we want to see our headers sent, our requests, or the server responses.\nBecause the app is using HTTPS, we cannot observer any traffic yet. To the bottom-right we will have the options to enable proxying, either all the domains of the app, or just that specific domain.\nOnce you click either button you will be prompted to install and trust Proxyman\u0026rsquo;s certificate. This is necessary in order to decrypt HTTPS traffic. Do note that Proxyman cannot intercept calls when dealing with certificate pinning. There is no tool that can currently do this.\nOnce you install the certificate, proxyman will prompt you to run the request again. Simply repeat an action on the app that would trigger a request.\nOnce you re-run the request, you will find that you are not quite ready yet. Now the app will refuse to run as it (rightfully) thinks someone else is trying to act as them. To fix this, we now need to install the matching key on the simulators. Open the request you just re-did and look to the bottom-right.\nProxyman automatically knows the request came from the simulator. Click the \u0026ldquo;Install Certificate\u0026rdquo; button to show a window where you can install the certificate on the simulators with a simple click.\nWe are almost done. Click the \u0026ldquo;Reset iOS Simulators\u0026rdquo; button. Next time when they launch, the certificate will be installed, and you will be able to intercept networking calls.\nNow relaunch a request, and take a look at the panel below. Finally, some data!\nAdvanced Features Proxyman offers some features that makes it very valuable when it comes to debugging networking. They are very easily accessible and easy to use.\nRepeat and Edit and Repeat The most basic advanced feature is repeating a request. When you are debugging and working with your backend team at the same time, it could be useful to repeat a request without having to relaunch your app.\nTo Repeat a request, go the Flow menu or press Cmd + Enter. This will repeat the request you have highlighted with no modifications whatsoever.\nYou can also Edit and Repeat a request (Flow menu or Option + Cmd + Enter). You will get a window where you can edit your request. If your API does not send JSON, you can also choose to show Form instead of text.\nThis is a very useful feature. For my particular job, and when dealing with private APIs in general, this allows me to write stronger code for my requests and find requests that prevent me from bombing the server.\nWorth nothing you can edit everything about the request, including the header, so you can use this feature when experimenting with an API for the first time.\nSimilar to editing, you can compose new requests from scratch, by going to Tools \u0026gt; Compose. This will show window very similar to the Edit and Repeat one, and you will be able to compose a request from scratch.\nBreakpoints One final handy feature I want to talk about are breakpoints. If you are debugging with traditional iOS app debugging, you know breakpoints. They work the same way.\nWith Proxyman, you can set breakpoints on certain URLs with paths, you can choose what HTTP method should trigger it, and whether it should trigger for Requests, Responses, or both. To use the breakpoints feature, go to Tools \u0026gt; Breakpoints \u0026gt; Rules, and click +.\nThe specific API I use on Next Anime Episode is a GraphQL API, so there\u0026rsquo;s only one URL I can interact with.\nWhen a breakpoint is hit, you can edit it the contents. Whether you chose the breakpoint to be triggered on requests or responses, you can edit it before sending it off to its destination.\nWhen a breakpoint is hit, you will see the Breakpoints screen, and you will be able to edit your requests immediately.\nEditing responses works the same way. Editing responses is useful as you can modify a response before it hits its destination. This is useful when debugging on an actual device.\nSetting up a Physical iOS Device Proxyman allows you to use your physical device. You can configure your device to point to a proxy on your Mac running a Proxyman instance and inspect and modify all and any traffic sent from and meant to your phone.\nTo do the setup, make sure both your Mac and device are connected to the same network. Then, configure your phone\u0026rsquo;s WiFi to use the proxy by pointing the Proxy settings to YOUR_MAC_IP:9090, where YOUR_MAC_IP is the IP address for your Mac and 9090 is the default port for Proxyman. Note that you can change the port used by Proxyman by going to Proxyman \u0026gt; Preferences.\nOnce that\u0026rsquo;s done, visit http://proxy.man/ssl from Safari on your phone. You will be prompted to install a certificate.\nThen, go to Settings \u0026gt; General \u0026gt; Profile on your phone, and select the Proxyman profile.\nFinally, go to Settings \u0026gt; General \u0026gt; About \u0026gt; Certificate Trust Settings, and enable the switch for the Proxyman certificate.\nYou will now be able to debug your network requests from your physical device.\nFinal Word Don\u0026rsquo;t forget to disable the certificates on both your Mac and iOS when you are done with them. An attacker could in theory be running Proxyman and be able to capture your requests when connected to public WiFi. Also remember you cannot observe traffic on apps with SSL pinning.\nConclusion Proxyman is a wonderful debugging tool. I find it easier than mitmproxy, and even friendlier than Charles. If you can afford it, I strongly recommend Proxyman, as it makes network debugging a breeze.\n","tags":["reverse engineering","apple","ios","ipados","macos","tvos","watchos","proxy","networking"]},{"id":"2949f741779ce6df1f53ef0facf518ba","title":"nil-null-mess in Objective-C and Swift","link":"/posts/nil-null-mess-objective-c-and-swift/","content":"All programmers are familiar with the concept of nullability. Whether something exists or not. Whether something is there or not.\nObjective-C is very dynamic when it comes to dealing with nullability. All Objective-C programmers are familiar with this phrase:\nmessages can be sent to nil.\nWhich means that nil itself can call methods, safely enough, without crashing.\nIn Swift, we have a bit more safety. We can send \u0026ldquo;messages\u0026rdquo; to nil, but only if they are the result of a chained optional. nil can only be a thing when we are working with optionals.\nDealing with nullability in Objective-C can be a mess, and this mess can carry over to Swift when bridging, so we are going to talk about the different \u0026ldquo;kinds\u0026rdquo; of nullability here, with practical examples and situations I have come across the real world.\nIf you are thinking that dealing with nils is easy and \u0026ldquo;works as expected\u0026rdquo;, I recommend you read this, especially if you have never touched Objective-C.\nOur old friend nil Both Objective-C and Swift programmers are familiar with nil. When an object \u0026ldquo;points\u0026rdquo; to nil, it means it\u0026rsquo;s pointing to nil.\nnil is probably the essence of nothingness. When we have nil, it means we have nothing. This has some interesting implications, especially when working with Objective-C.\nPeople who have been working with Objective-C may recall that they needed to terminate variadic parameter methods with a nil in order to tell the compiler we were done passing values.\nNSArray\u0026lt;NSString *\u0026gt; *array = [NSArray arrayWithObjects:@\u0026#34;Alice\u0026#34;, @\u0026#34;Eileen\u0026#34;, @\u0026#34;Sepia Alice\u0026#34;, nil]; The code above is an old-style way of initializing an array with a variable number of arguments. Let\u0026rsquo;s see what happens if we try to print it:\nfor(NSString *string in array) { NSLog(@\u0026#34;%@\u0026#34;, string); } Alice Eileen Sepia Alice It will print everything, except the nil - Because nil is not part of the array.\nThings become even more interesting when you try to add multiple nil values to an array.\nNSArray\u0026lt;NSString *\u0026gt; *array = [NSArray arrayWithObjects:@\u0026#34;Alice\u0026#34;, nil, @\u0026#34;Eileen\u0026#34;, @\u0026#34;Sepia Alice\u0026#34;, nil]; for(NSString *string in array) { NSLog(@\u0026#34;%@\u0026#34;, string); } The output on the console will be following:\nAlice !?!?\nBut wait, there\u0026rsquo;s more. Print the number of elements in that array and you get:\nNSLog(@\u0026#34;%d\u0026#34;, (unsigned)array.count); 1 nil, being the terminator to variadic functions, will cause the input to stop being considered the moment nil is found.\nWhat happens if you want to have an array that can contain strings AND null values? Can this be done at all?\nIntroducing NSNull If nil is the essence of nothingness itself, NSNull is a representation of nothingness. NSNull contains a method null whose only purpose is to give you a singleton to a representation, or placeholder, of nothingness.\nThe Cocoa Framework is a highly dynamic thing. Because of the way nil behaves, particularly in Objective-C, there are many times when its pure purpose is not wanted. And so, we can answer our question:\nCan we have an array of objects that also has null values?\nAnd the answer is, yes!\nAnd no.\nNSNull is an actual Foundation object. It inherits from NSObject like anything else in the framework. In Objective-C, you cannot have an array with pure nil or pure nothingness. What you need to do is to replace actual nothingness with something Foundation can understand, and that\u0026rsquo;s what we use NSNull for. You can think of NSNull as a wrapper around nil, but I prefer to think of it as a dummy that represents nothingness and is of the same family of anything else that comes from NSObject.\nThe last array we wrote above can therefore be rewritten like this:\nNSArray\u0026lt;NSString *\u0026gt; *array = [NSArray arrayWithObjects:@\u0026#34;Alice\u0026#34;, [NSNull null], @\u0026#34;Eileen\u0026#34;, @\u0026#34;Sepia Alice\u0026#34;, nil]; When we try to print it, we will get a more expected output:\nAlice \u0026lt;null\u0026gt; Eileen Sepia Alice And if you print its count, you will get 4.\nObjective-C knows NSNull or something entirely different to nil. When you need actual nothingness, use nil. When you need to operate or use that nothingness, use NSNull.\nNSNull and Swift In Swift, we are spared from this entire discussion, when it comes to arrays, because optionals are a data type thought around the need for nullability. If an array takes an optional, it can take nil, and your array will always work as you expect it to work.\nA Swift optional, with the ? marks all over the place, is really just syntactic sugar for the Optional\u0026lt;T\u0026gt; type, which as an enum with two cases: .none and .some(T). Therefore, an array of optionals does not really have true nullability either, but we can say you have indirect access to nullability.\nlet dolls: [String?] = [\u0026#34;Alice\u0026#34;, nil, \u0026#34;Eileen\u0026#34;, \u0026#34;Sepia Alice\u0026#34;] for doll in dolls { print(doll) } This will print:\nOptional(\u0026#34;Alice\u0026#34;) nil Optional(\u0026#34;Eileen\u0026#34;) Optional(\u0026#34;Sepia Alice\u0026#34;) nil-null-mess and dictionaries Up until now, we have talked about nullability and arrays, but it\u0026rsquo;s more interesting to see them when it comes to dictionaries. Nullability and dictionaries have been a point of pain for old projects for many years. If you don\u0026rsquo;t understand nullability in Objective-C and Swift, you can find yourself struggling with extremely bizarre bugs.\nObjective-C Dictionaries To explore these fun examples, we are going to parse a JSON file into a dictionary of type NSJSONSerialization. This would return us a dictionary of type NSDictionary\u0026lt;NSString*, NSArray\u0026lt;NSString *\u0026gt; *\u0026gt;. This may seem overkill, but parsing JSON the old way is the best way to describe the problems I have found in the real world and why being aware of the different \u0026ldquo;nullability\u0026rdquo; kinds is important.\n{ \u0026#34;Pullip\u0026#34;: [ \u0026#34;Classical Alice\u0026#34;, \u0026#34;Eileen\u0026#34;, \u0026#34;Alice Sepia\u0026#34; ], \u0026#34;Myou\u0026#34;: [ \u0026#34;Delia\u0026#34;, \u0026#34;Matcha\u0026#34; ], \u0026#34;HarmoniaBloom\u0026#34;: null } In case you are following along, this is the code that loads that file (dolls.json) into a dictionary:\nNSURL *file = [[NSBundle mainBundle] URLForResource:@\u0026#34;dolls\u0026#34; withExtension:@\u0026#34;json\u0026#34;]; NSData *data = [NSData dataWithContentsOfURL:file]; NSDictionary *dictionary = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; Now we are going to explore a slightly tricky situation. Now consider the following questions:\nWhat data does dictionary[@\u0026quot;Nendoroid\u0026quot;] have?\nWhat data does dictionary[@\u0026quot;HarmoniaBloom\u0026quot;] have?\nTake a few minutes and answer in your head before continuing.\nNSLog(@\u0026#34;%@\u0026#34;, dictionary[@\u0026#34;Nendoroid\u0026#34;]); NSLog(@\u0026#34;%@\u0026#34;, dictionary[@\u0026#34;HarmoniaBloom\u0026#34;]); (null) \u0026lt;null\u0026gt; If you have read up until now, you may deduce that null is printed with different parenthesis or \u0026lt;\u0026gt; depending on whether it is nil or NSNull. But which is which?\nThe console will print (null) when printing real nothingness, and \u0026lt;null\u0026gt; when printing an NSNull.\nIn other words dictionary[@\u0026quot;Nendoroid\u0026quot;] is nil, whereas dictionary[@\u0026quot;HarmoniaBloom\u0026quot;] is NSNull.\nIn short, in Objective-C, when a dictionary does not have a given key, it will point to nil. When the dictionary does have the key, but said key is null, it will be NSNull. It makes complete sense if you think about it. Earlier we said NSNull is a placeholder for actual nothingness, and if you want a dictionary that can have nothingness, you need to use a placeholder for nothingness.\nThis has been the source of many weird crashes for the following reason: In Objective-C, you can send messages to nil, but when you are sending messages to a real object, the object needs to implement the method you want to call - in other words, you want the object to respond to a selector. If you send a message to an object and the object does not respond to it, you will crash with a message similar to \u0026ldquo;unrecognized selector sent to instance 0xb4df00d\u0026rdquo;.\nTo clarify the following point, we will try to print the contents of the Nendoroid key, and the dolls in the HarmoniaBloom key, using for in. for in is the quick iteration operator. Behind the scenes, for-in will call the countByEnumeratingWithState:objects:count: method in arrays. If arrays didn\u0026rsquo;t implement this method, for-in would crash your program instantly.\nTrying to print the Nendoroid key won\u0026rsquo;t print anything. The key does not exist in the dictionary at all:\nfor(NSString *doll in dictionary[@\u0026#34;Nendoroid\u0026#34;]) { NSLog(@\u0026#34;%@\u0026#34;, doll); } This will print nothing, and the program will move on.\nOn the other hand, trying to print the contents of the HarmoniaBloom array will have unexpected consequences:\nfor(NSString *doll in dictionary[@\u0026#34;HarmoniaBloom\u0026#34;]) { NSLog(@\u0026#34;%@\u0026#34;, doll); } *** Terminating app due to uncaught exception \u0026#39;NSInvalidArgumentException\u0026#39;, reason: \u0026#39;-[NSNull countByEnumeratingWithState:objects:count:]: unrecognized selector sent to instance 0x7fff8002ef10\u0026#39; The console tells us what\u0026rsquo;s wrong, and if you read the discussion above, you know what\u0026rsquo;s wrong: Since accessing a non-existing key in a dictionary returns nil, and messages can be sent to nil, the program can continue executing without an issue.\nOn the other hand, when we access an existing key whose value is NSNull, the program will crash, because NSNull is an object like any other, and it expects to receive selector calls that it can respond to. Failing to do so will cause your program to crash.\nTherefore, when accessing dynamic dictionary data, you need to check if the object that will receive a selector is NSNull before you send any messages to it.\nif(![dictionary[@\u0026#34;HarmoniaBloom\u0026#34;] isEqual:[NSNull null]]) { for(NSString *doll in dictionary[@\u0026#34;HarmoniaBloom\u0026#34;]) { NSLog(@\u0026#34;%@\u0026#34;, doll); } } Dictionaries, Nullability, and Swift Note: The sample code here omits working with optionals safely unless it is necessary for the example. Always work with your optionals responsibly and avoid force-unwrapping optionals as much as possible.\nUnlike arrays, the above discussion is largely relevant to Swift.\nFirst, if you want to be as type safe as possible, you will likely want to cast the result of JSONSerialization.jsonObject(data:options:) to something more sensible. In this case:\nlet jsonString = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;Pullip\u0026#34;: [ \u0026#34;Classical Alice\u0026#34;, \u0026#34;Eileen\u0026#34;, \u0026#34;Alice Sepia\u0026#34; ], \u0026#34;Myou\u0026#34;: [ \u0026#34;Delia\u0026#34;, \u0026#34;Matcha\u0026#34; ], \u0026#34;HarmoniaBloom\u0026#34;: null } \u0026#34;\u0026#34;\u0026#34; let data = jsonString.data(using: .utf8)! let dictionary = try! JSONSerialization.jsonObject(with: data, options: []) as! [String: [String]] The first thing you will notice here is that the program will crash with the diagnostic:\nCould not cast value of type \u0026#39;NSNull\u0026#39; (0x7fff86d72b38) to \u0026#39;NSArray\u0026#39; (0x7fff86d72430) This is because the values of objects may be optionals. A better option would be:\nlet dictionary = try! JSONSerialization.jsonObject(with: data, options: []) as! [String: [String]?] Using this, the parsing will succeed without an issue. Now try printing the values of the keys Nendoroid and HarmoniaBloom:\nprint(dictionary[\u0026#34;Nendoroid\u0026#34;]) print(dictionary[\u0026#34;HarmoniaBloom\u0026#34;]) This will print:\nnil Optional(nil) Similar to Objective-C, using the same APIs and all, accessing a nonexisting key and a key whose value is nil yield different results. NSNull can be used in Swift, but when bridging the framework decided not to use it.\nWhen it comes to Swift, you will largely use Codable to parse JSON anyway, so you may not need to concern yourself much with the different types of nothingness when parsing JSON, but do keep the differences in mind.\nConclusion Nullability can actually be messy when working in some (rather common situations). Keep in mind what nil really is and what NSNull represents, and you will be mostly fine. To make matters worse, Objective-C has additional nothingness, including NULL which happens when working with C and C++ code, and Nil, when working with nullability of classes. Most developers do not need to concern themselves with the last two, but it\u0026rsquo;s good to know they exist.\n","tags":["apple","objective-c","swift","nil",null,"nsnull","nullability"]},{"id":"71eb639a00bc0a9bd09ad2a22326682e","title":"Understanding Basic Data Structures in Swift: Dictionaries in Depth","link":"/posts/understanding-basic-data-structures-dictionaries-in-depth/","content":"Whether you are a seasoned developer with a lot of code out in the wild world, or you started learning programming this week, chances are you hace used (and seen) dictionaries being used in many places. Also known as hashmaps or hash tables, dictionaries allow us to store key-value mappings, from one object to another.\nIn this article we will study this structure which is known by everyone, and we will also learn about its quirks and unknown features.\nDictionary Basics Dictionaries map keys with values. Similar to an array, but instead of using numerical indexes, they use a Hashable as the key. For the vast majority of cases, this Hashable is a string. Each has is unique, and a dictionary cannot store the same key twice pointing to a different object. In fact, try running this somewhere:\nlet dollDic = [ \u0026#34;Pullip\u0026#34;: \u0026#34;Classical Alice\u0026#34;, \u0026#34;Pullip\u0026#34;: \u0026#34;Eileen\u0026#34; ] Dictionary literals can do a lot of checking beforehand. You will see an error similar to the one below:\nFatal error: Dictionary literal contains duplicate keys: file Swift/Dictionary.swift, line 826\nWhen you attempt to set the same existing value at runtime, your code will not crash. Instead, it will replace the old one:\nvar dollDic = [ \u0026#34;Pullip\u0026#34;: \u0026#34;Classical Alice\u0026#34; ] dollDic[\u0026#34;Pullip\u0026#34;] = \u0026#34;Eileen\u0026#34; print(dollDic[\u0026#34;Pullip\u0026#34;]) // Eileen Keys Order One question I see being asked very often is, why aren\u0026rsquo;t the keys of a dictionary ordered when I print them or try to access them? Why are the keys in a different order every time I print an app?\nThere is nothing in the definition of a dictionary (or a hashmap) that guarantees an order for the keys. As part of the hash part, there is no way to make a guarantee of the order.\nThe hash is a calculated value. Dictionary keys get \u0026ldquo;converted\u0026rdquo; to a hash at runtime. Ultimately, dictionaries are hash tables, and that means that they need a very fast access of their index. Whatever you want to use as a key, is likely to be slow, so converting it to a hash ensures quick lookup in the table to retrieve it or store something new. Because keys are converted to hashes for lookup, the table does not keep track of the original keys*. Instead, the keys may look like random data, but they are the result of an operation to make hash table lookup very quick.\n*: While you can access the keys in Swift and they are not lost forever, the definition of a dictionary still does not guarantee any order. In Swift, you can access the keys by calling the keys property on a dictionary. This will return an array of the keys.\nKeeping a dictionary order With all that said, there may be times in which you do need to keep a certain order to your keys after all.\nThe first method is to call the keys property of a dictionary. This will return an array with the keys. this is an array you can sort and use that to access your dictionary.\nvar directory = [ \u0026#34;e\u0026#34;: \u0026#34;Eileen\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;Bloody Red Hood\u0026#34;, \u0026#34;a\u0026#34;: \u0026#34;Alice\u0026#34;, ] let keys = directory.keys.sorted() keys.forEach { print(directory[$0]) } Once you have your keys, you can sort them any way you like, and then just iterating over them and accessing the dictionary in that order will give you the results you want.\nAlice Bloody Red Hood Eileen Introducing KeyValuePairs But, there is a lesser known type in the Swift library called KeyValuePairs. This object is a key-value store just like dictionaries, with the main difference being that the collection is ordered since the beginning, but another important difference is that this is not a hash table, so lookup is not as fast. While you are not likely to hit any constraints in most modern computing systems, do keep in mind that performance when using KeyValuePairs is worse.\nThe easiest way to initialize a KeyValuePair is to declare your variable of type KeyValuePair and then giving it a dictionary literal.\nTo be clear and avoid any confusion, the KeyValuePair will not accept anything and return it sorted for you. instead, it just means that it will keep the items in the order you gave them.\nAlso keep in mind that there is no guarantee that the keys will be unique. In fact this is perfectly valid:\nvar directory: KeyValuePairs = [ \u0026#34;e\u0026#34;: \u0026#34;Eileen\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;Bloody Red Hood\u0026#34;, \u0026#34;a\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;Betty\u0026#34; ] directory.forEach { _, value in print(value) } Eileen Bloody Red Hood Alice Betty Perhaps the reason this object isn\u0026rsquo;t very well known is because ultimately, it\u0026rsquo;s not really useful. You can get the same benefits just using a an array of (String, String) objects and prevent your codebase from getting polluted with lesser known objects.\nHashable Implementation While not very common, it\u0026rsquo;s possible you may want to create your own keys for a dictionary.\nHashable is a protocol with very few requirements.\nAll you need to do is implement the hashValue: Int property.\nThe hash of an object has to be unique per run of the app. It doesn\u0026rsquo;t even have to be the same across consistent launches. Generally when I need to create my own Hashables, I try my best to user an underlying properly to supply it.\nstruct Doll: Hashable { let name: String let maker: String var hashValue: Int { name.hashValue } } let alice = Doll(name: \u0026#34;Classical Alice\u0026#34;, maker: \u0026#34;Pullip\u0026#34;) let delia = Doll(name: \u0026#34;Delia\u0026#34;, maker: \u0026#34;Myou\u0026#34;) let dollCount = [alice: 2, delia: 3] In the example above, I\u0026rsquo;m using the name property\u0026rsquo;s hashValue as the hash for my object. Sometimes this will help you build more obvious code, but make sure you don\u0026rsquo;t over-engineer on top of this.\nConclusion Dictionaries are very common, in all programming languages, all over the world. Understanding the gotchas is important, and the features Swift provides for them are worthwhile a bit more study.\n","tags":["swift","apple","dictionary","data structures","data","structures","foundation"]},{"id":"1fc5dc6e4a6e6e76a7b9bd1d404fd0c6","title":"Understanding Basic Data Structures in Swift: Sets","link":"/posts/understanding-basic-data-structures-swift-sets/","content":"I\u0026rsquo;m introducing a short small series in which we will talk about basic data structures in Swift. My goal is not to show how they are implemented internally, but rather to show when they can be useful.\nIn truth, unless you have studied Computer Science to some capacity, chances are you are missing on a lot of powerful existing data structures that can help you write better code. I have been studying iOS development for a long time with many resources, and none of the resources ever dive into useful data structures, such as sets. These sources tend to focus on arrays and dictionaries only (as the focus is iOS development, and not necessarily computer science), not teaching other structures that are actually really useful in the iOS Development world. I have never seen an iOS dev resource that covered these structures as deeply as my computer systems engineering courses did.\nMany computer science classes introduce data structures by teaching students the theory and making them implement them. We are not going to do be doing that here (unless there\u0026rsquo;s demand for that, for a future article). Instead, this series will introduce a new structure and show you the native implementation in either Foundation or the Swift standard library.\nSome of these articles may contain a bit of mathematical discussion. I do not want that to be a turn off to read them. I can guarantee you, as someone who has never had a good mathematical foundation, that understanding these concepts is both easy and important to grow your career.\nMost of the examples here use numbers, but keep in mind that you can use any other object with sets as long as it complies with the Equatable protocol. Many types, like Strings, are already Equatable so you can use those in sets right out of the box.\nWithout further ado, let\u0026rsquo;s get into it.\nIntroduction to Sets. Stanford University defines set theory as:\nSet theory is the mathematical theory of well-determined collections, called sets, of objects that are called members, or elements, of the set.\nIn more humane words, a Set is a collection of some sort of object. These objects can have sub-groupings, or sub sets, that allow us to further constraint the objects a set can contain.\nYou may remember from your elementary school days, that numbers can be grouped in multiple sets:\nNatural numbers: Whole numbers from 1 upwards. Integers: Whole numbers, which include both negative numbers and the number 0. Rational Numbers: Numbers that result from dividing one integer by another, except division by zero. Essentially, fractions.\nThese are just some of the sets you have seen in school, but what matters here is that Numbers themselves are a set, and you can subset Numbers into many different categories. Integers are a subset of numbers, and Natural numbers are a subset of integers. We can further find more sets that were defined way before our time, and we can even create our own sets too, like numbers that can be divisible by 2 with a remainder of 0, and more.\nSets and Arrays Many times, I see programmers using Arrays when a Set may suffice. What you may be wondering at this point is what is the relationship of a set with an array? How can one replace the other?\nIn computer science, sets have an additional property, and that is that all its members are unique. Many libraries and frameworks offer you Sets with a an existing definition of Unique for specific data types. For example, in Swift, the definition of uniqueness for a set or integers is that each number must be different than any other existing number, but you can create your own definition of uniqueness for your custom types.\nIn contrast, an array can contain multiple elements, including repeating ones.\nMany times I see programmers wanting to keep an array of unique elements, and swiftly making up ways to clean their arrays of duplicate elements. In Swift, if you need an array of unique elements, you can quickly convert between Sets and Arrays and vice-versa with an initializer. Both sets and arrays are Collections in Swift, and interoperating between them is easy.\nConsider the following example:\nlet array = [1, 1, 2, 3, 4] let set = Set(array) We declare an array called array with a list of elements, and another set with the same list of elements.\nIf you count the number of elements in each:\nprint(\u0026#34;Array count: \\(array.count) - Set count: \\(set.count)\u0026#34;) // You will find that array has more elements than set.\nArray count: 5 - Set count: 4\nWe have magically converted an array into a set by just passing the array to the set. The set has done its magic and it has removed all the duplicate numbers for us.\nSets and Ordering Using sets has another implication though: They are not ordered by default, and there is no order to be found in the definition of a set. Some implementations in other libraries and languages may guarantee an order, but conceptually you should never rely on that.\nIf you print(set) multiple times, you will see the output is different every time.\nLuckily, we can get a sorted version of the set easily by just calling sorted() or sorted(by:).\nprint(set.sorted()) // [1, 2, 3, 4] print(set.sorted(by: \u0026gt;)) // [4, 3, 2, 1] Do note that, if you need to keep the set ordered to begin with - every insertion inserts the item in the right place -, you will need to use something different. Foundation provides NSOrderedSet for this. Because it\u0026rsquo;s an old Foundation API, it does not support Swift generics, so using it requires a bit of involved code.\nSet Operations Now let\u0026rsquo;s talk about common set operations you can do. All the set operations I am going to talk to about take two sets and return another set. Keep these in mind as you will likely find moments where it\u0026rsquo;s useful to know them in your code.\nIntersection The intersection operation returns a new set of elements that exist in both sets.\nlet set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4, 5, 6] let intersection = set1.intersection(set2) print(intersection) // [3, 4] In the above example, intersection only contains 3 and 4, as those are the only items that exist in both sets. Do note that there is no guaranteed order in the resulting set, so you can expect a different order every time.\nDifference Given set1 and set2, the difference of two sets are the elements that are unique to each set. It is essentially the opposite of intersection.\nIn Swift, symmetricDifference will return a new set.\nlet set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4, 5, 6] let difference = set1.symmetricDifference(set2) print(difference) // [6, 5, 2, 1] Swift also has the formSymmetricDifference method for sets. This call will remove the elements that exist in both sets, and it will append the resulting elements from the second set to the first one:\nvar set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4, 5, 6] set1.formSymmetricDifference(set2) print(set1) // [6, 5, 2, 1] Do note that because this mutates a set, the \u0026ldquo;target\u0026rdquo; set has to be declared as var.\nisDisjoint Given a set1 and set2, set1 is disjoint with set2 if set2 contains only elements that are not part of set1.\nlet set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4, 5, 6] let set3: Set = [5, 6] set1.isDisjoint(with: set2) // false set1.isDisjoint(with: set3) // true Superset Checking You can check if set1 is a superset - in other words, that set1 contains all the elements - of set2.\nWe say set1 is a superset of set2 if every member of set2 also belongs to set1.\nlet set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4] let set3: Set = [4, 6] set1.isSuperset(of: set2) // true set1.isSuperset(of: set3) // false We can also check if set1 is a strict superset of set2.\nset1 is a strict superset of set2 when all the elements in set2 exist in set1, and when set1 contains at least one element that is not part of set2.\nlet set1 = Set([1, 2, 3, 4]) let set2 = Set([3, 4]) set1.isStrictSuperset(of: set2) // true Because of this, a set is a superset of itself, but a set will never be a strict superset of itself.\nSubset Checking Just like we can check when a set is a superset or strict superset of another set, we can do the same with subsets.\nset2 is a subset of set1 when all the elements of set2 exist on set1.\nlet set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4] set2.isSubset(of: set1) // true set2 is a strict subset of set1 when every member of set2 is also a member of set1 and set1 contains at least one element that is not part of set2.\nlet set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4] set2.isStrictSubset(of: set1) // true Subtraction From set1, you can remove all the elements that exist in set2.\nThere are two ways of doing this: The first method returns a new set containing the elements of set1 that were removed because they were in set2.\nlet set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4] let subtraction = set1.subtracting(set2) // [1, 2] The other one takes a mutating set, and the subtraction occurs on it.\nvar set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4] set1.subtract(set2) // [1, 2] Union The union between set1 and set2 contains all the elements of both sets, with the duplicate ones removed.\nlet set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4, 5, 6] let union = set1.union(set2) // [1, 2, 3, 4, 5, 6] formUnion does the same, but operating on a mutable set instead.\nvar set1: Set = [1, 2, 3, 4] let set2: Set = [3, 4, 5, 6] set1.formUnion(set2) // [1, 2, 3, 4, 5, 6] Inserting and Updating You can insert new elements to mutating sets. For this, we have the insert and update methods.\nThey work very similarly, with the difference living in the return object.\nvar set1: Set = [1, 2, 3] let set2: Set = [3, 4, 5, 6] set1.update(with: 4) // returns 4 set1.insert(7) // returns (true, 7) update returns the object that was just inserted, or nil if the object could not be inserted because it already exists.\ninsert returns a boolean indicating if the member was inserted, and the value of the last member that was equal to the inserted one. This is important, because with more complicated member types, you may have logic to consider equality for sets, but ultimately your objects may have differences.\nHigh-order Functions Because Sets in Swift are implemented as Collections, you can use filter, map, reduce and other high order functions on them.\nlet set: Set = [1, 2, 3, 4] let set2: Set = [3, 4, 5, 6] let filtered = set.filter { $0 % 2 == 0 } // [2, 4] APIs based on Sets Finally, I want to talk about other APIs that are implemented as sets and are really useful. In particular, I want to talk about Foundation\u0026rsquo;s Character sets.\nThe sets you have seen until now can be really useful and I fully expect to see such code in the real world, but character sets are very useful, especially when dealing with strings.\nIntroduced in iOS 7, CharacterSet gives us access to predefined character sets and allows us to create our own. These sets can help us create some string validations easier.\nlet letters = CharacterSet.letters let string = \u0026#34;pullipalice\u0026#34; let stringCharacters = CharacterSet(charactersIn: string) stringCharacters.isSubset(of: letters) // true We are checking a simple string and seeing if it has only letters. CharacterSet has many predefined sets for us, such as letters, alphanumeric, decimalDigits, and more. We can also very easily create our own character sets. In the following example, we will create a set with morse code characters and compare it against some strings.\nlet morseCodeCharSet = CharacterSet(arrayLiteral: \u0026#34;.\u0026#34;, \u0026#34;-\u0026#34;) let string1 = \u0026#34;..--.-\u0026#34; let string2 = \u0026#34;alice..-..\u0026#34; let string3 = \u0026#34;------\u0026#34; let string1Set = CharacterSet(charactersIn: string1) let string2Set = CharacterSet(charactersIn: string2) let string3Set = CharacterSet(charactersIn: string3) morseCodeCharSet.isSuperset(of: string1Set) // true morseCodeCharSet.isSuperset(of: string2Set) // false string3Set.isSubset(of: morseCodeCharSet) // true Conclusion Sets are a very powerful but lesser used data structure. They have al of features and they can take up the place of arrays more often than we would think. It\u0026rsquo;s worth to study them, as they will help us become better developers.\n","tags":["swift","apple","sets","data structures","data","structures","foundation"]},{"id":"b6b98f2ccd25e7a12c127e7ffe028087","title":"Being an iOS Developer in Bolivia (and South America)","link":"/posts/being-ios-developer-bolivia/","content":"Happy New Years everyone! To kick off this year, I wanted to write a non-technical article. This time I want to focus on a topic that you won\u0026rsquo;t find in many other places, and that is what it is like to hunt for iOS jobs in Bolivia, and what my experience has been like being one here. By the end of this article, you will hopefully understand a very different market compared to countries such as the USA, and you will be able to make a decision on whether this is a field you want to pursue or not. What I\u0026rsquo;m going to be writing about applies to Bolivia, but keep in mind that South America in general has very similar conditions and markets.\nBuying Macs and Other Apple Devices Let\u0026rsquo;s talk about one of the most, if not THE most important, factor that could make someone pursue an iOS dev career in Bolivia: Cost and hardware.\nBolivia is a considered a third-world country. We do not have any Apple Stores, and authorized retailers are something that appeared around this decade.\nRetailers crank up the price of each Apple product considerably, and although there are ways to get them for cheaper, the cost of getting into iOS development is often very prohibitive.\nThe good news is that Apple products last a very long time, so you can be an iOS dev without refreshing your hardware very year, or even every two years, or even every three years. Your Mac and iPhone are going to last a very long time, receiving software updates and overall performing really well.\nWhen it comes to support, since we have no official Apple Stores, our only option is to go to \u0026ldquo;official\u0026rdquo; service providers with the doubt of whether they really are authorized or not. The good news is that you can see who is an authorized repairer on Apple\u0026rsquo;s website. The bad news is, even when they are authorized and have good parts, getting your Mac or iPhone fixed is once again expensive - because you can\u0026rsquo;t make use of the Apple Care warranty here -, and also getting your repairs done can take a long time. When my MacBook Pro 2015\u0026rsquo;s battery got swollen up, it took around 4 weeks for the guy to give me my computer back. It was in perfect working condition, but I couldn\u0026rsquo;t get anything done then. And forget about getting shiny new hardware. When Apple does product recalls and they offer brand new products, you cannot do that claim here. You will never get a shiny new device by turning in a faulty one.\nCost is one of the most important factors to consider if you want to get into iOS dev. Even with the duration of every device, some people may not see it that way. In my experience, being in the Apple has always been worth it. It is not perfect, and it has its fair share of annoyances, but overall it\u0026rsquo;s pretty good, and I\u0026rsquo;m happy with all the investments I have made in Apple Hardware.\nThe Market Despite the cost of getting Apple products, iPhones are used by a considerable amount of the population. The vast majority of devices are Android, but the market for iOS apps is there, demanding iOS devs that are very hard to find.\nThe numbers may not look like it - after all, according to statcounter, Android represents around 95% of the market. But, that small percentage of iOS users is very demanding, and they do want to run some apps.\nLet me say this again: There is a great market for iOS developers, but iOS developers simply don\u0026rsquo;t exist in big numbers. Companies can spend months and years looking for iOS developers and not find one, so when they do, they take proper care of them, and the salary will more often than not be pretty good (under Bolivian standards). More often than not, companies fail to fulfill these positions, and they end up writing cross-platform apps (which is not inherently a bad thing, but they are often not very well done because Android devs are not necessarily cross-platform devs, and it\u0026rsquo;s a discipline that demands its own study), or writing (or not updating), their iOS apps at all.\nVery often, this looks pretty embarrassing to the companies making such decisions. One such app, is the mobile banking app belonging to (Banco Uni√≥n). Their mobile app is already questionably designed to begin with. But here\u0026rsquo;s the thing - Banco Uni√≥n is a public bank. They are the biggest public bank in the country and they are one of the banks that, among other things, pay COVID reliefs and other legal bonuses to many people. In their latest app update, they were supposed to let people claim their latest COVID relief money from the app, and have it transferred to the bank of their choice. To their embarrassment, this super important feature only made it to the Android app. iOS users are left in the dust, making it necessary to make long lines to claim their money at physical institutions or not being able to claim at all.\nThere is no doubt that one of the reasons this is the case is because there are no iOS devs around to hire. Companies try hard to find iOS devs in other places, but more often than not they will try to poach the ones that are already working as iOS devs somewhere else.\nLearning iOS Development in Bolivia We have established two important things:\nGetting into the Apple ecosystem in Bolivia is prohibitively expensive, and There is enough demand for iOS devs but not enough people to fill in those positions. The last thing we are going to talk about is about actually learning the ropes of iOS development in Bolivia.\nIt is no surprise to most programmers, even college students, that self study is pretty important to grow as any kind of developer. If you don\u0026rsquo;t have the discipline to learn about a shiny new language or framework on your own, you are SOL. This is not exclusive to iOS development. If you are any kind of programmer, you know that technology moves fast, and the Java Applets you spent a semester studying in college are no longer relevant. The market moves fast, and you need to move with it.\nIn Bolivia, I have never heard, not even once, about an institution, college, or bootcamp that teaches iOS development to people. You are not going to find a university with the Apple Academy logo. Android is dominant, and iOS users, while they exist, they are far too spread-out to find them in a single place, making it hard (and profitable) to create some sort of training course for iOS development.\nThis is when the ability to self-learn kicks in. If you can learn iOS development on your own, and you can prove it, you are pretty much guaranteed to find a good, decent-paying iOS development job in one of the main cities in Bolivia.\nLearning iOS development can be lonely in Bolivia, but the international community is extremely helpful, tight, and dedicated. Of course, this has one more implication: You need to be able to read and in general communicate in English. Yes, I wrote that in English.\nA crucial skill to any iOS developer in general, English is the language that will open all sort of doors for you. If it turns you (surprisingly) cannot fulfill an iOS dev job in Bolivia, you will be ready to work anywhere else in South America if you know English. All software-dedicated houses require English - Avantica, Mojix, etc. If you do not know English, you are going to have a hard time progressing in your iOS developer career.\nConclusion Bolivia is a very challenging place to get into iOS development, but once you are in, finding jobs is pretty much guaranteed. If you are willing to do the investment in terms of money and time, you will have doors open to all sorts of places. As a little bonus, no company has actually required my university degree, and I have had offers for Senior Engineering positions without fully acquiring it (working on that, though).\nIf you want to get into iOS development in Bolivia, I strongly encourage you to, as it is very rewarding and job security will be a given for many years to come.\n","tags":["apple","ios","development"]},{"id":"fe9a56b0019d93dd4cd455b7583afd61","title":"Happy 2021! And Short Break Notice","link":"/posts/happy-2021-short-break-notice/","content":"This has been quite a year! Not only did we have the bad stuff happen (COVID-19), it has also been a crazy year for my personal development and for the growth of my blog.\nThanks to the events that happened mid-year, the reach of my blog has reached wide, and I have connected to a bunch of people thanks to all that.\nI want to take one minute to thank you all who have reached to me with questions about my articles, ideas, and even suggestions to improve my writing. When you guys point out typos and ask questions, it measn you guys are reading my content. It means that I am not writing in vain, and that makes me genuinely happy. When I revived my blog in 2019, I said I wanted to become an active Swift community member. I\u0026rsquo;m very happy to say this purpose has been fulfilled.\nI also want to thank those who have shared my articles. From the simplest link to sharing it in your newsletters and podcasts, my blog wouldn\u0026rsquo;t have the reach it has today if it wasn\u0026rsquo;t for you guys. I\u0026rsquo;d love to give names here, but I realized, there\u0026rsquo;s actually too many! And I do not want to miss a single one of you.\nSo thank you all very much for your support this first full year the new andyibanez.com has been out. And here\u0026rsquo;s to a (hopefully better) 2021!\nShort Break Notice I decided to take a break from writing for a few weeks. On January 13, I will publish the first article of the year. With me working from home, having side projects and all, I decided to avoid seeing code outside my day job for a few weeks. Thank you for your understanding!\n","tags":["apple"]},{"id":"98e6f18c0aa809dcd72f725c4fe0fca9","title":"The \"ExpressibleBy-\" Protocols in Swift","link":"/posts/expressibleby-protocols-swift/","content":"Swift gives us many interesting features to write cleaner and more obvious code. This code is more readable, and it helps both SDK consumers and code maintainers.\nOne such feature Swift has is the ExpressibleBy- family of protocols. This is a set of protocols that allow you to instantiate objects by providing some native Swift object. For example, we can instantiate an object providing a Boolean, or a String.\nThis family of protocols consist of the following protocols (this is not a complete list):\nExpressibleByNilLiteral ExpressibleByStringLiteral ExpressibleByIntegerLiteral ExpressibleByFloatLiteral ExpressibleByBooleanLiteral ExpressibleByArrayLiteral ExpressibleByDictionaryLiteral We can use these, and a few others, to create neater code for certain initializers.\nUsing the ExpressibleBy- Protocols The different variations of these protocols have different requirements. We will explore a few of them so you can get up to speed and know what to do when you find a situation when you can use them.\nExpressibleByNilLiteral Suppose you have a requirement that requires that, when an object gets initialized with nil, you don\u0026rsquo;t want the whole object to be nil. You may have a custom requirement in which you need to consider nil something different.\nFor example, suppose you want to treat the existence of an object that actually does exist, but has all its properties set to nil.\nTo use ExpressibleByNilLiteral, you need to implement the print(\u0026quot;New doll: \\(doll.name)\u0026quot;) method.\nConsider the following example:\npublic class Doll: ExpressibleByNilLiteral { var name: String? var maker: String? public required init(nilLiteral: ()) { self.name = nil self.maker = nil } } When we create a Doll object and assign it to nil, we will create a doll object whose name and maker properties point to nil.\nlet doll: Doll = nil print(\u0026#34;New doll: \\(doll.name)\u0026#34;) // Prints \u0026#34;New doll: nil\u0026#34; Make sure you only use this when it really make sense to, as new programmers to your codebase may be confused when they see a non-optional being assigned nil.\nExpressibleByStringLiteral We can instantiate our objects using strings by using ExpressibleByStringLiteral. When using this protocol, make sure you implement at least the public required init(stringLiteral:) method:\npublic class Doll: ExpressibleByStringLiteral { var name: String var maker: String public required init(stringLiteral value: StringLiteralType) { let splat = value.split(separator: \u0026#34;|\u0026#34;) self.name = String(splat.first ?? \u0026#34;\u0026#34;) self.maker = String(splat.last ?? \u0026#34;\u0026#34;) } } With this, we can instantiate a new Doll with a string with the format DOLL_NAME|DOLL_MAKER, as so:\nlet aliceDoll: Doll = \u0026#34;Classical Alice|Pullip\u0026#34; print(\u0026#34;\\(aliceDoll.name) was made by \\(aliceDoll.maker)\u0026#34;) // Prints \u0026#34;Classical Alice was made by Pullip This is one of my personal favorites, as it can help you create nice initializers for complex data.\nExpressibleByIntegerLiteral and ExpressibleByFloatLiteral These two are very similar, and as such they share the same section.\nIt is very easy to use a number to instantiate our objects. The following example declares MultipliedNumber, which takes a number and multiplies it by itself:\npublic class MultipliedNumber: ExpressibleByIntegerLiteral { let number: Int public required init(integerLiteral value: IntegerLiteralType) { self.number = value * value } } let myNumber: MultipliedNumber = 8 print(\u0026#34;myNumber is \\(myNumber.number)\u0026#34;) ExpressibleByBooleanLiteral I really like this one, because if you have an object that simply keeps track of different boolean states, you can use this to initialize them all to the same value.\npublic class DollFlags: ExpressibleByBooleanLiteral { var hasWig: Bool var hasStockOutfit: Bool var hasExtraAccessories: Bool public required init(booleanLiteral value: BooleanLiteralType) { self.hasWig = value self.hasStockOutfit = value self.hasExtraAccessories = value } } Now we can initialize them all to the same value by initializing it as so:\nlet flags: DollFlags = true You can naturally do much more with it, but this is one of my favorite use cases.\nExpressibleByArrayLiteral Now we will see two of the most interesting ones due to their additional constraints. because Arrays and Dictionaries are typed in Swift, we need to keep that in mind when using ExpressibleByArrayLiteral and ExpressibleByDictionaryLiteral.\nIn the following example, we will create an object that takes an array of numbers, multiplies them by themselves, and stores that result:\npublic class ArrayNumberMultipler: ExpressibleByArrayLiteral { public typealias ArrayLiteralElement = Int let numbers: [ArrayLiteralElement] public required init(arrayLiteral elements: ArrayLiteralElement...) { self.numbers = elements.map { $0 * $0 } } } These protocols use associated types to assign the data type of the elements. In our case, our object can be initialized with an array of integers, so we assign ArrayLiteralElement to Int.\nlet myNumbers: ArrayNumberMultipler = [2, 4, 6] print(myNumbers.numbers) // Prints \u0026#34;[4, 16, 36]\u0026#34; ExpressibleByDictionaryLiteral Finally, the last ExpressibleBy- protocol we will explore will allow us to instantiate objects with a dictionary. This can be very cool and handy in certain cases.\npublic class Doll: ExpressibleByDictionaryLiteral { public typealias Key = String public typealias Value = String let name: String? let maker: String? public required init(dictionaryLiteral elements: (Key, Value)...) { self.name = elements.filter { $0.0 == \u0026#34;name\u0026#34; }.first?.1 ?? \u0026#34;\u0026#34; self.maker = elements.filter { $0.0 == \u0026#34;maker\u0026#34; }.first?.1 ?? \u0026#34;\u0026#34; } } let doll: Doll = [\u0026#34;name\u0026#34;: \u0026#34;Classical Alice\u0026#34;, \u0026#34;maker\u0026#34;: \u0026#34;Pullip\u0026#34;] Once again, we have associated types, this time for the Key and Value of the dictionary.\nConclusion The ExpressibleBy- protocols are very helpful and they can help us write very expressive code. We shouldn\u0026rsquo;t abuse them as they can be shocking for someone looking at a codebase the first time, but when used in moderation, they are one of my favorite features of Swift.\n","tags":["swift","programming","apple"]},{"id":"03053c50c4c35916e208d2cc584a5a6e","title":"Getting Started with the App Store Connect API","link":"/posts/getting-started-app-store-connect-api/","content":"In 2018, Apple introduced the App Store Connect API. We as iOS developers interact with App Store Connect almost daily. We like to see our sales reports, analytics, check how our apps are doing. Occasionally, we may need to register a new device or manage our users.\nMany of these tasks are so common that it was necessary to get an App Store Connect API at some point. Having an API allows us to automatize some aspects of our day to day tasks on App Store Connect, and to make some tasks easier and faster. In this article, we will explore a few features of the App Store Connect API.\nThe App Store Connect API. Apple provides us with a nice and simple RESTful API, meaning that all you need to do to interact with it is perform a few pure HTTP calls. We need to authenticate ourselves providing a JWT (Jason Web Token) token.\nCurrent Features At the time of this writing (December 2020), App Store connect offer us endpoints for the following tasks:\nApp Management: We can create new versions of our apps, configure pre-orders, manage manage phased releases of new versions, and even submit our apps for review. App Metadata: We can edit our apps metadata, such as managing assets, edit the description, managing screenshots, and app previews. *Pricing and Availability: You can manage your app\u0026rsquo;s price and availability, price tiers, and more. Power and Performance: Introduced in WWDC2020, we can use this tool to monitor performance for our apps. We can get data for launch times, hang rates, disk writes, memory use, and battery life. This is the same API Apple uses to make such info available in Xcode. Provisioning: Manage bundle IDs, certificates, development devices, and provisioning profiles. Reporting: Manage Sales and Trends, allowing you to see first-time downloads, sales, proceeds, pre-orders, subscriptions, and more. We can also view our Payments and Financial reports with earnings by product, territory, currency, price, and more. The API will even show you how much you were paid each month and any money Apple may have withheld for tax or other reasons. TestFlight: You can automate tester management and build distribution. You can remove and add testers, manage tester groups, manage builds based on testers and tester groups, submit builds to beta review, and more. Users and Roles: You can manage Users and Roles. If you work on an organization, you can integrate with your own employee management tools, to have control over and link users between App Store and your own systems. Requesting App Store Connect API Access Requesting Permission To request App Store Connect API access, visit this link. You need to be the Account Holder to finish the process.\nI was under the impression that I needed approval and that my request would be reviewed manually. However after agreeing to the prompts, my request was instantly approved and I was able to use the API. I do not know if this is the case for everyone, or Apple does review some requests manually.\nKeys and Access Tokens. You need to create API keys, which you later use to create JWT access tokens.\nGenerating Keys. You can create up to 50 API keys, and you can limit the API access for each key. Once you create a key, you cannot edit its permissions.\nClick the \u0026ldquo;Generate API Key\u0026rdquo; button, and you will be greeted with the following view:\nYou can give it any name you want and select the permissions. If you choose \u0026ldquo;Admin\u0026rdquo;, your key will automatically get all the permissions, but you can pick and choose stricter permissions and as many as you need for your particular scenario.\nI named mine \u0026ldquo;Article Key\u0026rdquo; and chose \u0026ldquo;Admin\u0026rdquo; as the key type.\nNote: You probably know this, but just in case, do not share your API keys with people you don\u0026rsquo;t trust! While it may make sense to create keys for specific members of your team, remember that the keys have power over the specific permissions you granted when creating them. If your keys fall in the wrong hands, damage CAN be done. Shall your keys be compromised, you can revoke them from the same screen where you generated them.\nOnce you create the key, you have to download it. This is a file with a .p8 extension. You can only download your key once, so make sure you don\u0026rsquo;t lose it later.\nMake a mental note of the Key ID (this info is always visible), as you will need it to generate your JWT tokens.\nGenerating Access Tokens JSON Web Tokens are JSON payloads encoded in Base64 and signed with your private key for their transmission to the App Store Connect API server. You can create your token with any text editor.\nTo create the token you will need the following info:\nYour private key (the .p8 file you got earlier) Your KEY ID (This is visible in the same screen where you generate API keys - the one I linked you to above). Your Issuer ID. To get this, go back once again to the page where you generate keys. The issuer ID is near the top of the page. The JWT Token We will now begin creating creating our JWT token. The token is made of a JWT header and a JWT Payload, both joined together and signed with our private key.\nThere are libraries out there that can do this for you. For this article, we will use the Ruby script Apple used at WWDC2018 to show how to generate the token. The script is below (token.rb):\nrequire \u0026#34;base64\u0026#34; require \u0026#34;jwt\u0026#34; ISSUER_ID = \u0026#34;YOUR_ISSUER_ID\u0026#34; KEY_ID = \u0026#34;YOUR_KEY_ID\u0026#34; PATH = \u0026#34;PATH_TO_YOUR_P8_FILE\u0026#34; private_key = OpenSSL::PKey.read(File.read(PATH)) token = JWT.encode( { iss: ISSUER_ID, exp: Time.now.to_i + 20 * 60, aud: \u0026#34;appstoreconnect-v1\u0026#34; }, private_key, \u0026#34;ES256\u0026#34;, header_fields={ kid: KEY_ID } ) puts token You may need to install the Ruby jwt dependency for it. If you have Homebrew and installed Ruby with it, simply run gem install jwt in a Terminal window and you will get the dependency.\nWhen you run the script (ruby token.rb), the console will print out the token you can use, with a lifetime of 20 minutes from the time it was generated.\nUsing the API. Once you have the token, you can finally start using the API. You need to include your token in every call as a header field called Authorization with the format Authorization: Bearer YOUR_TOKEN.\nThe following is a complete cURL request you can run the terminal:\ncurl -v -H \u0026#39;Authorization: Bearer [signed token]\u0026#39; \u0026#34;https://api.appstoreconnect.apple.com/v1/apps\u0026#34; If you don\u0026rsquo;t like the Terminal, you can also use something such as Postman to get a GUI.\nIn a future article, we will explore a little bit more of the features the API offers. I originally intended to make this article to explore the API itself, but I spent more time than expected generating the token. Look forward to that. In the meantime, you can download the OpenAPI specification from here and play around with what you find.\nConclusion The App Store Connect API has many features to help with automation. It has seen steady growth in terms of features each WWDC, and we can expect it to become better.\n","tags":["apple","app store connect","programming"]},{"id":"ddb6dcfa55be0f897fc13309d2a5e208","title":"Understanding the Limited Photo Library in iOS 14","link":"/posts/understanding-limited-photo-library-ios-14/","content":"This year, Apple introduced a new feature that gives users even more control over what photos may third party apps see when they see a Photo Picker. The system will first present an alert asking users if they want to give access to their photos at all, and they have the option to give access to all their photos, or only to the photos they choose.\nThis is great, but it has been a very confusing experience for both users and developers alike. In this article we will explore this new privacy-focused photo picker and how to make good use of it without compromising too much of either usability and privacy.\nThe New Limited Photos Library Up until know, if an app asked for permission to use photos, the app got access to all of them through the PhotoKit APIs. In iOS 14, the limited photo access feature presents a system prompt where users can choose which photos will be available, and to which apps. That is to say, they can choose to give access to certain photos to one app, and a completely different set to other apps, meanwhile giving full library access to apps they fully trust.\nThe new photo app will even apply to apps that weren\u0026rsquo;t shipped with iOS 14 support out of the box. As this is a system feature, the prompt, being a system one, can show up on top of any app.\nUsers can manage their selection in a few ways.\nThe first one is to send them to Settings. In the Settings for your app, users can modify the photo access. Once again, they will have the option to give access to the whole library, or only a few photos. When the user chooses to select photos, a new button to select photo access will appear under the option selector. Below are some screenshots I took for the Twitter app.\nNote that when a user limits photo access to your app, you still have access to all the information you had before at an individual photo level. The functionality only limits access to assets themselves, not their metadata.\nFor apps that haven\u0026rsquo;t made any changes to their photo library handling code, the app can prompt the user, once per launch session, if they want to keep their library selection or if they want to change it.\nThe Motivation As we said above, this feature exists to give users more control over the data they make available to third party data. In a WWDC2020 session video, Apple said that users don\u0026rsquo;t like to give access to their whole libraries, because they have been growing over time, and they want to feel they have more control over that data.\nThe Alternatives The prompts we saw above are displayed to users when the app wants to access assets directly. In general, there\u0026rsquo;s very little need to ask access to entire photo libraries.\nApple has introduced the new PHPicker class in iOS 14. This class is a replacement for UIImagePickerController which has many more features. The new picker provides a system UI to let users search their libraries and select multiple photos and videos. The best part is, since this is a system prompt, the user will never be prompted about giving access to their photos to your app. Unless you have a good reason to request access to user photos directly (specific cases include photo backup apps), you should adopt this picker instead, which has many improvements over the old UIImagePickerController. It makes it better for users to search for the photo they want in huge libraries.\nAlso, in the past, camera apps had to request full read/write access to the library to be able to take photos and save them. This didn\u0026rsquo;t make sense, as most camera apps would only want write access. There are new workflows to support this kind of situations.\nAdopting Explicit Limited Library Support Authorization Status If you ever thought Apple wouldn\u0026rsquo;t add more enum values to their APIs that have an authorization status, you now know they can. When requesting photo access, the system will give you back the new .limited case of PHAuthorizationStatus when users choose to limit access. There is also a new enum called PHAccessLevel. This value can be add only or read/write access.\nUI Considerations Earlier we said that apps that don\u0026rsquo;t have code to work with the limited library, can only change their access through Settings or by having the app automatically prompt the user if they want to change their selection, once per launch session.\nTo make the experience better, you should add a button or other UI elements to let users trigger the system prompt. To do this, you can call the new presentLimitedLibraryPicker(from:) method of PHPhotoLibrary.\nlet library = PHPhotoLibrary.shared() library.presentLimitedLibraryPicker(from: viewController) The system prompt can be annoying. The good news is that we can suppress it by setting PHPhotoLibraryPreventAutomaticLimitedAccessAlert key in our Info.plist to yes. If you already deal with the new limited photo library, you don\u0026rsquo;t need the system to alert your users, as you have code to show the picker as necessary.\nNote that you need to import PhotosUI to use this feature.\nConclusion The new limited photo library exists for privacy reason. Before you even make use of these APIs, you should ask yourself if you really need to access user photos, or if the new PHPhotoPicker can do the work for you. If you must access the assets directly, adopt the new features and suppress the alert to make the photo picker experience smoother.\n","tags":["swift","programming","apple","wwdc2020"]},{"id":"ff04cad987c23a4113c08ca91541ee98","title":"Lazy Sequences in Swift","link":"/posts/lazy-sequences-in-swift/","content":"Lazy Sequences in Swift\nIf you have been writing Swift for a while, you have undoubtedly used high order functions such as .map and filter. These higher order function work on any collection, and they are very useful when we want to quickly transform objects into something else, or when you want to do other operations in sequences that would otherwise take more than one line of code if you were to make them with loops.\nHowever, applying these higher order functions to collections directly can pose some implications regarding performance and memory usage. If you have an array of 1000 elements of an object of type X, when you apply map to it, it will operate over all 1000 elements to create your new array of objects of type Y. Now, 1000 elements is very tiny for a computer with the power of an iPhone, but what if you have much bigger collections?\nThis is where lazy sequences come into play.\nstruct Character { let name: String } let characters = [\u0026#34;Elize\u0026#34;, \u0026#34;Arietta\u0026#34;, \u0026#34;Anise\u0026#34;] let mappedCharacters = characters.map { Character(name: $0) } // A new collection of 3 elements let lazyMappedCharacters = characters.lazy.map { Character(name: $0) } // This won\u0026#39;t execute any code until you need it. print(lazyMappedCharacters[2]) In this example, we want to convert an array of [String] into [Character]. mappedCharacters will go ahead and map all the strings into Characters and store it, doing more work and using more memory, whereas, when you use lazyMappedCharacter, your .map closure won\u0026rsquo;t be called immediately. Instead, the closure will be stored and it will be called as you need it. When we print lazyMappedCharacters[2], the lazy collection will take the original collection, search for index 2, apply the closure to it, and return it.\nWhen to use lazy sequences? When to use the standard sequences? At a first glance, after you reading this, you may be tempted to just go back to all your .map/.filter calls and change them to call .lazy on all of them. Don\u0026rsquo;t do that.\nFirst, know that lazy sequences don\u0026rsquo;t implement any sort of cache, so if you keep calling lazyMappedCharacters[2] over and over again, the closure will be applied over and over again and therefore the mapped value will be calculated each time.\nSecond, if you use .filter and you want to .count the number of elements in the resulting sequence, be aware that filter will have to go through all the elements to give you the total count. If you need to .count, you should use .filter on a non-lazy sequence. Operating on lazy collections is slower than operating on non-lazy ones, so you may think that calling .count in a non-lazy or lazy sequence is the same - it\u0026rsquo;s not.\nOn the other hand, if you consider you don\u0026rsquo;t have memory to spare, or you don\u0026rsquo;t need to do something with all the results of a .filter or .map immediately, you could use lazy collections. For example, if you are consuming a web service and want to convert all the JSON into user objects, you can avoid mapping the JSON that is not currently visible to the user by using .lazy.\nIf you find yourself in a situation which you genuinely don\u0026rsquo;t know which one to use, I\u0026rsquo;d recommend opting to use standard sequences over lazy ones. Lazy is great, but it can be seen as premature optimization for some, and while you may have some uses for it in mind, you may find yourself in the unexpected scenarios in which you do need to do that .count call after all, completely voiding .lazy\u0026rsquo;s benefits and actually writing worse-performing code.\nConclusion .lazy sequences are an interesting tool to add to your arsenal. They have performance implications that can sometimes be better or worse. Use them wisely, and don\u0026rsquo;t mindlessly apply their use everywhere unless you have a good reason to.\n","tags":["swift","apple","sequences"]},{"id":"86daa1ef9c3e3b58bfd42010d8057c27","title":"Quick Tip: Custom Debug Printing with CustomDebugStringConvertible in Swift","link":"/posts/quick-tip-custom-debug-printing-customdebugstringconvertible-swift/","content":"Printing stuff to the console is a simple but powerful step we can take when debugging our apps. But there are times when we want to print an object and we actually get something entirely different, often also useless.\nFor example, this commonly happens when working with classes and printing instances of them.\nclass User { let id: Int let name: String init(id: Int, name: String) { self.id = id self.name = name } } let andy = User(id: 1, name: \u0026#34;Andy\u0026#34;) print(andy) In a playground, this will print:\n__lldb_expr_6.User This won\u0026rsquo;t really help us find or observe our objects as they get printed to find issues in our app.\nIntroducing CustomDebugStringConvertible Luckily for us, Swift comes with the CustomDebugStringConvertible which we can adopt to print custom types. By using this protocol, we can make it so print prints more relevant info to the console when working with our custom objects.\nTo adopt it, you simply need to implement the debugDescription property. This property is of type String and you can return any string you want.\nclass User: CustomDebugStringConvertible { let id: Int let name: String init(id: Int, name: String) { self.id = id self.name = name } var debugDescription: String { return \u0026#34;\u0026#34;\u0026#34; ----------------------------------------------- User ID: \\(id) Name: \\(name) ----------------------------------------------- \u0026#34;\u0026#34;\u0026#34; } } Now, when we print(andy), we will get this in the console:\n----------------------------------------------- User ID: 1 Name: Andy ----------------------------------------------- Printing More Properties with Reflection and CustomDebugStringConvertible If you have objects with many properties, it will take a good amount of effort to print all the properties of your object. To go around this, we can leverage reflection to quickly get and iterate over the properties of our object.\nvar debugDescription: String { let mirror = Mirror(reflecting: self) var debugString = \u0026#34;----------------\u0026#34; mirror.children.forEach { debugString += \u0026#34;\\n\\($0.label ?? \u0026#34;\u0026#34;): \\($0.value ?? \u0026#34;\u0026#34;)\u0026#34; } debugString += \u0026#34;\\n----------------\u0026#34; return debugString } ---------------- id: 1 name: Andy ---------------- Conclusion While I still prefer breakpoints when it comes to debugging, getting proper prints is useful, especially if you want to observer the values of multiple variables, probably in different scopes, and don\u0026rsquo;t want to deal with a breakpoint on each. Hopefully this also helps library developers implement \u0026ldquo;print-friendly\u0026rdquo; objects.\n","tags":["swift","programming","apple"]},{"id":"aca1de882a4349f48a5ac953a52f59b0","title":"Understanding KeyPaths in Swift","link":"/posts/understanding-keypaths-swift/","content":"KeyPath. It sounds like a very fancy word. And it is a feature you have likely used it, either knowingly or unknowingly. KeyPaths are one of my favorite features in Swift, but they can be a bit tricky to understand. In this article we will explore what KeyPaths are, and when you may want to use them.\nUnderstanding KeyPaths In simple words, a KeyPath is a reference to an actual property instead of a value.\nKeyPaths basics. As we said above, KeyPath is a reference to a property instead of a value. If you can\u0026rsquo;t wrap your head around this concepts, imagine a normal variable pointing to a normal value, such as:\nlet dollName = \u0026#34;Classical Alice\u0026#34; The variable points to a value, and we can access that value anytime by just writing the variable name.\nlet completeDollName = \u0026#34;Pullip \\(dollName)\u0026#34; Everytime we write dollName, we are getting the value stored by that property.\nOpposite to that, KeyPaths can hold a property itself.\nKeyPaths point to properties in an object, so to show you how to create and use them, we will create a Doll object with three basic properties.\nclass Doll { let maker: String let name: String let releaseYear: Int init(name: String, maker: String, releaseYear: Int) { self.name = name self.maker = maker self.releaseYear = releaseYear } } let classAlice = Doll(name: \u0026#34;Classical Alice\u0026#34;, maker: \u0026#34;Groove\u0026#34;, releaseYear: 2013) When we are referencing a KeyPath, we start with a backwards slash \\, followed by the definition of the object (the class or struct name), followed by the property we want to \u0026ldquo;point\u0026rdquo; to.\nlet dollMaker = \\Doll.maker print(dollMaker) \\Doll.maker gives as a reference to the maker property of Doll. If you print dollMaker, Swift will print some weird meta info about the object, but that\u0026rsquo;s OK - A KeyPath is a reference to a property! And you should not expect it to return a value directly.\nBy the time you do want to get a value when you have a KeyPath, the keyPath will help you do just that.\nlet dollMaker = \\Doll.maker let aliceMaker = classAlice[keyPath: dollMaker] print(aliceMaker) // Pullip When using KeyPaths within an object definition itself, you can omit the definition name, like this:\nclass Doll { //... func getMaker() -\u0026gt; String { return self[keyPath: \\.maker] } } The Usefulness of KeyPaths I can hear some of you rumbling in the back, wondering why in the heck would this ever be useful to anyone. There\u0026rsquo;s a few reasons for this.\nFirst, KeyPaths are actually nothing new. They are used all over Apple\u0026rsquo;s frameworks, and all Swift actually did was to provide a much better syntax for dealing with KeyPaths. Objective-C does support KeyPaths, but they are provided as strings when you need them, and this is error prone. In the beginning, Swift actually ported this mechanism directly, but through the process of its evolution, Swift arrive at this new syntax which won\u0026rsquo;t let you introduce bugs based on simple typos when writing a KeyPath.\nIf you have played with SwiftUI, you have likely seen the ForEach and List views. These views expect an Identifiable object, but when you don\u0026rsquo;t have them, you can provide a KeyPath to tell them what property to use to consider your data source as unique.\nlet dollArray = [classAlice, eileen, delia] ForEach(dollArray, id: \\.name) { // Do something with each doll } ForEach and List operate on unique data and they have internal optimizations to do their work. If our views are not Identifiable, we have a way to tell them to treat a property as unique. We do with KeyPaths. We are providing them with the Doll.name KeyPath and the views will assume the doll names are the unique property for each model. There is no other way to \u0026ldquo;explain\u0026rdquo; ForEach what property it should use to look for uniqueness.\nKeyPaths are very powerful if you know how to use them.\nSecond, KeyPaths enable us to do what\u0026rsquo;s called metaprogramming. Metaprogramming is a concept in which a program uses another program as its data. When it comes to KeyPaths, our apps themselves are their own data. This funky concept opens a lot of doors, and the best thing is, in Swift, it does in a very safe manner. Metaprogramming in Objective-C through KeyPaths is very possible, but as we said above, it doesn\u0026rsquo;t have specialized KeyPath types, but rather it just uses KeyPaths as strings.\nOne more important thing before we move in, KeyPaths can reference properties nested deeply in other objects. Consider the following example:\nclass Maker { let name: String let fundedYear: Int let producedDolls: Int init(name: String, fundedYear: Int, producedDolls: Int) { self.name = name self.fundedYear = fundedYear self.producedDolls = producedDolls } } class Doll2 { let maker: Maker let name: String let releaseYear: Int init(name: String, maker: Maker, releaseYear: Int) { self.name = name self.maker = maker self.releaseYear = releaseYear } } let groove = Maker(name: \u0026#34;Groove\u0026#34;, fundedYear: 2004, producedDolls: 100) let alice2 = Doll2(name: \u0026#34;Classical Alice\u0026#34;, maker: groove, releaseYear: 2013) We have created a new Maker object, so each doll will reference the company that created them.\nNow, consider the following KeyPaths:\nlet dollMakerFundedYearKeyPath = \\Doll2.maker.fundedYear let makerFundedKeyPath = \\Maker.fundedYear let fundedYear = alice2[keyPath: dollMakerFundedYearKeyPath] let fundedYear2 = alice2[keyPath: makerFundedKeyPath] It\u0026rsquo;s very important to keep in mind that Doll2.maker.fundedYear, and \\Maker.fundedYear may look like they are pointing at the same property, they are not. These KeyPaths are entirely different, and they point to different things. Namely, the former points to a maker.fundedYear property, whereas the latter points simply to a fundedYear. KeyPaths are\u0026hellip; Paths. Each period digs deeper in a property hierarchy, and it can become quite lengthy.\nThe neat thing about Swift is that the code above won\u0026rsquo;t even compile. Because Doll doesn\u0026rsquo;t have a fundedYear property, the compiler will catch the warning and it will stop you from introducing interesting bugs (looking at you, Objective-C).\nPassing KeyPaths Around If you have tried to print a KeyPath directly, you have seen the console print something like this:\nSwift.KeyPath\u0026lt;__lldb_expr_15.Doll2, Swift.Int\u0026gt; Swift.KeyPath\u0026lt;__lldb_expr_15.Maker, Swift.Int\u0026gt; Swift.KeyPath\u0026lt;__lldb_expr_15.Doll, Swift.String\u0026gt; When dealing with KeyPaths, we have a literal object called KeyPath - There\u0026rsquo;s a few more variations of KeyPaths, but we will explore them in a future article.\nFirst we are going to explore an example that is not very useful in the real world, but it should help you get the hang of KeyPaths and why they are useful.\nThe following function takes a Doll2, and returns the value of any String property you want.\nfunc getPropertyValue(in doll: Doll2, keyPath: KeyPath\u0026lt;Doll2, String\u0026gt;) -\u0026gt; String { return doll[keyPath: keyPath] } //... let groove = Maker(name: \u0026#34;Groove\u0026#34;, fundedYear: 2004, producedDolls: 100) let alice2 = Doll2(name: \u0026#34;Classical Alice\u0026#34;, maker: groove, releaseYear: 2013) print(getPropertyValue(in: alice2, keyPath: \\.name)) // Classical Alice print(getPropertyValue(in: alice2, keyPath: \\.maker.name)) // Groove We can make this slightly more interesting, by adding generics and therefore being able to get the value of any property we want.\nfunc getPropertyValue\u0026lt;Value\u0026gt;(in doll: Doll2, keyPath: KeyPath\u0026lt;Doll2, Value\u0026gt;) -\u0026gt; Value { return doll[keyPath: keyPath] } print(getPropertyValue(in: alice2, keyPath: \\.releaseYear)) // 2013 print(getPropertyValue(in: alice2, keyPath: \\.maker.fundedYear)) // 2004 Let\u0026rsquo;s make a slightly more interesting example. While this example is not hard to recreate it with the usual high-order functions directly, I deliberately chose this one to show you how powerful KeyPaths are, and how dynamic the code you write can become.\nextension Array where Element: Doll2 { func filtered\u0026lt;Value: Equatable\u0026gt;(by keyPath: KeyPath\u0026lt;Element, Value\u0026gt;, value: Value) -\u0026gt; [Element] { return Array(filter { $0[keyPath: keyPath] == value }) } } This looks like a mouthful. A quick explanation is in order.\nWe are creating an extension that will apply to Array objects that contain Doll2 objects. This extension has a filtered(by:value) function. This function will filter an array based on a KeyPath and its value, so if we want to keep all the dolls whose maker is Groove, it can do that. We use a generic called Value that conforms to equatable - in other words, values that can be compared, such as Strings, Ints, or anything else that can use == to compare amongst two instances of their own kind. Within the function we grab the KeyPath and compare it to the expected value.\nWhen we want to filter Doll2 arrays, we can call this as so:\nlet grooveMaker = Maker(name: \u0026#34;Groove\u0026#34;, fundedYear: 2004, producedDolls: 100) let myouMaker = Maker(name: \u0026#34;Myou\u0026#34;, fundedYear: 2012, producedDolls: 50) let classAlice = Doll2(name: \u0026#34;Classical Alice\u0026#34;, maker: grooveMaker, releaseYear: 2013) let eileen = Doll2(name: \u0026#34;Eileen\u0026#34;, maker: grooveMaker, releaseYear: 2018) let delia = Doll2(name: \u0026#34;Delia\u0026#34;, maker: myouMaker, releaseYear: 2016) let dolls = [classAlice, eileen, delia] let onlyGrooveDolls = dolls.filtered(by: \\.maker.name, value: \u0026#34;Groove\u0026#34;) onlyGrooveDolls.forEach { print($0.name) } // Prints: // Classical Alice // Eileen Conclusion KeyPaths open a lot of doors for us. By leveraging metaprogramming, we can write highly dynamic code. With Swift, this code is dynamic without sacrificing safety thanks to the fact we have literal KeyPath objects. KeyPaths also exist in Objective-C, but they aren\u0026rsquo;t as safe.\n","tags":["swift","programming","apple","keypaths"]},{"id":"24f1eae6531f4cbaa79b54e55a8f7a7e","title":"Quick Tip: Hosting JSON Files on Github for Free","link":"/posts/quick-tip-hosting-json-files-github-for-free/","content":"There are times in which you may want to host small JSON (or other small types of files) somewhere because your app needs them. Maybe you want to configure feature flags, or maybe you want to host IAP identifiers somewhere so as to not hardcode them in your app. This last case is something I did recently.\nThe immediate thought will be get a cheap server somewhere - after all, using something like Vultr you can get cheap hosting for as low as $2.50 per month. But did you know Github allows you to publish static websites, and you can piggyback that on that to store remote \u0026ldquo;config\u0026rdquo; about your apps?\nBefore moving, be aware that remotely configuring your app or using feature flags may get your app rejected or even removed post-approval. If you use this technique for feature flags, please consider being transparent with the App Review team, so they don\u0026rsquo;t think you are passing off un-reviewed functionality to end users.\nWith that out of the way, let\u0026rsquo;s host a small file in Github for small remote settings.\nYou can create a new repository or use an existing one without it clashing with your actual code. I prefer to keep a separate repository for all the simple files I use across my apps.\nIn the repository you want to host the files at, click *Settings and scroll down until you find Github Pages. Enable the feature there. You will need to select the branch and optionally a Jekyll theme. We don\u0026rsquo;t need Jekyll, which is a static site generator. Just select the branch, and you are done.\nWhen you save it, Github will give you the link where all the content will be reachable.\nIn my case, the URL is http://www.andyibanez.com/fairesepages.github.io/ because I have a custom domain which is in another repo where I host this website. If you don\u0026rsquo;t have a custom domain, worry not, it will give you a URL you can print for free.\nThen you just need to create the files and commit them there.\nThis is the file I have to create the Shop screen of Silvianna:\nhttps://www.andyibanez.com/fairesepages.github.io/silvianna-iap.json\nI then use this data in my app to build this screen:\nFeel to use this technique when you need to host mostly static files. You will be able to change the files, but since you cannot run server-side logic, don\u0026rsquo;t expect to do anything complicated that would require logic or backend storage.\nConclusion Sometimes we need to host small files, but there\u0026rsquo;s no justification in paying a monthly fee for it. If you need to host absolutely simple files, you can go down this route.\nYou can also do this to host the minimum pages Apple requires for your app, including your Privacy Policy and Support Page.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos"]},{"id":"67025964280422f2d7bf366386c21a47","title":"Parsing Tricky JSON With Codable in Swift","link":"/posts/parsing-tricky-json-codable-swift/","content":"If you have been writing Swift in the past couple of years, you have probably been using Codable (which is really just the composition of Decodable and Encodable in the same protocol).\nIf you have been writing iOS apps for longer, you likely know about JSONSerialization as well, which is the backbone of Codable and it allows you to do more manual work when parsing JSON, seemingly giving you more control.\nIf you know JSONSerialization, you have probably found times in which Codable seemingly doesn\u0026rsquo;t give you the flexibility you need, and you may have been tempted to drop Codable in favor of JSONSerialization when parsing very specific or even corrupted JSON.\nCodable is actually more powerful than you expect, and if you know how to use it fully, you will never need to drop down to JSONSerialization for those cases when Codable seems like it\u0026rsquo;s holding you back.\nIn this article, we will explore one feature of Codable that makes it parsing tricky JSON possible by exploring two specific scenarios:\nWhen you have a field that seems to return different data types in different situations, and when you have a field that is a collection such as an array or a dictionary, but the datatype within this collection varies. My intention is to show you these specific situations because I have dealt with them in the real world, and because the methods you will learn here to can give you other ideas for working with different cases of \u0026ldquo;malformed\u0026rdquo; (but valid) JSON.\nTricky JSON Unless you can have any kind of influence over the backend, you shouldn\u0026rsquo;t really expect JSON to be perfect (and actually, my own experience at my job has shown me that there\u0026rsquo;s times even when you can ask for backend changes, it\u0026rsquo;s not possible to be done, or not worth it). There\u0026rsquo;s many cases in which Codable can already help you. being able to declare properties as optionals already does a huge job dealing with missing properties. So even if a JSON returns a field that should exist, there are times when you can get the job done providing a default value yourself.\nBut when our JSON has unexpected different datatypes, things can be messy. Even if you have a field marked as an optional, if Codable finds it, it will try to parse it with that datatype and throw an error if it is something else.\nDealing With Different Datatypes When I started my current job, I started migrating some very old legacy Objective-C code into Swift. One of these tasks involved migrating an Objective-C parser that relied on JSONSerialiation to parse content into our objects. We never needed to operate on this field. Essentially we had to receive it, and pass it back to the backend as-is.\nBecause of this, and the nature of JSONSerialization, nobody ever realized that this value was sometimes returning as a string, and sometimes as a number. It really didn\u0026rsquo;t matter. Below is an example of the object in question and the kind of data it returned. This is not the real code I found at my job, but it\u0026rsquo;s very easy to recreate:\n{ \u0026#34;username\u0026#34;: \u0026#34;aibanez\u0026#34;, \u0026#34;phone_number\u0026#34;: 1234567, \u0026#34;identifier_hash\u0026#34;: \u0026#34;ABXAASDASFASFS\u0026#34; } I called this object UserInfo, and it returned as a nested object in multiple calls, such as:\n/last_login_info { \u0026#34;login_date\u0026#34;: \u0026#34;2020-05-05T05:00:00-04:00\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;Bolivia\u0026#34;, \u0026#34;ip_address\u0026#34;: \u0026#34;192.168.0.1\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;aibanez\u0026#34;, \u0026#34;phone_number\u0026#34;: 1234567, \u0026#34;identifier_hash\u0026#34;: \u0026#34;ABXAASDASFASFS\u0026#34; } } /login { \u0026#34;process_token\u0026#34;: \u0026#34;ABCASD\u0026#34;, \u0026#34;previous_device_name\u0026#34;: \u0026#34;iPhone 11 Pro Max\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;aibanez\u0026#34;, \u0026#34;phone_number\u0026#34;: \u0026#34;1234567\u0026#34;, \u0026#34;identifier_hash\u0026#34;: \u0026#34;ABXAASDASFASFS\u0026#34; } } The first call is used to retrieve the last session information when you launch the app. If you download the app on a new device, the app calls the last method and returns that JSON.\nYou can clearly see the red flag here. phone_number is an integer in one call, and a string in another!\nIn the beginning this was problem because I told the backend about this inconsistency and they wouldn\u0026rsquo;t fix it. Also note that this object in real life is much more expansive. Tens of fields in one request. The quick solution at the time was to create two classes for UserInfo - UserInfoString, and UserInfoInt. Luckily I had a bit of time to research a real solution.\nI started by declaring UserInfo as such:\nclass UserInfo: Codable { let username: String let phoneNumber: Int let identifier: String enum CodingKeys: String, CodingKey { case username = \u0026#34;username\u0026#34; case phoneNumber = \u0026#34;phone_number\u0026#34; case identifier = \u0026#34;identifier_hash\u0026#34; } } And the two objects that had this nested object:\nclass LastLogin: Codable { let loginDate: String let country: String let ipAddress: String let user: UserInfo enum CodingKeys: String, CodingKey { case loginDate = \u0026#34;login_date\u0026#34; case country = \u0026#34;country\u0026#34; case ipAddress = \u0026#34;ip_address\u0026#34; case user = \u0026#34;user\u0026#34; } } class LoginInfo: Codable { let processToken: String let previousDeviceName: String let user: UserInfo enum CodingKeys: String, CodingKey { case processToken = \u0026#34;process_token\u0026#34; case previousDeviceName = \u0026#34;previous_device_name\u0026#34; case user = \u0026#34;user\u0026#34; } } At this point, we can only parse one of them. Whoever has the phone number as a string will fail (the JSON returned by /login).\nTo solve this, you can manually implement the required initializer provided by Decodable. Inside it you can parse each expected field, one by one.\nThis is how the initializer was implemented in UserInfo:\nrequired init(from decoder: Decoder) throws { let container = try decoder.container(keyedBy: CodingKeys.self) self.username = try container.decode(String.self, forKey: .username) self.identifier = try container.decode(String.self, forKey: .identifier) // Try to parse the phone number as an int first. do { self.phoneNumber = try container.decode(Int.self, forKey: .phoneNumber) } catch { // Parsing it as an int failed. We will try to parse it as a string. let phoneString = try container.decode(String.self, forKey: .phoneNumber) if let phoneInt = Int(phoneString) { self.phoneNumber = phoneInt } else { throw error } } } In my particular case, I knew username and identifier_hash were always going to return strings, which is why I just parse those two fields directly.\nWhen attempting to parse the phone number, the parser first tries to parse it as an Int as that is the datatype in the model. If that fails, we will try to parse it into a temporary String variable. We then try to convert it into into an integer - if it succeeds, we will assign the variable and go on with on with our day. If it fails, we will rethrow the error telling us phone_number expected a String, but found something else instead. If the error is rethrown, we will have to look into the JSON and see what it is returning. This is not likely to happen in this specific case, but it could if you were parsing a field that expected a number but suddenly returned floating points or even strings.\nAlso, keep in mind that if your object had optional fields, you can use container.decodeIfPresent instead of container.decode. This will allow nil values to be ignored, though errors will be thrown if the value does exist and it\u0026rsquo;s of an unexpected data type.\nDealing with Different Datatypes Within Collections I found this \u0026ldquo;tricky JSON\u0026rdquo; situation working on my weekend app. My app, Silvianna, is a client for a website called Anilist - an anime and manga database where you can search, find, and discover new anime to watch or manga to read.\nThey use a GraphQL API, but due to implementation details on their side, I couldn\u0026rsquo;t just parse the responses using something like Apollo. Instead, I created objects for everything I wanted to parse.\nOne specific response returned a dictionary like this:\n{ \u0026#34;advancedScores\u0026#34;: { \u0026#34;Story\u0026#34;: 0, \u0026#34;Characters\u0026#34;: 0, \u0026#34;Visual\u0026#34;: 0, \u0026#34;Audio\u0026#34;: 0, \u0026#34;Enjoyment\u0026#34;: 0 } } Users can configure their own advanced scoring parameters, so I had to parse this as a dictionary of type [String: Double].\nAnilist is supposed to return Doubles here, but I discovered when parsing a huge array that contained this nested object, that there was a case in which it returned something like this instead:\n{ \u0026#34;advancedScores\u0026#34;: { \u0026#34;Story\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;Characters\u0026#34;: 0, \u0026#34;Visual\u0026#34;: 0, \u0026#34;Audio\u0026#34;: 0, \u0026#34;Enjoyment\u0026#34;: 0 } } For reasons entirely unknown to me (and to the people who had worked with the Anilist API), the \u0026ldquo;Story\u0026rdquo; key was returning with its value as a String. This only happened in one object in a gigantic array of around 900 objects that had this nested object.\nTo deal with this, I made the assumption that the values here are always floating points. My decision was backed up by the Anilist docs and by the community who had used the API.\nBefore I stumbled upon this problem, my model looked like this (simplified):\nclass UserMediaEntry: Codable { let advancedScores : [String: Double] } In order to parse the value of the dictionary, I ended up creating an intermediary object called WrappedDouble.\nThe Decoder object we receive from the required init(from decoder: Decoder) has one more useful container: singleValueContainer(). We can use it to decode a single value without having to pass in the CodingKeys or anything like that.\nThe implementation of wrapped value is as follows:\nclass WrappedDouble: Codable { let value: Double required init(from decoder: Decoder) throws { let container = try decoder.singleValueContainer() do { // Try to parse it as a Double value = try container.decode(Double.self) } catch { let tempString = try container.decode(String.self) if let convertedDouble = Double(tempString) { value = convertedDouble } else { throw error } } } } This parser will take in a single value, and the rest of the logic is pretty straightforward: We try parsing this object as a Double first, and if that fails, we try to parse it as a String.\nThe UserMediaEntry object above now needs to be modified. We will also do slightly more manual parsing. We are not going to modify the datatype of advancedScores at all. Instead we will parse the Doubles out using our DoubleWrapper object, get the value, and finish creating UserMediaEntry with them:\nclass UserMediaEntry: Codable { required init(from decoder: Decoder) throws { let decoder = try decoder.container(keyedBy: CodingKeys.self) let wrappedDoubleDic = try decoder.decode([String: WrappedDouble].self, forKey: .advancedScores) advancedScores = wrappedDoubleDic.mapValues { $0.value } } let advancedScores : [String: Double] } Pretty straightforward. Once we have our DoubleWrapper object, we can try to parse a given key using [String: DoubleWrapper]. DoubleWrapper can get a double out of a Double itself or a String. If our init can parse that dictionary, we than map it to a new dictionary keeping the keys, but transforming them to Double instead.\n(Aside note: Dictionary.mapValues will map all the dictionary values keeping their keys, so it\u0026rsquo;s perfect to convert our DoubleWrapper into Double without any issues).\nConclusion JSON is oftentimes a format that is out of our control. Luckily Codable actually provides all the tools we need to parse extravagant JSON responses without having to drop down to JSONSerialization. Often times when dealing with broken (but valid) JSON, the first solution we may think of is to use the lower level APIs, but by manually overriding init(from), we can do manual parsing even easier.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","codable"]},{"id":"0628428c635827e918368a39ad252ec3","title":"A More Practical Custom Formatter ","link":"/posts/a-more-practical-custom-formatter/","content":"I had announced that I wouldn\u0026rsquo;t be able to write an article this week due to it being Elections Day in my country. that said I just can\u0026rsquo;t leave you guys without article, so this is a short one.\nWe will write another NSFormatter subclass. It will allow us to compose E-mails easily. This should also help show that formatters can format string into anything else really.\nIn short, we will be able to \u0026ldquo;compose\u0026rdquo; emails using raw strings, like this:\nTO: andy@andyibanez.com FROM: andy.cito@gmail.com CC: gg@hotmail.com, rk@hotmail.com BCC: myboss@gmail.com,myarchitect@gmail.com SUBJECT: Important Notice BODY: Hello guys. Just wanted to let you know that this is a very important notice. The notice has been sent and it\u0026#39;s importance has priority one. Please take note of the importance, and share it with everyone you need to. We will be able to convert that into this:\nclass Email { let to: String? let from: String? let subject: String? let cc: [String]? let bcc: [String]? let body: String? init( to: String? = nil, from: String? = nil, subject: String? = nil, cc: [String]? = nil, bcc: [String]? = nil, body: String? = nil) { self.to = to self.from = from self.subject = subject self.cc = cc self.bcc = bcc self.body = body } } And viceversa.\nThe only constraint will be that the BODY: always has to go last. Any fields can be missing and they will be filled as nil when appropriate.\nThe EmailFormatter Class The EmailFormatter will format plain text into emails and the other way around. It will inherit from Formatter.\nOverriding string(for:) We will start by implementing override func string(for obj: Any?), as it is the easiest case. This object will ultimately take an Email and return the string representation of it.\noverride func string(for obj: Any?) -\u0026gt; String? { guard let email = obj as? Email else { return nil } var stringRep = \u0026#34;\u0026#34; if let to = email.to { stringRep += \u0026#34;TO: \\(to)\\n\u0026#34; } if let from = email.from { stringRep += \u0026#34;FROM: \\(from)\\n\u0026#34; } if let cc = email.cc { let joined = cc.joined(separator: \u0026#34;,\u0026#34;) stringRep += \u0026#34;CC: \\(joined)\\n\u0026#34; } if let bcc = email.bcc { let joined = bcc.joined(separator: \u0026#34;,\u0026#34;) stringRep += \u0026#34;BCC: \\(joined)\\n\u0026#34; } if let subject = email.subject { stringRep += \u0026#34;SUBJECT: \\(subject)\\n\u0026#34; } if let body = email.body { stringRep += \u0026#34;BODY:\\n\\(body)\u0026#34; } return stringRep } We are also going to expose a prettier signature for our string formatter.\npublic func stringFor(_ email: Email) -\u0026gt; String? { return string(for: email) } Converting strings into Emails The hardest part is now to convert strings into our object. In this specific case, it isn\u0026rsquo;t too complicated, but know that it can become hairy quickly.\noverride func getObjectValue( _ obj: AutoreleasingUnsafeMutablePointer\u0026lt;AnyObject?\u0026gt;?, for string: String, errorDescription error: AutoreleasingUnsafeMutablePointer\u0026lt;NSString?\u0026gt;?) -\u0026gt; Bool { obj?.pointee = stringToEmail(emailString: string) return true } stringToEmail is implemented as such (can definitely be improved):\nfunc stringToEmail(emailString: String) -\u0026gt; Email { let splat = emailString.split(separator: \u0026#34;\\n\u0026#34;) var to: String? = nil var from: String? = nil var subject: String? = nil var cc: [String]? = nil var bcc: [String]? = nil var body: String? = nil for line in splat { if line.hasPrefix(\u0026#34;TO: \u0026#34;) { let toLine = line.split(separator: \u0026#34;:\u0026#34;) to = { if let to = toLine.last { return String(to) } else { return nil }}() } if line.hasPrefix(\u0026#34;FROM: \u0026#34;) { let fromLine = line.split(separator: \u0026#34;:\u0026#34;) from = { if let from = fromLine.last { return String(from) } else { return nil }}() } if line.hasPrefix(\u0026#34;SUBJECT: \u0026#34;) { let subjectLine = line.split(separator: \u0026#34;:\u0026#34;) subject = { if let subject = subjectLine.last { return String(subject) } else { return nil }}() } if line.hasPrefix(\u0026#34;CC: \u0026#34;) { let ccLines = line.split(separator: \u0026#34;:\u0026#34;).last?.split(separator: \u0026#34;,\u0026#34;).map { String($0) } cc = ccLines } if line.hasPrefix(\u0026#34;BCC: \u0026#34;) { let bccLines = line.split(separator: \u0026#34;:\u0026#34;).last?.split(separator: \u0026#34;,\u0026#34;).map { String($0) } bcc = bccLines } } let bodyStart = splat.firstIndex { $0.hasPrefix(\u0026#34;BODY: \u0026#34;) } let nextIndex = (bodyStart ?? 0) + 1 if nextIndex \u0026lt; splat.count { let linesToMerge = nextIndex..\u0026lt;splat.count body = linesToMerge.reduce(\u0026#34;\u0026#34;){ \u0026#34;\\($0 ?? \u0026#34;\u0026#34;)\\n\\(splat[$1])\u0026#34; } } return Email( to: to, from: from, subject: subject, cc: cc, bcc: bcc, body: body) } And with that, we have a formatter that can convert from and to strings and Email objects.\nSample usage is below:\nlet email = Email(to: \u0026#34;me@andyibanez.com\u0026#34;, bcc: [\u0026#34;gg@hotmail.com\u0026#34;, \u0026#34;rk@yahoo.es\u0026#34;]) let formatter = EmailFormatter() let string = formatter.stringFor(email) print(string!) let emailString = \u0026#34;\u0026#34;\u0026#34; TO: andy@andyibanez.com FROM: andy.cito@gmail.com CC: gg@hotmail.com, rk@hotmail.com BCC: myboss@gmail.com,myarchitect@gmail.com SUBJECT: Important Notice BODY: Hello guys. Just wanted to let you know that this is a very important notice. The notice has been sent and it\u0026#39;s importance has priority one. Please take note of the importance, and share it with everyone you need to. \u0026#34;\u0026#34;\u0026#34; let newEmail = formatter.email(from: emailString)! print(\u0026#34;We will send an email to \\(newEmail.to!) and \\(newEmail.cc!.count) others\u0026#34;) Conclusion Hopefully this article shows you a bit better everything you can do with your custom formatters. Having the flexibility to convert anything into string and back is great, and there\u0026rsquo;s support for it all over the frameworks.\n","tags":["nsformatter","swift","programming","apple","ios","ipados"]},{"id":"428e50e7c405754c36ba50e388748cad","title":"Silvianna for Anilist ","link":"/projects/silvianna/","content":"Silvianna is the best Anilist client for iOS.\nAnilist is the popular website for anime and manga fans, where you can keep track of your favorite series, or discover something new to watch or read.\nSilvianna comes packed with power features for list management. The app allows you to modify anything about items on your list as long as it is supported by Anilist.\nFEATURES:\nFriendly on the smallest iPhone and the biggest iPad. Keep track of series that are currently airing easily. Series that you haven\u0026rsquo;t watcheda all the episodes of and are currently airing will have a visible red banner telling you how many episodes behind you are, making it easy to keep track of everything you watch. When you finish watching a series, you will automatically be prompted for the rating. You no longer need to navigate through different screens if you weren\u0026rsquo;t able to rate something you watched. When rating a series, it will use the rating system currently set in your Anilist account. It doesn\u0026rsquo;t matter if you are using the standard 10 point system, 10 point decimal system, 5-star system, or even the Emoji system - Silvianna supports all the rating systems provided by Anilist. If your rating system supports Advanced Scoring, Silvianna will grab your parameters and you will be able to also perform advanced scoring according to your custom parameters. You have access to your Anilist profile, so you can access your Manga and Anime lists easily and quickly. Multiwindow support on the iPad. You can search the entire Anilist database for Anime and Manga. This is just the initial release of Silvianna, and we are excited to make the project grow with your feedback and ideas.\nTestFlight Link Click Here\n","tags":["ios","ipados","swift"]},{"id":"0f92cea018aa1c5f8dbf3936adde53ca","title":"Writing Custom NSFormatters in Swift","link":"/posts/writing-custom-nsformatters-swift/","content":"Last year we explored some NSFormatters and how to use them. We also explored some formatters introduced in iOS 13. Finally, a few weeks ago we learned about yet more formatters, and how to better use the ones we already had. In short, we have explored how powerful NSFormatter is. One thing we haven\u0026rsquo;t done yet though, is to write our own custom NSFormatter subclass.\nNSFormatter NSFormatter is an abstract class. All formatter classes inherit from it. In Swift, everything we need about it is open, so we can create our own NSFormatters with ease.\nOverriding NSFormatters The class comes with many methods you can override, but you must, at the very least, override the following:\nfunc string(for obj: Any?) -\u0026gt; String getObjectValue(_ obj: AutoreleasingUnsafeMutablePointer\u0026lt;AnyObject?\u0026gt;?, for string: String, errorDescription error: AutoreleasingUnsafeMutablePointer\u0026lt;NSString?\u0026gt;?) -\u0026gt; Bool These look a bit messy, especially the second method. The second method will return us a formatted object. It can be a string, or anything else that makes sense in the context of your app.\nOther methods you can override include:\nattributedStringForObjectValue:withDefaultAttributes: Suppose you have a string that is supposed to represent a big title and a smaller title underneath. You can use this formatter to format such strings. editingStringForObjectValue:: You can override this when you are editing a string and the string your users see are different. By default, this will call stringForObjectValue:. There\u0026rsquo;s a few other ones, but they are either only useful in macOS or very complicated to implement (beyond this article). We won\u0026rsquo;t implement all of the methods, but be aware they exist so you can write a formatter that fits your needs.\nEmojiFormatter To show how to write our own formatters, we will create EmojiFormatter. The formatter will take strings with old-school emoticons - such as :-), :-(, :-|, ;-( - and it will replace them with an actual emoji - like üôÇ, ‚òπÔ∏è, üòê, üò¢.\nBecause this formatter operates on strings and returns strings, we will define two things before moving on:\nThe String representation will be the string that contains the Emoji. For example, I'm happy to talk to you üôÇ. The original object will be the string with raw ASCII emoticons. I'm happy to talk to you :-). Implementing Emoji Formatter To write the class, start by subclassing Formatter and overriding the two mandatory methods:\nclass EmojiFormatter: Formatter { override func string(for obj: Any?) -\u0026gt; String? { } override func getObjectValue(_ obj: AutoreleasingUnsafeMutablePointer\u0026lt;AnyObject?\u0026gt;?, for string: String, errorDescription error: AutoreleasingUnsafeMutablePointer\u0026lt;NSString?\u0026gt;?) -\u0026gt; Bool { } } Next, we will add a property to make the formatting a bit easier through ASCII/emoji mapping.\nlet emojiMapping = [ \u0026#34;:-)\u0026#34;: \u0026#34;üôÇ\u0026#34;, \u0026#34;:-|\u0026#34;: \u0026#34;üòê\u0026#34;, \u0026#34;:-(\u0026#34;: \u0026#34;‚òπÔ∏è\u0026#34;, \u0026#34;;-(\u0026#34;: \u0026#34;üò¢\u0026#34; ] Next, implement two methods: One will replace ASCII with emoji, and the other will replace emoji with ASCII.\nfunc replaceAsciiWithEmoji(in string: String) -\u0026gt; String { var rawString = string emojiMapping.forEach { rawString = rawString.replacingOccurrences(of: $0, with: $1) } return rawString } func replaceEmojiWithAscii(in string: String) -\u0026gt; String { var rawString = string emojiMapping.forEach { rawString = rawString.replacingOccurrences(of: $1, with: $0) } return rawString } Finally, we need to implement the overriden methods in order to use this formatter. They are pretty straightforward.\noverride func string(for obj: Any?) -\u0026gt; String? { if let string = obj as? String { return replaceAsciiWithEmoji(in: string) } return nil } override func getObjectValue(_ obj: AutoreleasingUnsafeMutablePointer\u0026lt;AnyObject?\u0026gt;?, for string: String, errorDescription error: AutoreleasingUnsafeMutablePointer\u0026lt;NSString?\u0026gt;?) -\u0026gt; Bool { obj?.pointee = replaceEmojiWithAscii(in: string) as AnyObject return true } The last method looks complicated. It\u0026rsquo;s important to remember that (NS)Formatter is an Objective-C class, and thus it has kept most of its original interfaces when exposing it to Swift. The obj AutoreleasingUnsafeMutablePointer contains a reference to the object that will be returned upon converting the string into something. In this case, it\u0026rsquo;s a string.\nFormatter Usage With that, our formatter is done. We can get an ASCII representation of an emoji string like so:\nlet emojiFormatter = EmojiFormatter() print(emojiFormatter.string(for: \u0026#34;I\u0026#39;m happy to talk to you üôÇ how you doin\u0026#39;? üòê\u0026#34;) ?? \u0026#34;\u0026#34;) // I\u0026#39;m happy to talk to you :-) how you doin\u0026#39;? :-| To get a \u0026ldquo;formatted\u0026rdquo; emoji string - that is, to convert its ASCII representations to actual emoji, we need to do a little bit of more low-level stuff and bridging:\nvar formattedEmojiStringContainer: AnyObject? var fstring = \u0026#34;I\u0026#39;m happy to talk to you üôÇ how you doin\u0026#39;? üòê\u0026#34; var errorDescription: NSString? emojiFormatter.getObjectValue(\u0026amp;formattedEmojiStringContainer, for: fstring, errorDescription: \u0026amp;errorDescription) print(formattedEmojiStringContainer!) // I\u0026#39;m happy to talk to you :-) how you doin\u0026#39;? :-| Of course, this is less than ideal, and all formatters included in Foundation contain methods so developers don\u0026rsquo;t have to do that dirty work themselves. Before continuing, we are going to write a rawString(for emojiString: String) methods that takes a String with Emoji and turns them into ASCII emojis.\npublic func rawString(for emojiString: String) -\u0026gt; String? { var formattedEmojiStringContainer: AnyObject? getObjectValue(\u0026amp;formattedEmojiStringContainer, for: emojiString, errorDescription: nil) return formattedEmojiStringContainer as? String } And now we have a nice interface to formate ASCII emojis into actual emojis.\nprint(emojiFormatter.emojiString(for: \u0026#34;I\u0026#39;m happy to talk to you üôÇ how you doin\u0026#39;? üòê\u0026#34;) ?? \u0026#34;\u0026#34;) // I\u0026#39;m happy to talk to you :-) how you doin\u0026#39;? :-| And that\u0026rsquo;s how you create a basic formatter! In a future article, we are going to create a more powerful formatter that will show us everything we can do with NSFormatter.\nA reference of the entire class we wrote in this article is below:\nclass EmojiFormatter: Formatter { // MARK: - User facing methods public func rawString(for emojiString: String) -\u0026gt; String? { var formattedEmojiStringContainer: AnyObject? getObjectValue(\u0026amp;formattedEmojiStringContainer, for: emojiString, errorDescription: nil) return formattedEmojiStringContainer as? String } // MARK: - Emoji Mapping let emojiMapping = [ \u0026#34;:-)\u0026#34;: \u0026#34;üôÇ\u0026#34;, \u0026#34;:-|\u0026#34;: \u0026#34;üòê\u0026#34;, \u0026#34;:-(\u0026#34;: \u0026#34;‚òπÔ∏è\u0026#34;, \u0026#34;;-(\u0026#34;: \u0026#34;üò¢\u0026#34; ] func replaceAsciiWithEmoji(in string: String) -\u0026gt; String { var rawString = string emojiMapping.forEach { rawString = rawString.replacingOccurrences(of: $0, with: $1) } return rawString } func replaceEmojiWithAscii(in string: String) -\u0026gt; String { var rawString = string emojiMapping.forEach { rawString = rawString.replacingOccurrences(of: $1, with: $0) } return rawString } // MARK: - Overriden methods override func string(for obj: Any?) -\u0026gt; String? { if let string = obj as? String { return replaceAsciiWithEmoji(in: string) } return nil } override func getObjectValue(_ obj: AutoreleasingUnsafeMutablePointer\u0026lt;AnyObject?\u0026gt;?, for string: String, errorDescription error: AutoreleasingUnsafeMutablePointer\u0026lt;NSString?\u0026gt;?) -\u0026gt; Bool { obj?.pointee = replaceEmojiWithAscii(in: string) as AnyObject return true } } Why NSFormatter? Why not create custom formatting classes? Seeing this example, you may be thinking that it may be easier to just create an EmojiFormatter that doesn\u0026rsquo;t inherit from (NS)Formatter. After all, basic formatters are just going to need string replacing at most. So what\u0026rsquo;s the point?\nOne big advantage of using NSFormatter is that there\u0026rsquo;s multiple places all over Foundation and the rest of the iOS, macOS, and other Apple Platforms APIs. Because they take an NSFormatter, you can pass them any custom formatters.\nEven SwiftUI has APIs that take formatters. As of WWDC2020, you can interpolate in SwiftUI strings that take a formatter.\nText(\u0026#34;\\(\u0026#34;I\u0026#39;m happy to talk you :-)\u0026#34; as NSObject, formatter: EmojiFormatter())\u0026#34;) Other than that cast to NSObject, this is very straightforward to use, and you can expect multiple places all over Apple\u0026rsquo;s technologies that take formatters and you can pass your own.\nConclusion Formatters never cease to amaze us. Writing our own can be very easy, but it has everything you need to write more complex formatters. There\u0026rsquo;s various APIs that can take formatters throughout all the APIs in Apple\u0026rsquo;s platforms, and thus subclassing (NS)Formatter to get that default functionality can be very rewarding.\n","tags":["nsformatter","swift","programming","apple","ios","ipados"]},{"id":"eb17a5ae27da2bf3194b51d4bd4971eb","title":"Benchmarking Your App with MetricKit","link":"/posts/benchmarking-app-metrickit/","content":"Sometimes we may be interested on how well our app is performing out there in the world. After all, our apps may be running in different environments that are hard to test or that Instruments may not catch.\nFor this purpose, Apple introduced MetricKit back in WWDC2019. MetricKit allows us to aggregate and analyze this benchmark data on a per-device basis, and not only does it include information on performance and battery usage, but also on exceptions and crash reports.\nMetricKit will provide us with data of the last 24 hours at most, an it will include all kinds of metrics.\nImplementing MetricKit In order to implement and start using MetricKit, we need a place in our app that never gets destroyed and is always there, receiving system events. A good candidate for this is our AppDelegate. All we need to do is to register ourselves to the MXMetricManager object, extend our AppDelegate to conform to MXMetricManagerSubscriber, and implement the didReceive(_:) method of this protocol.\n// In AppDelegate func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { // Override point for customization after application launch. MXMetricManager.shared.add(self) return true } // ... // Creating an extension to conform to MXMetricManagerSubscriber extension AppDelegate: MXMetricManagerSubscriber { func didReceive(_ payloads: [MXMetricPayload]) { // Handle payloads here } } Around every 24 hours, MetricKit will call the didReceive(_:) method and it will handle us many payloads. A Payload is simply an object that wraps certain metric data. If you explore the properties of this object, you will find the animationMetrics property, which is a MXAnimationMetrics? - like you can tell, it contains metrics related to animations. You will also find applicationLaunchMetrics (MXAppLaunchMetrics?), cellularConditionMetrics (MXCellularConditionMetrics), and many more.\nIt\u0026rsquo;s worth noting that a MXMetricPayload contains a bunch of metrics, but it may not contain all the metrics in a single payload. That is to say, you may receive a payload that has the applicationLaunchMetrics property filled in, but not the animationMetrics one, and so on. This is why it is important to actually iterate through the array and check what metrics are filled in.\nHow can we test this when we expect metrics to be called every 24 hours? Luckily, Xcode has a way to simulate metrics. Do note that this doesn\u0026rsquo;t work on the simulator and you will need to attach your physical device.\nTo emulate metrics, go to the Debug menu in Xcode, and then click Simulate MetricKit Payloads.\nManually Logging Critical Sections of your Code By default, MetricKit will give us a lot of information regarding the usage of our app, but you can also manually log critical sections of your app. You can use this to benchmark code that you suspect is taking too long, for example, and understand better the behavior of your app under certain specific scenarios.\nlet filterLog = MXMetricManager.makeLogHandle(category: \u0026#34;Picture Filter\u0026#34;) func applyFilter(nanmed name: String) { mxSignpost(.begin, log: filterLog, name: \u0026#34;\\(name) filter\u0026#34;) // Long running operation of applying a filter here // .. // Don\u0026#39;t forget to call end to end the data collection. This can go inside a completion handler as well. mxSignpost(.end, log: filterLog, name: \u0026#34;\\(name) filter\u0026#34;) } Sending Metric Data to a Web Service. You may want to process and store the metric information to help you understand your users\u0026rsquo; habits and your app performance in the long run.\nApple thought it through, and all metrics that inherit from MXMetric have a jsonRepresentation property you can use to easily send this over to a custom web service.\nWWDC2020 Improvements The basics of this article covers how you can use MetricKit. Some metrics may be unavailable on iOS 13. This section will cover what\u0026rsquo;s new with this framework in iOS 14 so you don\u0026rsquo;t expect it to work in iOS 13.\nSome new tasks we can do now include:\nCPU Instructions Scroll Hitches, for when scrolling through a table view or other scrollable components feels laggy. This is good to measure the graphical performance in your app and find reasons for dropped frames or other unwanted visual artifacts. App exit reasons MetricKit Diagonistics With Diagnostics, we can get more detailed info for hangs, crashes, disk writes, and CPU exceptions. It allow us to literally get a stack trace of the call site.\nTo make use of this, all we need to do is implement a new method of MXMetricManagerSubscriber. didReceive(_:), but this time, it will pass you an array of MXDiagnosticPayload instead of MXMetricPayload. And that\u0026rsquo;s it. It will work exactly the same way as the other protocol method.\nThe API for dealing with MXDiagnosticPayload is pretty much the same as MXMetricPayload. Where we had MXMetric as the base class for all metric objects, we now have MXDiagnostic which fulfills that paper for diagnostics. MXDiagnosticPayload will wrap a bunch of MXDiagnostic subclasses the same way MXMetricDiagonistic does for wrapping MXMetric subclasses.\nIt also includes a MXCallStackTree object. This encapsulates stack traces for the moments when regressions occurred. These stacktraces are unsymbolicated.\nThe new subclasses introduced in WWDC2020 for diagnostics are:\nMXHangDiagnostic MXCPUExceptionDiagnostic MXDiskWriteExceptionDiagnostic MXCrashDiagnostic Conclusion MetricKit allows us to benchmark our apps. It aggregates a lot of data and hands it to us in reasonable intervals. WWDC2020 introduced the ability to not only do benchmarking but also diagnostics for apps crashing, hanging, and more. Implementing MetricKit in your app is very easy and it\u0026rsquo;s all about implementing two delegate calls (or just one, depending on whether you want diagnostics or not).\n","tags":["wwdc19","wwdc20","metrickit","swift","programming","apple","ios","ipados"]},{"id":"f9132e3d4424231e34365b93bd1b4f68","title":"Formatting Notes and Gotchas","link":"/posts/formatting-notes-and-gotchas/","content":"A year ago, we talked about using NSFormatter for formatting data in a human readable format. WWDC2020 brings some updates and changes to the NSFormatter APIs that we need to be aware of. This article will complement the NSFormatter article from last year with best practices and things to look out for.\nImprovements for Combinations of Languages and Regions. NSFormatter always does its best to format the data according to the user\u0026rsquo;s language and region where relevant. Apple is improving the combinations for this because it\u0026rsquo;s highly common for people to set their phones in a language that is not commonly used in a given region. This is pretty exciting for me, because I live in Bolivia where people speak Spanish, but I have used my devices in English for as long as I can remember.\nThis does mean that you should watch out for something that may look unintended, but it is what makes sense in different user devices.\nIn general, you should never try to force the formatting of content in a way that is not set in the user\u0026rsquo;s device. Ever since my previous article was published, people have been asking me about formatting data in a very specific way according to the developer\u0026rsquo;s preference. Don\u0026rsquo;t do this - Just keep in mind the most mundane differences (some countries separate decimals with commas, others with periods) in mind, and let the APIs do the formatting. Attempting to force an specific formatting can cause weird bugs where you least expect them.\nAs an example, I work for a bank, and I format currency amounts in different currencies on iOS all the time. There was very old legacy code that expected a number formatting to always have commas and replace them with periods (we use periods for separating thousands here). This code broke in many different ways if users were using different locale settings. Even when the code tried to force a specific formatting, subsequent versions of iOS broke the code.\nMoral of the story: Let NSFormatter do its jobs, and don\u0026rsquo;t rely on its output to be used as input in other methods.\nIn iOS 14, due to the internal improvements and further combinations of languages and regions, bugs like this are very likely to pop up often, so watch out for that.\nTemplates Actually introduced in iOS 8 (!), templates for date formatters allow us to do custom formatting and have it displayed properly for each locale.\nIf you have used DateFormatter before, you have likely used the dateFormat property. If you need to format in a specific locale, you should set the format with setLocalizedDateFormatFromTemplate(_:) instead. Setting the format this way will let the formatter set the order of the fields and any given punctuation for the final output.\nLet\u0026rsquo;s take controversial format: In the USA, dates are represented as month/day/year. Most countries in the world will use the more correct (I avoid saying things like this in my articles, but I will die on this hill) day/month/year.\nUsing dateFormat, you can format a date like this:\nlet dateFormatter = DateFormatter() dateFormatter.dateFormat = \u0026#34;MM/dd/yyyy\u0026#34; dateFormatter.string(from: Date()) // 09/27/2020 You are forcing the formatter to output a USA date. What if you wanted to format it for different locales? We fellas in South America don\u0026rsquo;t like that format. For us, it should really say 27/09/2020. If you wanted your format to look right in all possible locales, you can probably implement an if-hell and account for different locales that way.\nBut by setting the format with setLocalizedDateFormatFromTemplate(_:) instead, the formatter will do the right thing based on the locale you give it.\nlet dateFormatter = DateFormatter() dateFormatter.locale = Locale(identifier: \u0026#34;en_US\u0026#34;) dateFormatter.setLocalizedDateFormatFromTemplate(\u0026#34;MMddyyyy\u0026#34;) dateFormatter.string(from: Date()) // US: 09/27/2020 // ... dateFormatter.locale = Locale(identifier: \u0026#34;es_BO\u0026#34;) dateFormatter.setLocalizedDateFormatFromTemplate(\u0026#34;MMddyyyy\u0026#34;) dateFormatter.string(from: Date()) // Bolivia: 27/09/2020 It is very use to have dates formatted for the right locale. Grabbing the current Locale is also very easy, so there is no reason to not let your app format correctly for all possible locales.\nNote that setLocalizedDateFormatFromTemplate(_) will ignore anything that is not a valid date specifier. This is fully expected, as it will take care of any formatting for you. This also means that the order of the fields does not matter either.\nWith this, there\u0026rsquo;s very little reason to use the dateFormat property, as using it directly will produce the wrong output in many cases, especially if the developer is not aware of locale differences.\nFormatting Names It\u0026rsquo;s not unheard of for countries to treat names differently. For this reason we have PersonNameComponentsFormatter, which allows us to format names for each locale.\nlet formatter = PersonNameComponentsFormatter() var nameComponents = PersonNameComponents() nameComponents.familyName = \u0026#34;Êú®‰πãÊú¨\u0026#34; nameComponents.givenName = \u0026#34;Ê°ú\u0026#34; nameComponents.nickname = \u0026#34;Sakura\u0026#34; formatter.string(from: nameComponents) // Êú®‰πãÊú¨Ê°ú formatter.style = .short formatter.string(from: nameComponents) // Sakura formatter.style = .abbreviated formatter.string(from: nameComponents) // Sakura This a full Japanese name. If we write it down in romaji, we can expect different output:\nnameComponents.familyName = \u0026#34;Kinomoto\u0026#34; nameComponents.givenName = \u0026#34;Sakura\u0026#34; nameComponents.nickname = \u0026#34;Sakura-chan\u0026#34; formatter.string(from: nameComponents) // Sakura Kinomoto formatter.style = .short formatter.string(from: nameComponents) // Sakura-chan formatter.style = .abbreviated formatter.string(from: nameComponents) // SK There is interesting behavior here that you may have not noticed if you don\u0026rsquo;t know the Japanese kanji here.\n\u0026ldquo;Êú®‰πãÊú¨\u0026rdquo; is \u0026ldquo;Kinomoto\u0026rdquo;, and \u0026ldquo;Ê°ú\u0026rdquo; is Sakura. The moment we wrote the name with our alphabet, the formatter output the given name first and the family name second. Using the formatter in Japanese outputs the family name first, and then the given name. Japanese people are used to putting the family name first, and the formatter has taken care of those details for us automatically.\nFormatting Lists We can also format lists. Suppose you want to say \u0026ldquo;Apples, eggs, and pears\u0026rdquo; when you have the following array:\nlet items = [\u0026#34;apples\u0026#34;, \u0026#34;eggs\u0026#34;, \u0026#34;pears\u0026#34;] You can probably think of a clever way to concatenate the first two items only with a comma and then follow the last item with the word \u0026ldquo;and\u0026rdquo;. In fact doing so may not be complicated, but we have ListFormatter which allows us to do just that in just one line of code:\nlet items = [\u0026#34;apples\u0026#34;, \u0026#34;eggs\u0026#34;, \u0026#34;pears\u0026#34;] ListFormatter.localizedString(byJoining: items) // apples, eggs, and pears If you remove one of the elements, the formatter will do the right thing:\nlet items = [\u0026#34;apples\u0026#34;, \u0026#34;pears\u0026#34;] ListFormatter.localizedString(byJoining: items) // apples and pears In Spanish, we can use either \u0026ldquo;y\u0026rdquo; or \u0026ldquo;e\u0026rdquo; when we want to say the word \u0026ldquo;and\u0026rdquo;. When we are listing elements like this, we will use \u0026ldquo;y\u0026rdquo; the vast majority of the time, but when the sound of the letter following our \u0026ldquo;and\u0026rdquo; has an \u0026ldquo;e\u0026rdquo; (\u0026ldquo;i\u0026rdquo;) sound, we use \u0026ldquo;e\u0026rdquo; (read as \u0026ldquo;eh\u0026rdquo;) instead.\nIn the following example, we are talking about two civilizations that lived way before us: The Aymaras and Incas. If your phone was set to Spanish and you were to format this array, depending on the order of the words, you would get a different output for \u0026ldquo;and\u0026rdquo;:\nlet historic = [\u0026#34;aymaras\u0026#34;, \u0026#34;incas\u0026#34;] ListFormatter.localizedString(byJoining: historic) // aymaras e incas //... let historic = [\u0026#34;incas\u0026#34;, \u0026#34;aymaras\u0026#34;] ListFormatter.localizedString(byJoining: historic) // incas y aymaras The Oxford Comma When @steipete shared this article on Twitter, I looked into the comments and remmebered the (in)famous Oxford comma. Turns out that the formatter will even take into account when to use it. When your locale is the UK, it will not use the comma, whereas when it is the USA, it will.\nlet items = [\u0026#34;apples\u0026#34;, \u0026#34;eggs\u0026#34;, \u0026#34;pears\u0026#34;] let formatter = ListFormatter() formatter.locale = Locale(identifier: \u0026#34;en_UK\u0026#34;) print(formatter.string(from: items)) // apples, eggs and pears formatter.locale = Locale(identifier: \u0026#34;en_US\u0026#34;) print(formatter.string(from: items)) // apples, eggs, and pears Starting on iOS 14 and the rest of the OSes introduced in WWDC2020, ListFormatter will use the right grammatical rules for your lists. In earlier versions you may get unexpected results for some lists.\nNumbers Like we mentioned earlier, different locales separate decimals and thousands with a different symbol. Most English people will use commas for thousands, whereas in Spanish speaking countries we normally separate with periods.\nThis can be done correctly with NumberFormatter.\nlet numFormatter = NumberFormatter() numFormatter.numberStyle = .decimal numFormatter.string(from: 32.823) // 32.823 (English), 32,823 (Spanish) Conclusion Formatting text sounds like an easy thing, until you consider different languages and locales do things differently. As a bilingual developer, I have always been aware that languages have differences with how they should display numbers and other kinds of data, and I always thought it was a challenge to adopt to those rules. That said, Apple is making it easier to format different content and their formatters are improving to support more especial case scenarios and particular grammar rules.\nThis article is based on WWDC2020\u0026rsquo;s Formatters: Made data human-friendly session.\n","tags":["swift","programming","apple","ios","macos","tvos","watchos","ipados","iOS14","nsformatter","wwdc2020"]},{"id":"e8bd16f40800431da23ade606abf8725","title":"A Short Guide to Localization on Apple Platforms","link":"/posts/a-short-guide-localization-apple-platforms/","content":"Translating our apps in different languages helps us reach wider audiences of different cultures. This reach can increase our app usage considerably and offer more monetization properties.\nIn this short article we will mention the features Apples gives us to translate our apps to different languages, namely NSLocalizedString and and stringsdict files. You will also understand when you will want to use each, as they have different use cases and an app that takes localization seriously will use both.\nNSLocalizedString and Localizable.strings NSLocalizedString allows us to do simple \u0026ldquo;mappings\u0026rdquo;. One string in one language corresponds to another language. Use NSLocalizedString when you need to create mostly static strings or dynamic strings that do not need to deal with pluralization.\nFor example, if you wanted to translate the words apples, oranges, pears:\nNSLocalizedString(\u0026#34;apples\u0026#34;, comment: \u0026#34;The delicious red fruit\u0026#34;) NSLocalizedString(\u0026#34;oranges\u0026#34;, comment: \u0026#34;\u0026#34;) NSLocalizedString(\u0026#34;pears\u0026#34;, comment: \u0026#34;\u0026#34;) By using NSLocalizedString, you are telling the system to search for these strings whenever a string is found. Specify a comment to provide more contexts to translators. This is important because of many issues with languages, including having synonyms in English that are two different words in other languages such as Spanish, and more.\nAll your NSLocalizedStrings should create in your Localizable.strings file. This is the file that does the actual mapping of your string to other languages.\n// Localizable.strings (es) // The delicious red fruit \u0026#34;apples\u0026#34; = \u0026#34;manzanas\u0026#34;; \u0026#34;oranges\u0026#34; = \u0026#34;naranjas\u0026#34;; \u0026#34;pears\u0026#34; = \u0026#34;peras\u0026#34;; You can also create strings with dynamic parameters. For example, suppose you want your app to have a string that reads \u0026ldquo;this shop sells pears\u0026rdquo;. You could probably create three different localized strings for each fruit. But what happens if your fruits come from another source such as an API? You won\u0026rsquo;t be able to have a string for each fruit. So you can instead create one this shop sells \u0026quot;x\u0026quot; string and have x be the right fruit. The string is a bit more complex, but nothing out of this world.\nlet fruitName = //... A fruit name from another source, or maybe even a local source String.localizedStringWithFormat(NSLocalizedString(\u0026#34;This shop sells %@\u0026#34;, comment: \u0026#34;Tells the user what kind of fruits a shop sells\u0026#34;), fruitName) And in the Localizable.strings file:\n// Tells the user what kind of fruits a shop sells \u0026#34;This shop sells %@\u0026#34; = \u0026#34;Esta tienda vende %@\u0026#34;; There are different formatters. %@ is to specify strings and other data. You can also use %d for integers and all other types you\u0026rsquo;d use in NSLog.\nYou can also have strings with multiple variables. For example, to write a string such as \u0026ldquo;Number of apples available: 3\u0026rdquo;:\nlet fruitName = NSLocalizedString(\u0026#34;apples\u0026#34;, comment: \u0026#34;The delicious red fruit\u0026#34;) let availableAmount = 3 String.localizedStringWithFormat(NSLocalizedString(\u0026#34;Number of %@ available: %d\u0026#34;, comment: \u0026#34;Tells the user how many of each fruit are available in the shop\u0026#34;), fruitName, availableAmount) NSLocalizedString is great for mostly static strings or strings with simple parameters, but if you need pluralization, you need to work with stringsdict files.\nPluralizing Strings with Stringsdict files. In the last example of the above section, we saw this string:\nNumber of apples available: 1 But what if we want to say something like \u0026ldquo;There are only 3 apples left\u0026rdquo; or \u0026ldquo;There is only one apple left\u0026rdquo;? How can we do that?\nYou may recall that some older software always showed strings like this:\nThere are only 1 apples available Functionally, the string does its job, but in this day and age, where computers are more accessible than ever, many users may find it odd.\nThe na√Øve approach would be to put if-else checks and then decide which NSLocalizedString to get with it. But we don\u0026rsquo;t need that.\nThe good news is that in all of Apple\u0026rsquo;s platforms, we can make it more natural by making it read \u0026ldquo;there is only 1 apple available\u0026rdquo; or my personal favorite, even \u0026ldquo;there is only one apple available\u0026rdquo; when there is only one apple left, or \u0026ldquo;there are only 3 apples available\u0026rdquo; when there\u0026rsquo;s 3 left very easily. stringsdict files will take care of choosing the right string for us.\nThere are two parts to using stringsdict: You will still need to use NSLocalizedString, and then use a stringsdict file which is a property list of values.\nNSLocalizedString is our entry point for any localization needs. When a NSLocalizedString is found, the system will look for its right counterpart in either Localizable.strings or the stringsdict file (commonly called Localizable.stringsdict). If the string cannot be found in a stringsdict file, the system will look for it in Localizable.strings, and if the string is in neither, it will use the raw string within the NSLocalizedString itself.\nWith that discussion out of the way, we will now use a stringsdict file to create the following strings:\nThere is only one apple left. There are no apples left. There are only 3 apples left. Also, we will use the XML representation of the file, because it\u0026rsquo;s easier to work with.\nWhen you create a stringsdict file for the first time, you will see the following content:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;StringKey\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;NSStringLocalizedFormatKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;%#@VARIABLE@\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;VARIABLE\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;NSStringFormatSpecTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NSStringPluralRuleType\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;NSStringFormatValueTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;zero\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;one\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;two\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;few\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;many\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;other\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; Depending on the language we are working with, we may need to pluralize differently for zero, one, two, few and many objects. In the case of English (and Spanish), we can only care about zero, one, and many, so delete all the other keys.\nStart by changing StringKey to APPLES_LEFT_STRING. This StringKey is that one that will be used for the NSLocalizedString search.\nThen, for NSStringLocalizedFormatKey, write the following string.\nThere are %#@VARIABLE@ apples left. %#@VARIABLE@ will be matched against the numeral keys (zero, one, many). More on this in a second.\nThen, the NSStringFormatSpecTypeKey can only have one value for now, which is NSStringPluralRuleType. It\u0026rsquo;s likely stringsdict files will have more uses beyond pluralization in the future and Apple added this for future proofing.\nFor NSStringFormatValueTypeKey, write u. This specifies our variable %#@VARIABLE@ is an unsigned integer.\nThen, for zero, one, and many, write the following:\n\u0026lt;key\u0026gt;zero\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;There are no apples left.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;one\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;There is one apple left.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;many\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;There are %#@VARIABLE@ apples left.\u0026lt;/string\u0026gt; So, when our %#@VARIABLE@ is 0, our string will be There are no apples left., and so on.\nYour final stringsdict file should look like this:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34;-//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;StringKey\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;NSStringLocalizedFormatKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;There are %#@VARIABLE@ apples left.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;VARIABLE\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;NSStringFormatSpecTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NSStringPluralRuleType\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;NSStringFormatValueTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;u\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;zero\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;There are no apples left.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;one\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;There is one apple left.\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;many\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;There are %#@VARIABLE@ apples left.\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; We are not done yet, we want to use this string, we need to call it and wrap it in NSLocalizedString:\nlet applesLeft = 1 String.localizedStringWithFormat(NSLocalizedString(\u0026#34;APPLES_LEFT_STRING\u0026#34;, comment: \u0026#34;Tells the user how many Apples are left\u0026#34;), applesLeft) We do not need to specify formats for the variables in this case, as they have already been specified in the stringsdict file.\nNow when you run that code, the string will be formatted differently depending on the value of applesLeft:\nlet applesLeft = 0 // There are no apples left. let applesLeft = 1 // There is one apple left. let applesLeft = 2 // There are 2 apples left. let applesLeft = 49 // There are 49 apples left. And for the record, you can specify strings that take more than one value, so if you needed to say \u0026ldquo;There are 6 apples spread throughout 2 boxes\u0026rdquo;, you can solve that creating another variable in your stringsdict. The following is a stringsdict I use to say \u0026ldquo;Read 20 chapters out of 35\u0026rdquo;:\n\u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;NSStringLocalizedFormatKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;%#@VOLUMES@ %#@TOTAL_VOLUMES@\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;VOLUMES\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;NSStringFormatSpecTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NSStringPluralRuleType\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;NSStringFormatValueTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;u\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;other\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;read %u\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;zero\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;read nothing\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;one\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;read one\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;key\u0026gt;TOTAL_VOLUMES\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;NSStringFormatSpecTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NSStringPluralRuleType\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;NSStringFormatValueTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;u\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;other\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;out of %u volumes\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;zero\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;one\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;out of one volume\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;key\u0026gt;EPISODES_BEHIND_TEXT\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;NSStringLocalizedFormatKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;%#@EPISODE_COUNT@\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;EPISODE_COUNT\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;NSStringFormatSpecTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;NSStringPluralRuleType\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;NSStringFormatValueTypeKey\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;u\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;zero\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;No episodes behind\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;one\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;one episode behind\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;other\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;%u episodes behind\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; Conclusion Localization is important, even more in modern computers, even more so. Apple provides developers with tools to make both \u0026ldquo;direct\u0026rdquo; translations easier and to make pluralization make sense in the context of any language.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos"]},{"id":"237320230415f8a16497505a933e2c0e","title":"WWDC2020: What's new in CryptoKit","link":"/posts/wwdc2020-whats-new-cryptokit/","content":"CryptoKit, introduced in WWDC2019, allows us to perform cryptographic operations very easily.\nWhile CryptoKit still doesn\u0026rsquo;t offer many algorithms and functionality, it\u0026rsquo;s still growing, and this year CryptoKit and do more.\nHKDF Key derivation functions have been available from day one, but it wasn\u0026rsquo;t possible to derive keys independently. It was only possible to do so if you were using elliptic curve key agreement protocols.\nTo do this, there is a new HKDF object with static methods. One such method is deriveKey with multiple overloads:\nlet key = SymmetricKey(size: .bits256) let info = \u0026#34;abcdef\u0026#34;.data(using: .utf8)! // Quick example only let derivedKey = HKDF\u0026lt;SHA512\u0026gt;.deriveKey(inputKeyMaterial: key, info: randomInfo, outputByteCount: 256) print(derivedKey.bitCount) Both parties would need to have same info in order to derive the same keys. This is because this is a deterministic algorithm and the same inputs will always produce the same outputs.\nCreating Elliptic Curve Keys with PEM and DER encoded strings. Something that I was really missing in CryptoKit was the ability to store EC keys in a standard format. Starting on CryptoKit 1.1.0 (iOS 14 and the other OSes announced at WWDC2020), we can create our EC keys with PEM and DER encoded strings.\nTo support this, all Private and Public keys inside EC wrappers now have two new initializers - init(pemRepresentation:) throws and init(derRepresentation:) throws.\nlet pemKey = \u0026#34;\u0026#34;\u0026#34; -----BEGIN EC PRIVATE KEY----- MHcCAQEEIKd4xNZ5A90r8jDUkfu9MrTscvKia9ebl2SDoPttK1C9oAoGCCqGSM49 AwEHoUQDQgAEdF+4auFmiRknxAXXb7X0QMfp6l/JGpf+2FUNkPaIBAODztGa6XNQ ItQzQGNo26D3DCe8LL/vQpMnNX1ONL6Ocw== -----END EC PRIVATE KEY----- \u0026#34;\u0026#34;\u0026#34; let p256FromPem = try P256.KeyAgreement.PrivateKey(pemRepresentation: pemKey) The pemKey is a string. If you want to play around with this, I generated the pemKey using OpenSSL on my Mac using the following command in the terminal:\nopenssl ecparam -genkey -name prime256v1 -noout -out ec256-key-pair.pem Needless to say, don\u0026rsquo;t use this private key for anything as it has been posted publicly.\nAnd not only can you create keys based on their PEM and DER representations, you can also get these representations from brand new keys created directly with CryptoKit.\nlet cryptoKitP521KeyPair = P521.KeyAgreement.PrivateKey() let cryptoKitP521PublicKey = cryptoKitP521KeyPair.publicKey print(\u0026#34;PRIVATE KEY:\\n\\n\\(cryptoKitP521KeyPair.pemRepresentation)\u0026#34;) print(\u0026#34;PUBLIC KEY:\\n\\n\\(cryptoKitP521PublicKey.pemRepresentation)\u0026#34;) PRIVATE KEY: -----BEGIN PRIVATE KEY----- MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIBuL2ZAOozjAd+SS54 ipH72btEIRcuWmzHZE2d+9fe+iMCfDnIT+/XF7+rUboSBvlQqFX/X/S96ddvbNdc bx3Ii3GhgYkDgYYABACm8IjMS9Ql0/xm8HtaJCalqceBGP1ydltl257TZB9O92zi LTwlzyceyMTQ6wdiY58BYkhs9WybldbGfV6OI8Jm1wAE3q+Gum/2bgf2ZVeU50gD h/N8Kpj2F8HVhph4aPci/ixZ84DfyIzU/8OxApGLW/0Ixdxy7XaUTiwwpBVIgvW4 Lw== -----END PRIVATE KEY----- PUBLIC KEY: -----BEGIN PUBLIC KEY----- MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAAQApvCIzEvUJdP8ZvB7WiQmpanHgRj9 cnZbZdue02QfTvds4i08Jc8nHsjE0OsHYmOfAWJIbPVsm5XWxn1ejiPCZtcABN6v hrpv9m4H9mVXlOdIA4fzfCqY9hfB1YaYeGj3Iv4sWfOA38iM1P/DsQKRi1v9CMXc cu12lE4sMKQVSIL1uC8= -----END PUBLIC KEY----- We can now store our keys in standard formats to be be able to easily use them in other apps.\nConclusion CryptoKit keeps improving. This year we got very nice features that should help with both the interoperability of CryptoKit with other systems and basic HKDF.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","cryptokit","wwdc2020"]},{"id":"8343426577aa2c5937f94e6054980dd9","title":"Logging Messages With the Unified Logging System on Apple Platforms","link":"/posts/logging-messages-unified-logging-system-apple-platforms/","content":"Last time we talked about the basics of the Unified Logging System, we set the basic concepts and code we need to write logs, along with the different logging levels, and more.\nIn this article we will talk about actually logging messages, how the framework is \u0026ldquo;smart enough\u0026rdquo; to strip out sensitive user info by default, and how we can control what gets stripped.\nLogging Messages The framework supports interpolated strings right out of the box when you are using the new system in Swift.\nlet elementCount = (1...3).count let username = \u0026#34;Andy\u0026#34; logger.notice(\u0026#34;The array contains \\(elementCount) elements\u0026#34;) logger.debug(\u0026#34;Logged in username \\(username)\u0026#34;) It\u0026rsquo;s good to know that you can do this by default, but it\u0026rsquo;s more interesting how there are some formatters ready to be used.\nFormatting Logging Variables You can format your variables in the following ways:\nSpecify the width of the variable and align its contents within it. Format integers as decimal, hex, or even octal numbers. Format floating-point numbers used fixed-point, exponential, or hybrid notation. Format booleans as true/false or yes/no strings. Setting the precision for floating point numbers. Setting the minimum number of digits. Specifying if a number needs an explicit plus or minus sign.\\ To set these options, your string interpolations can take additional parameters for their formatting, such as:\nlet shouldPromptRating = true logger.notice(\u0026#34;Should prompt rating on completion: \\(shouldPromptRating, format: .answer)\u0026#34;) let aFloat = 23434.29003493 logger.notice(\u0026#34;Distance is \\(aFloat, format: .exponential(precision: 3))\u0026#34;) Mentioning all the different formatting options and how to do them is beyond the scope of this article. As long as you are aware they exist, this section of the article has done its job. There is a very complete section on formatting in the official docs.\nRedacting Sensitive Info From Logging Messages. It is recommended that you keep your logging to static strings and numbers when you log, but sometimes, you just really need to know about what kind of specific dynamic input data is causing troubles for your users.\nThe system will redact the contents of dynamic strings and other complex dynamic objects. If you need to explicitly log the content of dynamic strings, you can specify the privacy parameter when you perform string interpolation.\nlogger.notice(\u0026#34;User logged in with username \\(username, privacy: .public)\u0026#34;) Integer, floating-point, and booleans are not redacted by default. But you can manually redact them if you deem it necessary, using the same method as un-redacting strings.\nlet applesBought = 5 logger.notice(\u0026#34;User bought \\(applesBought, privacy: .private) apples\u0026#34;) There is one more thing related privacy. Suppose you need to login unique user IDs, but doing so would be invasive for user privacy. It may be important to know that a specific user ID us having problems, so how can you view this ID without seeing the ID itself?\nThe .private enum has a .mask initializer you can use. It will create a unique hash for the same input, but you will never see the real value of the input.\nlogger.notice(\u0026#34;User \\(userId, privacy: .private(mask: .hash)) logged in\u0026#34;) We can now reference all the logs with this specific user, without leaking any information about them.\nConclusion The unified logging system has all the facilities to format logs in a way that make sense in the context of your app, and they have all the tools you need to strip out potentially personal information, without losing references to it and without undermining the usefulness of the logging system.\n","tags":["swift","programming","apple","ios","ipados","watchos","macos","tvos","logging","oslog"]},{"id":"513224700d9eaecadf7545b6bec24899","title":"Using ASWebAuthenticationSession with SwiftUI","link":"/posts/using-aswebauthenticationaession-swiftui/","content":"Working with REST APIs you have no control over can be a little monotonous. This is especially for OAuth 2.0 API that need you to do a little bit of setup, get your API keys with the service provider, and then you need to do the setup on your app\u0026rsquo;s size: Configure your URL scheme, deal with that URL Scheme, and write code that does something when your app gets called with that URL.\nIn the old days of iOS development, this took quite a while. If you adopted something like the Facebook and Twitter APIs, you likely used their SDKs as they dealt with all these issues for you. If you wanted to use a service that didn\u0026rsquo;t provide an SDK, you were of luck, and had to do quite a little bit of setup.\nLuckily for us, starting on iOS 12, Apple introduced the AuthenticationServices, which, amongst many many things, it greatly simplifies the OAuth 2.0 flow for REST APIs, thanks to the ASWebAuthenticationSession object.\nInitial Setup I recently had to use the Anilist API for an upcoming up, so a lot of the sample code will come from this project.\nRegardless of the service you are interacting with, you will first need to get your API credentials.\nAt the very least, they will always give you an API secret.\nYou still need to configure your URL Scheme to call your app. To do this, click your project blueprint in Xcode, click Info, select your Target, and expand the URL Types section. The identifier needs to be anything in reverse DNS donation. The scheme has to be everything up to but not including :// of your URL. Depending on the service provider, you may have the flexibility of creating your own or they will assign one to you. Set the role to Viewer, thought it doesn\u0026rsquo;t really matter for iOS apps.\nAnd that\u0026rsquo;s all we need to do for the initial setup. We can now start writing some code.\nThe View and ViewModel Because we are using SwiftUI, we can create our views and a companion ViewModel object.\nThe ViewModel The ASWebAuthenticationPresentationContextProviding Protocol The ViewModel will take care of handling the actual authentication flow for us. It must conform to the ASWebAuthenticationPresentationContextProviding protocol.\nclass SignInViewModel: NSObject, ObservableObject, ASWebAuthenticationPresentationContextProviding { } Also note the NSObject inheritance. This is necessary, because we are conforming to ASWebAuthenticationPresentationContextProviding. If you don\u0026rsquo;t inherit from NSObject you will need to do a lot of implementations to satisfy the constraint, and it\u0026rsquo;s not easy or short to do.\nBefore we move on, let\u0026rsquo;s satisfy that ASWebAuthenticationPresentationContextProviding protocol. There\u0026rsquo;s only one tiny method we need to implement.\nclass SignInViewModel: NSObject, ObservableObject, ASWebAuthenticationPresentationContextProviding { // MARK: - ASWebAuthenticationPresentationContextProviding func presentationAnchor(for session: ASWebAuthenticationSession) -\u0026gt; ASPresentationAnchor { return ASPresentationAnchor() } } This method is actually one of the source of confusion developers have when they try to integrate this framework with web logins. I have seen implementations where people try to get a reference to UIWindow and all other kinds of hacky jobs to get this to work, but nothing like that is necessary. In SwiftUI 2, it\u0026rsquo;s not easy (is it even possible?) To get a reference to the main window and use that as the presentation anchor, so it\u0026rsquo;s good to know you don\u0026rsquo;t need to keep any kind of whacky references to get this to work.\nEverything this method is doing is telling the framework \u0026ldquo;hey, use use a presentation anchor appropriate for this platform\u0026rdquo;. You don\u0026rsquo;t need to give it any other context information or references. In fact, the ASPresentationAnchor documentation states:\nA platform-specific type that indicates the kind of user interface element to use as a presentation anchor.\nThe system will choose the right anchor for you, so you don\u0026rsquo;t have to worry about grabbing one up from up above the view hierarchy.\nFurthermore, the documentation even tells you how it is implemented:\nFor iOS, Mac Catalyst, tvOS:\ntypealias ASPresentationAnchor = UIWindow for macOS:\ntypealias ASPresentationAnchor = NSWindow So no need to grab references or anything. Just return ASPresentationAnchor and let the framework do the rest.\nThe SignIn Method We can finally write the actual code that will show up the login UI. The login UI is a website provided by the OAuth 2.0 service, where the user logs in without having to enter their credentials directly into their app. Once the user finishes the login flow with the service, the service calls your custom URL Scheme with a longer URL that contains an access token.\nfunc signIn() { let signInPromise = Future\u0026lt;URL, Error\u0026gt; { completion in let apiData = AnilistAPIConfigurations.load() let authUrl = AnilistAuthenticationURLBuilder(clientID: apiData.id)() let authSession = ASWebAuthenticationSession( url: authUrl, callbackURLScheme: apiData.redirectURL.absoluteString) { (url, error) in if let error = error { completion(.failure(error)) } else if let url = url { completion(.success(url)) } } authSession.presentationContextProvider = self authSession.prefersEphemeralWebBrowserSession = true authSession.start() } signInPromise.sink { (completion) in switch completion { case .failure(let error): // Handle the error here. An error can even be when the user cancels authentication. default: break } } receiveValue: { (url) in self.processResponseURL(url: url) } .store(in: \u0026amp;subscriptions) } This looks like a lot, so let\u0026rsquo;s look at it step by step.\nFirst, I\u0026rsquo;m getting into the habit of reducing the amount of callback code I have. For this reason, when I find a native API that requires a callback, I wrap it in a combine Future. For more info, check out my Wrapping Asynchronous APIs into Combine Futures article. You do not need to do this, and you can use the callback and its results directly.\nSecond, we have a AnilistAPIConfiguration object that calls a static load() object.\nI bundle an API config file in my app that is simple a JSON file with my API credentials. For those raising eyebrows at this, you are allowed to do this as long as your service provider allows you to use implicit grants.\nThe JSON file looks like this:\n{ \u0026#34;id\u0026#34;: 1, \u0026#34;secret\u0026#34;: \u0026#34;api_secret\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Nae for Anilist\u0026#34;, \u0026#34;redirectURL\u0026#34;: \u0026#34;fairese-nae://anilist-auth\u0026#34; } All the values here were given to my by service provider (Anilist). You may need to adapt this or provide your credentials in an entire different way depending on your API provider.\nThe AnilistAPIConfigurations class is implemented like this:\npublic class AnilistAPIConfigurations: Codable { public let id: Int public let secret: String public let name: String public let redirectURL: URL static func load() -\u0026gt; AnilistAPIConfigurations { let filePath = Bundle.main.url(forResource: \u0026#34;anilist_api\u0026#34;, withExtension: \u0026#34;json\u0026#34;)! let data = try! Data(contentsOf: filePath) let object = try! JSONDecoder().decode(AnilistAPIConfigurations.self, from: data) return object } } The load() does not safely unwrap, because I want it to fail when it\u0026rsquo;s not possible to use my credentials.\nThe AnilistAuthenticationURLBuilder builds the authentication URL for the service. You could hardcore your URL here directly, or anything else. Just know you need an authentication URL the service will call based on your API secret and other info. The implementation of this object is the following:\n/// Builds authentication URLs. public class AnilistAuthenticationURLBuilder { /// The domain URL let domain: String /// Client ID let clientID: Int init( domain: String = \u0026#34;anilist.co\u0026#34;, clientID: Int) { self.domain = domain self.clientID = clientID } var url: URL { var components = URLComponents() components.scheme = \u0026#34;https\u0026#34; components.host = domain components.path = \u0026#34;/api/v2/oauth/authorize\u0026#34; components.queryItems = [ \u0026#34;client_id\u0026#34;: String(clientID), \u0026#34;response_type\u0026#34;: \u0026#34;token\u0026#34; ].map { URLQueryItem(name: $0, value: $1) } return components.url! } func callAsFunction() -\u0026gt; URL { url } } Anilist requires you build the URL with the client ID. The secret is not necessary for this specific API (and grant type).\nNext, we have the core of this article - the ASWebAuthenticationSession object.\nTo create this object, you need to give it:\nThe Authentication URL (authUrl). This is the URL that the web view will display once it loads. It will show the service\u0026rsquo;s login page in which your users write their credentials and finish the login flow. The callback URL Scheme: This is the scheme that was both provided by the service and that we configured in our project\u0026rsquo;s Target. A callback: The callback will give us an error or an URL containing the access token and possibly other login info. When the callback gets called, at the very least we need to grab the access token and store it in our app for authenticated requests. I have also set two additional properties:\nauthSession.presentationContextProvider = authSession.prefersEphemeralWebBrowserSession = true The former is necessary, as that will assign us as the context provider. The later sets the web browser session as ephemeral, meaning that each time we show this web view, it will not try to use any cookies or data from a past authentication session. I do this because if the user logs out of the app, they may want to login into a different account.\nFinally, once you call start(), the session will start, the web view will be displayed, and your user will be able to authenticate against the service.\nHandling the Response If the callback gets called successfully with an URL, we need to parse out the access token and store it. I will leave the storage details to you as that will depend on how secure the token must be and your own needs.\nTo parse out the token, I created the processResponseURL(_) method:\nfunc processResponseURL(url: URL) { let anilistComponents = URLComponents(url: url, resolvingAgainstBaseURL: true) // Anilist actually returns the token in a messed up way. // All the parameters - including query parameters - are AFTER the fragment. // So I can\u0026#39;t just access the query property of these components to get all the data I need. // To work around this and save myself the headache of possible encoding issues, I will create // a new URL using the fragment of the old components and some dummy domain. if let anilistFragment = anilistComponents?.fragment, let dummyURL = URL(string: \u0026#34;http://dummyurl.com?\\(anilistFragment)\u0026#34;), let components = URLComponents(url: dummyURL, resolvingAgainstBaseURL: true), let queryItems = components.queryItems, let token = queryItems.filter ({ $0.name == \u0026#34;access_token\u0026#34; }).first?.value, let expirationDate = queryItems.filter ({ $0.name == \u0026#34;expires_in\u0026#34; }).first?.value { /// Store the token /// Store the token expiration date if necessary. } } This implementation is a bit specific to Anilist. Anilist currently returns the URL query parameters after the fragment, so we cannot grab them with URLComponents\u0026rsquo; queryItems property. I had to create a dummy URL, create it with the contents of the response, and grab the token from there. It\u0026rsquo;s likely that if you use this with another service, you will not need to this as they are likely to return the URL query and fragment (everything after the #) correctly.\nFor more info on URLComponents, you can read this article.\nThe View Finally, the view will call our ViewModel\u0026rsquo;s signIn method, showing the web view. The I used for this is simply this one:\nstruct SignInView: View { @StateObject var viewModel = SignInViewModel() var body: some View { VStack(spacing: 16) { Image(systemName: \u0026#34;person.circle\u0026#34;) .resizable() .frame(width: 50, height: 50) .foregroundColor(colorForTheme(color)) VStack(spacing: 8) { Text(\u0026#34;You must be logged in to your Anilist account to use this feature\u0026#34;) .foregroundColor(.secondary) .font(.title3) .multilineTextAlignment(.center) .padding() Button { viewModel.signIn() } label: { Text(\u0026#34;Sign In\u0026#34;) .foregroundColor(.white) .padding() .background(colorForTheme(color)) .clipShape(RoundedRectangle(cornerRadius: 8)) } } } } } Tapping the Sign In button will show a web view:\nConclusion ASWebAuthenticationSession is one of the hidden gems from WWDC18. Authorizing your app with third party web services is now easier than ever, and you can get it done in just a few hours of code, without having to engage in heavy configurations or callbacks.\n","tags":["apple","swift","ios","programming","ipados","tvos","macos","swiftui"]},{"id":"f9e8d3b22e77f07af90ca694d64fe1f5","title":"Introduction to Apple's Unified Logging System on iOS 14 in Swift","link":"/posts/introduction-apples-unified-logging-system-ios14-swift/","content":"It is no surprise that software tend to write logs to a local file as they execute. As events, errors, or exceptional situations occur, a lot of software takes note of them using a local logging solution. This is done because these practices can allow us to troubleshoot problems for our users, find bugs, and in general understand the behavior of our software in untested or lesser tested scenarios.\nWhen comes to iOS and other Apple platforms, there have always been third party dependencies that allow you to do this. A lot of developers roll their own solution and write events in plain text files. It wasn\u0026rsquo;t until iOS 8 and macOS 10.10 that Apple provided us with a unified logging system that is easy to use and is very performant - OSLog.\nOSLog provided a lot of first party facilities for local logging, but it\u0026rsquo;s not quite there.\nThis year, at WWDC2020, Apple showed us further improvements to their unified logging systems, providing a simple and consistent API that is easy to use, performant, and optimized for different logging scenarios.\nIn this series of articles we will explore these new unified logging APIs and how you can use them in your apps. Note that we will be focusing on the new WWDC2020 APIs. If you need to implement logging in earlier versions, you will need to leverage OSLog instead.\nIntroducing Logging Traditional logging frameworks will always write their events to a file. Apple\u0026rsquo;s logging solution is very powerful, and it can persist events only in memory or to disk if necessary. There is default configurations to how the system stores logs, but you can change them to suit your needs, including logging absolutely everything to a file, or everything to memory (which wouldn\u0026rsquo;t make much sense).\nWhen logging to a file, this is not a plain text file. Instead, Apple has a logging format that is performant and it can do a lot of things for you, including removing sensitive data from logs (without losing filtering options), and more.\nDetails to view your logs will come at a later time. For now, be aware that Apple provides many ways to view them, including using the Mac\u0026rsquo;s Console.app, the log command-line tool, and the Xcode debugging console. We also have the option to read logs programmatically via the older OSLog system.\nWriting Logs From Your Code Logging Practices Before we get into the actual logging, let us establish some good practices you may use when you want to start logging events, including good places to place the logging code:\nAt the beginning and end of functions of tasks. Non-trivial functions are a good place to place logging code. If you have more complex tasks composed of smaller function calls, they are also good candidates for logging. Any general events: When networking calls succeed or fail, when opening files, etc. When significant errors take place. Unexpected errors that can leave your app in a weird state and significant errors in general should be logged. Unusual code paths. If there\u0026rsquo;s code paths that should barely happen, log them as well. This is great to find weird bugs or bugs that happen due to unusual user actions. Log after each line of a multi-step execution. When logging messages, you can log more than just static strings. You can incorporate static strings, numbers, and other Objective-C objects into your logging. Even with this huge flexibility, the system will by default automatically remove sensitive information from your messages.\nCreating Logs A log object centralizes all the logs that occur at a specific place of your app. All unified logging is done through this logging object. In Swift, you can use the Logger object introduced at WWDC. Objective-C folks will have to continue using OSLog.\nLogging objects come with two basic filtering options. You can use them to filter out information as you try to diagnose issues in a specific place of your app. Because unified logging can produce an overwhelming amount of logs, you should make good use of these two options:\nThe Subsystem is a functional area of your part. Multiple processes should be their own subsystems. You can even define a screen as a \u0026ldquo;screen\u0026rdquo; in your app. The subsystem can be anything that contextually makes sense in your app. I like to define a subsystem as an internal framework of my app. It is a good idea to use reverse DNS notation to name your subsystems. The Category can be used to define a component of your app inside a given subsystem. You may categorize your subsystem based on the UI that drives your interactions, the data processed by the component, or networking code related to that category. Once again, you have to define the category based on the context of your usage. Unlike the Subsystem, you are free to use any format for these strings, not just reverse DNS notation. Log Levels There are different log levels, and you should choose the right level for everything you need to log. Because different log levels store the logs differently by default, it is important to understand all the levels before you implement unified logging into your apps:\nDebug: Generally used to log \u0026ldquo;everything\u0026rdquo; when developing your app. Because debug logging can be aggressive, the logs are not stored on disk as they are only useful during development. Info: This level only stores logs on disk when collected with the log tool. Use it when you need to collect important but not essential information about your app. Notice: This is also the default level. Use it to capture information that may be important to diagnose issues, such as tasks that may cause errors. These are persisted to disk up to a storage limit. Error: Persisted to disk, up to a storage limit. Use this level to capture any error. Log information related to the error itself to make it easier to troubleshoot either. Fault: Persisted to disk, up to a storage limit. Log situations that can leave your app in an invalid state or that may cause bugs. Essentially, use this to log harsher conditions than simple errors. If you log messages with log, you can make it so Info messages are also stored on disk. The last three are compressed before being stored, so they are very efficient.\nCreating Logs In Code. With all that theory out of the way, we will explore the simplest use case for logging in this article - static strings. In a later article we will explore advanced logging with dynamic and stripped data, as it\u0026rsquo;s a topic that deserves its own article.\nTo create a Logger, you can use the default initializer that takes no parameters to use the default subsystem. This is not recommended. You should use the init(subsystem:category) initializer instead.\nDon\u0026rsquo;t forget to import OSLog, you need it regardless if you need Swift only or Objective-C support.\nimport OSLog var logger = Logger(subsystem: \u0026#34;com.andyibanez.com.nae.profile\u0026#34;, category: \u0026#34;Networking\u0026#34;) Finally, actually logging strings is really easy. The object has a method for each level.\nlogger.debug(\u0026#34;Initializing networking object\u0026#34;) logger.info(\u0026#34;Initialized networking object\u0026#34;) logger.notice(\u0026#34;Networking object is currently nil\u0026#34;) logger.error(\u0026#34;An error occured initializing network object\u0026#34;) logger.fault(\u0026#34;Networking object has gone away prematurely\u0026#34;) And that\u0026rsquo;s it for static strings! In subsequent articles in this series we will explore how to create dynamic logging and how to read the files created by this framework.\nConclusion Logging can help you diagnose issues that just don\u0026rsquo;t occur at development time. It can also help you troubleshoot other issues your users may experience. The unified logging system is very performant and very easy to use for this task.\n","tags":["swift","programming","apple","ios","ipados","watchos","macos","tvos","logging","oslog"]},{"id":"f18d24420f900dfdca797f36b1db4704","title":"Sponsor Me","link":"/sponsorship/","content":"Each month, over 35,000 developers from all over the world find their way to this website, looking to read about iOS, iPadOS, and Swift development in general. Since the site was launched a year ago, it has enjoyed constant growth and an increase in visitors every month.\nIf you are interested in sponsoring andyibanez.com, please send an e-mail to sponsor@andyibanez.com. I take care to reply to all inquiries sent to this address within 24 hours. Ensure you can receive e-mails from the andyibanez.com and andresibanez.com domains.\nWhy Advertise on AndyIbanez.com? Advertising on AndyIbanez.com will give you the following benefits:\nReach. AndyIbanez.com has over 35,000 visitors reading my articles every month. These developers come from all over the world and they all have different skill levels. The site is focused on developing for Apple technologies, and as such you will reach developers who develop for Apple\u0026rsquo;s platforms. Personal Ads. I will personally write your ad and show it to you before putting it up on the website. My goal is to make the ad as personal as it can be, so users can find it as engagement as the blogposts it will appear on. Ad Placement. Your add will appear in all the blog posts linked to in /posts, right under the title of each article, for the duration of your sponsorship. The Content of the Website is Kept Fresh. I strive to write at least one new article every week, and I also strive to update older articles with the newest information when necessary, so you know your sponsorship will be seen in fresh, up-to-date content. Simple and Exclusive. During your sponsorship period, you will be the only ad on the entire website. We will work together crafting a small, personal ad, and it will be visible in all the posts on the website. The warm, fuzzy feeling of supporting a community resource: The iOS community is full of community resources, and I appreciate everyone who decides to invest on them. Pricing Pricing is simple: Currently, Sponsorships cost $300 (USD) per week. ","tags":null},{"id":"71c0bee6d20c47eb4d3ae6f14b1292b0","title":"Simpler File Encryption on iOS","link":"/posts/simpler-file-encryption-ios/","content":"It\u0026rsquo;s not news that iOS has a heavy a focus on privacy and security. Apple provides us with many tools to make encryption easy, like CryptoKit, a high-level Cryptography framework on iOS. When CryptoKit is not enough, we can leverage older, lower-level APIs to do more cryptographic operations or use cyphers not covered by CryptoKit. We can even make use of the Secure Enclave to leverage hardware-level security to our apps.\nThis is all cool and dandy but did you know that you don\u0026rsquo;t need to leverage any of the technologies above to secure data in your app? In this article we will provide a much simpler method to protect user data, without having to know the first thing about Cryptography at all, and without compromising security at all. If you know you need to protect data, you can consider this option before even considering directly dealing with cryptography at all.\nData Protection on iOS Data Protection is an iOS feature that is automatically enabled the moment a passcode is set on the device. As this is enabled automatically, you get a lot of encryption support for free on your apps. You do not need to do anything especial when reading and writing files to ensure they are protected by Data Protection. Instead, you just use all reading and writing APIs as you would normally do, and the system will take care of encryption on the fly for you. This process is automatic, and when available, they use hardware-accelerated features.\nSo just by having a passcode, your data is already pretty secure. But to what extent? Is all my user data automatically safe just because a passcode is set? Well, no. But it\u0026rsquo;s pretty darn close.\nYou can actually specify the data protection level on a file by file basis. You can apply any of four different levels to your files, and each level defines the conditions under which files may be accessed:\nNo Protection: The file will always be accessible whether there is a passcode set or not. Complete Until First Authentication: The file will not be accessible until the user authenticates for the first time (after a reboot, etc). After unlocking the device, the file becomes accessible at all times, whether the device is currently locked or not. This is the device protection level. Complete Unless Open: You will only be able to open the file while the device is unlocked, but once you have it open, you can continue accessing it even after the user locks the device. You can create files with this protection level whether the device is locked or unlocked. Complete: You will only be able to access this file when the device is unlocked. No questions asked. Since Complete Until First Authentication is the default level, your files are actually quite out there. This is not necessarily a bad thing, but be aware you can make your data be accessed only while the device is unlocked. Consider your use case, and apply the right data protection level as you deem fit.\nApplying a Different Data Protection Level to Your Files Applying a different file protection level to a file is as easy as calling Data.write(to:options) on a piece of Data you want to store. In the options parameter (of type NSData.WritingOptions), you can pass in the protection level you want to use:\n.noFileProtection .completeFileProtectionUntilFirstUserAuthentication (default) .completeFileProtectionUnlessOpen .completeFileProtection A small sample code would look like this:\nlet fileURL = // ... let data = // ... let protectionLevel = Data.WritingOptions.completeFileProtection do { try data.write(to: fileURL, options: protectionLevel) } catch { // Handle errors. } And that\u0026rsquo;s it! Once you save your data to a file, it will apply the protection level you want, protecting your data to the level you specify.\nChanging the Protection Level of a File You can change the protection level of a file any time. The API is a bit messy at the time of this writing - it\u0026rsquo;s Objective-C, so you need to cast, and you can\u0026rsquo;t use the same Data.WritingOptions to change it, making it less intuitive. Luckily it\u0026rsquo;s not too complicated.\nTo change the protection level, you need to use NSURL\u0026rsquo;s setResourceValue(forKey:) method:\ndo { try (fileURL as NSURL).setResourceValue( URLFileProtection.complete, forKey: .fileProtectionKey) } catch { // Handle errors. } URLFileProtection allows you to specify .none, .completeUntilFirstUserAuthentication, .completeUnlessOpen, and .complete.\nManaging Protected File Access Depending on the file level you specify, there is a chance you will try to access protected data without it being available. So you need to be responsible and handle opening and closing your files, especially when working with higher-level data protection settings.\nFor this reason, your App Delegate can implement applicationProtectedDataWillBecomeUnavailable(_:) and applicationProtectedDataDidBecomeAvailable(_:).\nImplementing this methods also implies using the right protection data level for each file. Files that may be accessed in the background due to tasks such as location, background push notifications, and the like, should have a flexible enough level to be accessible at all times.\nConclusion Protecting data in your app doesn\u0026rsquo;t have to be complicated. By leveraging this simple system you can protect your data without knowing the first word about Cryptography at all. Just be responsible and ensure you know what data protection level you need to assign to each file, and your data will be more secure without affecting performance or functionality in any way.\nThis article is based on Apple\u0026rsquo;s Encrypting Your App\u0026rsquo;s Files article.\n","tags":["swift","programming","apple","ios","ipados","encryption","cryptography"]},{"id":"2389c88509d4eeb2ff34daf6d1ff099d","title":"andyibanez.com Turns One Year Old","link":"/posts/andyibanez-com-turns-one-year-old/","content":"AndyIbanez.com Turns 1 Year Old (?) Today\nI just wanted to let you all know that this website is having a birthday today! üéâ\nI started working on my new website earlier on August last year. I want to take the time to reflect about the previous year, and to thank everyone I have had the pleasure of meeting and interacting with since this all started.\nMy Website Is Actually Older I actually started to blog about iOS when I was a college freshman all the way back in 2011. You can find an archive of the old Wordpress-based website here. I have rewritten some articles to publish them here, and I may continue to do it depending on what I find necessary.\nI have always used blogging as a way to learn and teach what I learn. In the early days I used to blog a lot about Jailbreak development. I did cover other topics, but I was a lot into Jailbreak back then up until around 2014, when I stopped jailbreaking.\nThe main problem with my website during most of the decade was that I had absolutely no consistency whatsoever. There were times when I blogged very often, but most of the time there was a lot of downtime. There were literal years in which I did not publish anything.\nHow This Website Came to Be In late 2018 and early 2019, I started getting more involved in the community, but mostly passively and without publishing my own content. Mostly reading other people\u0026rsquo;s blogs and listening to Podcasts. A big driving force into driving to publish my own content was the Stacktrace Podcast. At some point after starting listening to this Podcast, I just had a drive to be more involved with the community, and the natural step was to continue doing what I was doing earlier in the decade. So, after listening about Static Web Site Generation from John Sundell back when he was working on Publish for the first time, I decided to relaunch my website from scratch, this time using a Static Site Generator (I\u0026rsquo;m currently using Hugo), and discarding all old content. The content I decided to keep was rewritten because I hated my old writing style.\nOriginally, I was going to wait until John finished Publish so I could use it. I really wanted to generate my site with Swift, but my drive to start blogging was too strong to wait. I had to start with whatever I could, and settled for Hugo.\nThe promise I made to myself was I would write one article per week. I have managed to do it so far, and I\u0026rsquo;m very proud of this achievement. Sometimes I find myself struggling to find topics to write about, but there is so much content that sometimes it\u0026rsquo;s just a matter of choosing something. For me, keeping my promise of blogging weekly is very important.\nAchievements, Events, and Anything Else. Article Reach While I blog to learn and to teach, it is always nice when you know your content is being shared across with other developers. When I started this website a year ago, I did not imagine the reach it could possibly get. It\u0026rsquo;s not much reach, but it has definitely surpassed my expectations.\nI was surprised when I saw some of my blog posts making it to Dave Verwer\u0026rsquo;s iOS Dev Weekly, because it has always been one of my favorite iOS development resources. AppCoda also grabbed some of my articles, as did TheSwiftDev.\nI was even more surprised when I was listening to the More Than Just Code podcast and I heard my name being mentioned, alongside my New Search APIs in iOS 13 article.\nOn Twitter, my articles have been shared by all kinds of people. Tim Condon from the Ray Wenderlich team, Peter Steinberger from PSPDFKit (we will get more into what Peter did for me shortly), and more.\nI want to thank everyone who has taken the time to share, comment, and point out fixes and inaccuracies in my articles. Especially when people point our problems in my articles, it makes me feel especially happy - no, not in a sarcastic manner! -, because I know my articles are actually being read, and people are dedicating a few minutes of their day to just my content. More over they are taking the time to point out typos, broken images, and whatnot. I want to thank you all for the time you have dedicated to my content. It is a very important driving force to continue publishing.\nI want to dedicate a paragraph to thank someone very important to me as well. Alexis Marechal was not only my teacher in college, he is also a great friend, and when I relaunched my website he told me to not stop publishing. If there is anyone who can manage to get the very best out of people, it\u0026rsquo;s Alexis. Thank you so much for everything you have done for me, Alexis! And I promise I will work on that final thesis defense soon.\nThe Community Helped Me When I Needed it the Most. When my Apple Developer Account was about to be terminated in June. I was having an incredibly hard time with it because iOS development is something very important to me. Not being able to publish my apps was going to hurt a lot. Add in the fact this happened one week before WWDC2020 and I was feeling sad. There\u0026rsquo;s no other way to describe what I was feeling other than pure sadness.\nI suffered in silence for about 5 days, until I decided to write the article linked to above to vent my feelings. Somehow, the story made it to HackerNews, and things spiraled from there.\nA bunch of iOS developers started tweeting the HackerNews post, and eventually my article directly. The support from the community got bigger and bigger. A bunch of developers I have a lot of respect for - Peter Steinberg, Dave Verwer, Gui Rhambo, and more, way more -, started sharing my story. And I cannot even begin to find the words, once again, to thank the support I have received from everyone in the community. That day I felt fortunate, because I had googled for days and everyone I saw dealing with the same problem never heard back from Apple and just got terminated. What I experienced with the community\u0026rsquo;s support is nothing short of a privilege. I felt the warmth of the community and it made me think that I\u0026rsquo;m lucky to be part of it.\nEverything Else While it\u0026rsquo;s nothing compared to the numbers other iOS devs are seeing in their blogs, my website currently has around ~35000 monthly visits from all over the world, according to Cloudflare. These numbers wouldn\u0026rsquo;t be possible without everyone\u0026rsquo;s support. The best part is the numbers go up rather than down, so thank you all so much!\nFuture Goals My goal is to focus on creating more content like this. Focus on this website will not die, but I\u0026rsquo;d like to be able to make a living publishing content. This year, I\u0026rsquo;d like to start gathering sponsors. Hopefully eventually, I will be able to start doing videos as well. But for this, I need to make enough money that would cover my current salary.\nThis should be an exciting year for me as a developer. I am looking forward to continue working for the community, hopefully increasing my involvement beyond weekly articles.\n","tags":null},{"id":"857739f9b6e4ea2e76a959d31e6bb40c","title":"A File Download Queue in Combine for Swift","link":"/posts/file-download-queue-combine/","content":"Combine allows us to create pipelines for a lot of tasks. Thanks to the fact it can do work concurrently without leveraging callbacks, it is very easy to build things that would otherwise be very complex.\nIn this short article, we will build a file download queue that downloads images sequentially. You can use this as the base for more complex queues.\nThe queue will download an array of images sequentially. If you wanted to support concurrent queues, it would probably be wise to instantiate this publisher as many times as necessary.\nThe Download Queue The download queue will begin with an array of strings with URLs pointing to the images we want to download.\nvar subscriptions = Set\u0026lt;AnyCancellable\u0026gt;() let images = [ \u0026#34;https://static.zerochan.net/Myne.%28Honzuki.no.Gekokujou%29.full.2884727.jpg\u0026#34;, \u0026#34;https://i.ytimg.com/vi/-CV-EvHCrwY/maxresdefault.jpg\u0026#34;, \u0026#34;https://image.tmdb.org/t/p/original/sCabfIegk8pvg7cquPqgWeN72Vo.jpg\u0026#34; ] Arrays in Swift have a .publisher property that immediately turns arrays into publishers.\nimages .publisher This is an array of strings, not URLs. We need URLs as that\u0026rsquo;s what NSURLSession tasks need to work. We can do this with the .compactMap operator. This operator will do an operation and discard all nil values.\nimages .publisher .compactMap { URL(string: $0) } At this point, our publisher is emitting non-optional URLs.\nTo actually download the images, we need another publisher. URLSession has a method called dataTaskPublisher which returns a NSURLSessionDataTask wrapped in a publisher. We can use the .flatMap operator to convert a publisher into another publisher. Here, we will convert our URL publisher into dataTaskPublisher.\nimages .publisher .compactMap { URL(string: $0) } .flatMap { URLSession.shared.dataTaskPublisher(for: $0) } When this publisher executes, it will give us a URLSession.DataTaskPublisher.Output. This output contains the .data of the content we just downloaded.\nWe will grab only the non-nil data for all the download operations we have received. For this, we can once again leverage compactMap.\nimages .publisher .compactMap { URL(string: $0) } .flatMap { URLSession.shared.dataTaskPublisher(for: $0) } .compactMap { $0.data } We now need to convert this data into an image. To do that, we can use the init(data:) initializer of UIImage. We will use compactMap again, because this initializer can return nil.\nimages .publisher .compactMap { URL(string: $0) } .flatMap { URLSession.shared.dataTaskPublisher(for: $0) } .compactMap { $0.data } .compactMap { UIImage(data: $0) } Finally, we plug in a subscriber so the task can start. We will receive each image sequentially, in the order they appear in the array:\nimages .publisher .compactMap { URL(string: $0) } .flatMap { URLSession.shared.dataTaskPublisher(for: $0) } .compactMap { $0.data } .compactMap { UIImage(data: $0) } .sink(receiveCompletion: ( { state in // Handle completion here })) { output in // Each image will be received here. You can do whatever you want with it. // uiImages += [output] } .store(in: \u0026amp;subscriptions) Other Considerations Internet connections can be spotty. For that reason, you could add the retry operator in the pipeline, so Combine will try to redownload other failed files as many times a you specify.\nIf you receive an other somewhere in the pipeline (with incorrect URLs, for example), the completion will be called on your subscription with a failure. This will cancel the entire subscription if the error happens early in. Consider handling the errors with a .catch block to deal with the error properly according to the context of your app.\nConclusion Combine makes it very easy to create tasks that become too complicated if you try to do them the old way with completion handlers and delegates. Streamlining everything into a pipeline makes it very easy to chain dependent operations without creating many \u0026ldquo;pyramids of doom\u0026rdquo;.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","combine"]},{"id":"e354416581e5f99eb608545f458293e4","title":"Common Reasons for Background Tasks to Fail in iOS","link":"/posts/common-reasons-background-tasks-fail-ios/","content":"Apple introduced modern background tasks last year on iOS 13. These new APIs have been out for a little over year (counting the beta period). Many developers have tried to adopt them to moderate success. Many of them have found them to be very unpredictable and that only work a fraction of the time. If you look around the internet (and even on the comments in that article), you will see many developers weren\u0026rsquo;t able to get them to work as expected.\nIn the article linked above, we mentioned that you can schedule your tasks, but it is entirely up to the system to decide when they will be executed, and if at all. In this article we will explore some common reasons the system may decide to ignore your tasks, so you can hopefully work around the limitations and setup more predictable background tasks.\nIn this article, we will talk about 7 factors that impact background runtime. These factor may apply to your background tasks whether they are using BGAppRefreshTask, BGProcessingTask, background push or URLSession backgrounded tasks.\nIt Is All About Balance. At the end of the day, what matters is balance. Balance between what your app wants to do and what the system needs. In a constrained system where hundreds of apps may be fighting for background resources, the system has to choose who will get to use its battery life and other performance features. After all, the system needs to maintain all-day battery life, be performant at all times, respect users\u0026rsquo; privacy, and respecting user intent.\nFactors That Affect Background Task Execution. There are actually more than seven factors that affect background task execution, but many of them don\u0026rsquo;t require any action. Factors such as the device lock state, if the screen is on or off, there is an iCloud restore going on, the camera is in use are just natural states of the device that you can\u0026rsquo;t do anything about.\nThe factors we care are about will be listed below. These will either require you to do things differently, will require your users to do things differently (a very important factor), or they will require you to understand how resource budgeting work within the system to assign resources. I apologize if some of these are obvious - My source for this article is the \u0026ldquo;Background execution demystified\u0026rdquo; WWDC2020 session vide.\nCritically Low Battery When the battery is at %20 capacity or lower, we can say it is at a critically low battery. The system will choose to preserve battery life by suspending non-essential processes and will prioritize essential work only.\nBackground tasks are opportunistic. If they have a chance to run, they will. You should never rely on background tasks for core functionality of your app. Opportunistic tasks get suspended the moment the device is in critically low battery.\nLow Power Mode Low power mode is similar to having a critically low battery. The main difference is user\u0026rsquo;s can trigger it at will, but the side-effects of it are the same.\nThe system will cancel background processing and opportunistic tasks will be suspended. The device will perform essential activity only.\nThis one is important because a lot of people these days enable low power mode and have it on all the time.\nYou can use NSProcessInfo.processInfo.isLowPowerModeEnabled and NSProcessInfoPowerStateDidChange to query whether low power mode is enabled and to learn when it is triggered by the user.\nApp Usage There are times when the system must prioritize some apps over others. Whenever it is necessary, the system will prioritize apps that are most important to the user. If your users are not using your app as much as other apps, then it will simply be treated as a low priority app by the system. The system uses machine learning to predict what apps the user will use and when, and it will use this information to prioritize background activity.\nApp Switcher Sometimes the system may have hints about what apps the user wants to run, even if they are not part of what the system has learned about their habits.\nOne such hint is the App Switcher. Apps that are currently backgrounded and visible in the App Switcher have higher priority by the system.\nThis is very important. The system will constrain the apps that can run background tasks to apps that are visible on the App Switcher. I have always said that killing apps on iOS is an enemy of the system, because the system is smarter at resource management than humans. Unfortunately, way too many people kill apps in the App Switcher. Those users may never benefit from having the system honor their background task requests.\nWe all know a person or two who this. If your users ever report to you that your app doesn\u0026rsquo;t seem to execute background tasks, this is probably one of the first questions you should ask them.\nBackground App Refresh switch Apps that support background task execution can be enabled and disabled by your users at will. Using the Background App Refresh screen in the Settings app, users can enable and disable background app refresh for specific apps.\nThe switch is enabled by default, so users have to know what they are doing in order to turn it off and what that implies in terms of your app\u0026rsquo;s background execution.\nYou can query the system to know if Background App Refresh is enabled for your app by using NSProcessInfo.processInfo.backgroundRefreshStatus and the UINotification.backgroundRefreshStatusDidChangeNotification notification to learn when it is toggled.\nSystem budgets Because the Background App Refresh switch is enabled by default, many users may not know their apps support background task execution, or even what that means. This is why System budgets are important to understand how your app may execute in the background when you have to compete against hundreds of other apps.\nThe system has both energy and data budgets. These budgets are slowly distributed to different apps throughout the day. When an app runs, it deducts from these budgets - there is no mistake with what I wrote here. The budgets are decreased when your app runs, not only when it manages to execute a background task.\nIf you are a good player and are not running obnoxious lengths of code, the system will have no reason to limit your app.\nRate limiting To help apps with budget management, the system may impose rate limiting on some apps. The system will space out background task launches for you. When you ask the system to schedule a background task for you, the system will decide the optimal time to honor your request.\nThis is one of the sources of confusion for this new system because developers keep scheduling tasks but don\u0026rsquo;t see any execution on them. Remember, you can ask the system to execute a task, but it\u0026rsquo;s up to it to honor your request and what capacity. It may trigger it later than you expect to, earlier, or never.\nControl for Developers. Most of the factors seen above are external, either due to user settings or system resources management. But there is one factor you have slight control over to improve your chances of the system honoring your requests in a timely manner.\nAs we said above, if you are a good player and perform little work per launch, you are being responsible with the budgets assigned to you. But you can do more, and you should prevent your app from using unnecessary resources while it is running.\nPower Consumption Minimize power consumption. Do not use hardware you have no need for. Do not use GPS and accelerometer, or other hardware that needs to be constantly in unless you really need to. When using the GPS, ensure you configure it to receive less events at the cost of slightly less accuracy if it is acceptable.\nDo try to finish work as quickly as possible. If dealing with APIs that require you to call a system completion handler, properly signal the system that you have finished working. This way, the system will know to not only limit your app after your task is done, but it will also know how good of a player you are. For app refresh tasks, always call setTaskCompleted(success:) when you are done.\nData Usage You should also minimize the amount of data your app uses. When called for background refresh, only download what you need to update your UI and nothing more. If you use images, download thumbnails and not full images.\nYou should enqueue URLSession background transfers when you need to download data.\nIdeally, keep the amount of data you download to 100 Kilobytes or less while your app refreshes. This is a good guideline for both app refresh tasks and background pushes,\nBackground Pushes Also known as \u0026ldquo;silent push notifications\u0026rdquo;, you can send background pushes that doesn\u0026rsquo;t show any indication to the users of their reception. They are instead, notifications for the app itself. They are low priority and preserve power.\nThey are great to let the app know that new content is available, but it\u0026rsquo;s not immediately necessary for the user.\nSilent Pushes and the Seven Factors The seven factors come into play for background pushes, except for App Usage.\nThe system will not limit background pushes based on App Usage. So no matter how much your user uses your app, whether it is a bit or much, background pushes will not be gated by app usage metrics.\nThis does not mean background pushes are a free way to trigger your app to do background work. Rate limiting is still a thing when it comes to this mechanism, and you should be responsible with them. If you are sending a lot of silent pushes, you are depleting budgets and affecting system resources.\nTo avoid this, the system may delay the delivery of some background pushes. If you send 14 pushes in a short time, the system will not wake up your app for each. It may coalesce them into 7 pushes to optimize resource usage.\nRather than focusing on the delivery rate, focus on spacing the number of pushes sent to your apps. Send them less often. Background pushes are for non-essential content such as receiving messages in a muted conversation in a chat app.\nBackground URLSessions When you use Background URLSessions, the system is in charge of managing them. This allows the system to continue the transfers even after the app exists (as long as it has not been killed from the App Switcher). They are not constrained by run time limits.\nThey are good for file downloads and photo uploads.\nYou can configure them to not use cellular data and you can configure them to send launch events. This allows the system to notify us when a big file download or upload has completed.\nIf you use the .isDiscretionary property, the work can be deferred until later. Enqueued tasks are always discretionary. The system will choose the right time to execute these tasks, such as when the phone is plugged into a charger and on a Wi-Fi network.\nThe Seven Factors and Background URLSessions Most of the factors apply to background URLSessions depending on the configuration. If the app was brought to the foreground recently, rate limiting won\u0026rsquo;t apply.\nFor non-discretionary launches that may even be queued, only App Switcher and System budgets apply. If the user kills your app while it is executing one of these tasks, the task will stop. System budgets apply, but they are relaxed and not as strict. This is because the system knows the user wants this to happen to some capacity.\nIf you configured your task to send launch events, App Usage and Rate limiting won\u0026rsquo;t apply.\nBackground Processing Tasks. App Usage, App Switcher, Background App Refresh switch, and Rate limiting are the only factors that apply to Background Processing tasks. If the user has used your app at least once in the last few weeks, the system may honor the launch of this task, so the system is very flexible with this type of tasks. If the user charges their phone daily, your tasks are more likely to run.\nConclusion The system will ultimately have all the control on whether your tasks will be executed or not. Still, if you are a good player and your apps are not resource hogs, you should have a better change of getting executed, depending on the conditions, task type, and whether your users are actually using your app.\n","tags":["swift","programming","apple","ios","ipados","backgroundtasks","wwdc2020"]},{"id":"64f72fcf116f23feec2ae8203168c77f","title":"Adding Custom SwiftUI Views and Modifiers to the Xcode Library","link":"/posts/custom-views-modifiers-xcode-library-swiftui/","content":"Xcode 12 introduces the ability for developers to add their own SwiftUI views and modifiers to the Xcode library. This allows people using your code to discover your custom views, makes your codebase easier to learn, and it allows you to visually edit complex views visually rather than with code.\nIn this short article we will explore how we can add our own views and modifiers to the Xcode library.\nThe LibraryContentProvider Protocol The fun thing about doing this is that it is done entirely in code. You do not have to mess with settings panes or anything of the sort in order to create and add your own SwiftUI content to the Xcode Library. Instead, all you need to do is to conform to the LibraryContentProvider protocol. This has the advantage that your custom views in the Library are per-project and the Library won\u0026rsquo;t be polluted with possibly irrelevant views.\nThe protocol looks like this:\nstruct LibraryViewContent: LibraryContentProvider { @LibraryContentBuilder var views: [LibraryItem] @LibraryContentBuilder func modifiers(base: ModifierBase) -\u0026gt; [LibraryItem] } Simple enough - We have an array of views, and a function to return an array of modifiers, both of the type [LibraryItem].\nXcode scans your code for objects conforming to this protocol and adds them to the library.\nThe LibraryItem Object The LibraryItem object, at the very least, expects the view that it will represent in the XcodeLibrary.\nLibraryItem(MyView()) But we can provide it with more information:\nLibraryItem( MyView(), visibility: true, // Whether the item should be visible in the library title: \u0026#34;My View\u0026#34;, // An optional title for the view. category: .control, // The category this view belongs to ) category is a LibraryItem.Category enum. It can be .control, .effect, .layout, and .other.\nConforming to LibraryContentProvider LibraryContentProvider For Views We are going to add this rounded rectangle view as an example:\nstruct RoundedTextView: View { var text: String var body: some View { Text(text) .padding(10) .background(Color.blue) .foregroundColor(.white) .clipShape(RoundedRectangle(cornerRadius: 30, style: .continuous)) } } It looks like this:\nAnd that\u0026rsquo;s it for views! Now when you open the Library (Tapping the + button, or pressing Shift + Command + L), you can search for your view and drag it and click it like you would any other view:\nBy default, you can see it\u0026rsquo;s in a section called customviewtexts. This is group is the name of your project. You cannot really get rid of it, but if you specify another category such as .control you can have better control over the grouping:\nYou can add the same view as many times as you want but with different configurations. In our example, you could create a view with a different text and add that as a different item in the library. If you make properties such as the foreground and background colors, you could add them as different configurations as well.\nLibraryContentProvider for Modifiers To add custom modifiers, start by creating your custom modifier on the view it applies to. In this example we will make a modifier for any view, but you can be as specific as you want:\nextension View { func shadowAndSaturation(saturation: Double) -\u0026gt; some View { self .shadow(color: Color.red, radius: 30) .saturation(saturation) } } Now, we need to implement the modifiers function of LibraryContentProvider.\n@LibraryContentBuilder func modifiers(base: ModifierBase) -\u0026gt; [LibraryItem] { } The ModifierBase is the type of view our modifier should apply to. If you created your modifier in an extension for Text, then you would use text; if you used Image, you would specify Image. In our case it applies to any view, so we will leave it as AnyView.\nAnd done! If you bring up the Library pane now, you can now see your custom modifier in the Modifiers section:\nFinal Discussion Another neat thing about using this system is that you don\u0026rsquo;t have to build and run your project in order for them to appear in the library. Xcode automatically scan and adds LibraryContentProviders without your intervention. Even when your code is not in a runnable state, Xcode can scan and add custom views to its library.\nWhen compiling your code for distribution, all LibraryContentProviders are stripped from your code. And you can use them in Swift Packages as well.\nConclusion Being able to add your own views and modifiers to the library is a great feature. They are project-specific and you can add them with the SPM. Consider using this feature if you have a lot of reusable custom views.\n","tags":["swift","programming","apple","ios","ipados","tvos","swiftui","xcode12"]},{"id":"7d1338d54e3c6998a54614764c3718c6","title":"Wrapping Asynchronous APIs into Combine Futures","link":"/posts/wrapping-asynchronous-apis-into-combine-futures/","content":"Two of the concepts used a lot in Reactive Programming are the Future and Promises. Whether you have been using Combine for a while or are new to Reactive Programming, chances are you have seen these two words. These terms date to years ago. And I would be lying if I told you I knew what that they were for until I started learning Combine. The first time I heard about Futures and Promises was back in my NodeJS job half a decade ago, and I didn\u0026rsquo;t understand these concepts back then.\nIn this short article, we will learn about Futures and Promises and how we can use them in our iOS/iPadOS/watchOS/macOS apps to integrate asynchronous code with callbacks into Combine. Basic knowledge of Combine is assumed for this article.\nBut First, a Quick Word on Asynchronous APIs and Combine Before we dive right in, there\u0026rsquo;s one thing we need to keep in mind when we work with combine. Combine allows us to grab multiple sources into a single, consistent reactive API. In the case of the iOS SDK, for example, we have a lot of frameworks that may give data either via callbacks (URLSession), sometimes app wide notifications (UINotificationCenter APIs), and more. Combine allows us to grab all these different sources and combine them into one. So dealing with networking callbacks or app wide notifications becomes the same process thanks to the reactive API.\nApple\u0026rsquo;s SDKs provides us with many Publishers for common tasks. For example, where we had URLSession\u0026rsquo;s dataTask, we now have a dataTaskPublisher as well. And rather than registering callbacks or target-actions for UINotificationCenter, we now have a .publisher property to work with notifications on Combine/\nDespite all this, there are still some APIs that could benefit of a Combine publisher integration but they currently do not.\nFutures and Promises Promises and Futures are two components of a system that allows us to run code concurrently and have a way to know when such code has finished running. If you google for a definition of futures and promises you are going to find a lot passionated discussions and even some mathematical definitions of these concepts that make it hard to wrap your head around.\nYou can think of a future as a placeholder for a value that doesn\u0026rsquo;t exist yet. This empty placeholder can happily sit forever, idle in your code. When it finally receives a value, in the context of Combine, the Future is essentially a publisher that will send the fulfilled value down the pipeline. The code that fills in this empty value is the promise. So, the future is the value we want to have, and the promise fulfills that value for us. You can imagine this system makes it very easy and intuitive to work with asynchronous code that gives us a value back.\nCombine-fying Non-Combine Asynchronous Code Into a Future Publisher As I said earlier, there are some elements in Apple\u0026rsquo;s SDKs that could benefit from a Combine publisher, but they don\u0026rsquo;t provide such a thing. One examples I can immediately think of is the LocalAuthentication framework, when you need to ask for permission to use Touch ID or Face ID.\nIn the case of the LocalAuthentication framework, you can simply create a Future directly:\npublic enum BiometryError: Error { case localAuthenticationFrameworkError(errorPointer: LAError) case evaluationError(error: Error) case unauthorized } let biometryFuture = Future\u0026lt;Bool, BiometryError\u0026gt; { completion in // 1 let context = LAContext() let biometricPolicy = LAPolicy.deviceOwnerAuthenticationWithBiometrics var error: NSError? if context.canEvaluatePolicy(biometricPolicy, error: \u0026amp;error) { context.evaluatePolicy(biometricPolicy, localizedReason: \u0026#34;To log in\u0026#34;) { (success, error) in if let error = error { completion(.failure(.evaluationError(error: error))) // 2 } else if success { completion(.success(true)) // 3 } else { completion(.failure(.unauthorized)) } } } else if let error = error as? LAError { let errorWrapper = BiometryError.localAuthenticationFrameworkError(errorPointer: error) completion(.failure(errorWrapper)) } } This looks like quite a mouthful, so let\u0026rsquo;s give a quick rundown of what\u0026rsquo;s going on here. It\u0026rsquo;s worth noting that the handful isn\u0026rsquo;t even the Combine Future/Promise part:\nWe are creating a future that will return a Bool on success, and a BiometryError on failure. We can use the completion handler. This allows our Promise to notify the Future that a value is ready. In this case, we provide a BiometryError We were able to successfully get a biometric scan, so we pass in the right value. And that, is a perfectly valid publisher. You can use it as such with the operators you know and love.\nbiometryFuture .sink(receiveCompletion: { (completion) in // Handle any errors here }, receiveValue: { (value) in print(\u0026#34;Did Login Successfully: \\(value)\u0026#34;) }) .store(in: \u0026amp;subscriptions) Conclusion We can Combine anything into publishers, even if we do not have native publishers for it. Using Futures and Promises is a good way to make simple asynchronous code into Combine code.\nIf you find any inaccuracies (and that includes typos) or problems in this article please tweet at me (@AndyIbanezK) or send me an e-mail to andy[at]andyibanez[dot]com. Thank you for helping me improve the quality of my blog!\nIf there\u0026rsquo;s anything related to Swift, iOS, or another Apple Platform you\u0026rsquo;d like me to cover, feel free to contact me and I will try to cover it in an upcoming article.\n","tags":["swift","programming","apple","ios","ipados","tvos","combine"]},{"id":"5b28596d51a487d23fc81e95907a3139","title":"Sharing Data Across Apple Devices with the MultipeerConnectivity Framework","link":"/posts/sharing-data-apple-devices-multipeerconnectivity-framework/","content":"There are times when we may want to share data across instances of our app running on different physical devices. You could develop a server or even leverage cloud storage, but did you know Apple provides a framework to share data directly across devices, without having to use an intermediary? This framework is the MultipeerConnectivity framework, and it has actually been around for a while. In this article, we will explore this framework to understand how we can use it to share data across instances of our app in different devices directly.\nThe MultipeerConnectivity Framework. This framework is actually very old. It was introduced in iOS 7 all the way back in 2013. macOS later supported in OS X 10.10 Yosemite in 2014, and it\u0026rsquo;s even supported by tvOS starting on tvOS 10.0. It supports a wide arrange of devices.\nThe framework allows you to send basically any kind of data, whether it is short strings of text or images.\nHow It Works Before we dive deep into the code, we need to understand, superficially, the technologies it uses under the hood. This is important because you will be able to understand the capabilities and limitations of the framework in case you ever come across code that you expect to work, but doesn\u0026rsquo;t.\nWhat\u0026rsquo;s important to know is that the framework can use different mediums to share data and not all devices support the same mediums.\niOS Support In iOS, the framework can use the following as the underlying medium for data sharing:\nInfrastructure Wi-Fi (AKA the Wi-Fi you have in your house). Peer-to-peer Wi-Fi. Bluetooth Personal Area Network (PANs). macOS and tvOS tvOS and macOS both support the same transport mechanisms:\nInfrastructure Wi-Fi Peer-to-peer Wi-Fi Ethernet Overall Architecture Devices cannot connect and send data to any device willy-nilly. Before two devices can share data, they need to establish a Session (a MCSession object) with each other.\nTo do this, one of the device becomes the advertiser and it starts broadcasting to nearby devices. It simply tells them \u0026ldquo;hey all, I am willing to connect to one, as long as you guys are offering a session of this type. This is done with the MCNearbyServiceAdvertiser, object, or with the MCAdvertiserAssistant object. The only difference between these two objects is that the latter provides an UI to accept invitations. If you want to create your own UI to let your user manage their invitations, you can use the former.\nOther apps can start looking for advertisers using the MCNearbyServiceBrowser or MCBrowserViewController objects. These two objects will let you see which devices are advertising the service type you want to connect to. Just like advertiser objects, the latter provides you with a standard UI, but you can build your own UI with the former if you want.\nFinally, all apps running an instance of the app have a MCPeerID associated to them. This ID is unique to each device.\nPlaying with the MultipeerConnectivity Framework With all that theory out of the way, it\u0026rsquo;s time to write a bit of code. We will explore a few more concepts as we do, so you can understand better how to use this framework.\nIf you want to use the code here, you may want to get two devices. I will provide a sample project at the end that you can install on two devices so you can see them share data with each other.\nBecoming the Advertiser We will explore how to become an advertiser using MCNearbyServiceAdvertiser first, as this gives us more control over the UI and experience when establishing a session.\nEstablishing an MCSession is a two-step progress. The first step is the discovery step. In the discovery step, a device can start looking for devices to connect to (advertisers who have a MCNearbyNearbyAdvertiser or MCAdvertiserAssistant currently advertising) using the MCNearbyServiceBrowser object.\nAdvertisers can start a session with code like this:\nvar advertiser: MCNearbyServiceAdvertiser? let serviceType = \u0026#34;MPCTutorial\u0026#34; var myId = MCPeerID(displayName: UIDevice.current.name) //... func becomeAdvertiser() { let discoveryInfo = [ \u0026#34;Device Type\u0026#34;: UIDevice.current.model, \u0026#34;OS\u0026#34;: UIDevice.current.systemName, \u0026#34;OS Version\u0026#34;: UIDevice.current.systemVersion ] advertiser = MCNearbyServiceAdvertiser(peer: advertiserId, discoveryInfo: discoveryInfo, serviceType: serviceType) advertiser?.delegate = self advertiser?.startAdvertisingPeer() } There is a bit going on here. First, we create a dictionary called discoveryInfo. During the discovery step, before the devices have had the opportunity to establish a session, they can broadcast limited activity about themselves using this dictionary. In our case we are offering the device name, OS, and OS Version to be seen by other devices who want to connect to us. In certain scenarios this can help provide more information to the devices to ensure they connect to the right one.\nWhen we create our MCNearbyServiceAdvertiser object, we need to pass in our MCPeerID. We create our peer ID also using the device name. The discoveryInfo is the same dictionary we defined earlier. Finally, the serviceType can be any string you want, as long as it is a maximum of 15 characters long, ASCII characters only, and/or hyphen.\nYou should only use the init(displayName) initializer when creating a peer locally. You can persist MCPeerdID long term to be used later on.\nWe assign the delegate to self. This is a MCNearbyServiceAdvertiserDelegate object that will receive events related to device discovery with devices coming to us. We will implement its only method in a bit.\nWe call startAdvertisingPeer() and we are ready to be seen by other devices. There is a matching stopAdvertisingPeer() we can use when we no longer want to be discoverable too.\nSearching for devices to connect to As part of the discovery step, other devices start looking for advertisers. This can be done as easily as:\nvar myId = MCPeerID(displayName: UIDevice.current.name) var browser: MCNearbyServiceBrowser? var connectedPeer: MCPeerID? //... func searchForDevices() { browser = MCNearbyServiceBrowser(peer: inviteeId, serviceType: serviceType) browser?.delegate = self browser?.startBrowsingForPeers() } We do not need to provide much info to browsers, as most of the info comes from advertisers. Set the delegate as it will receive all the events related to peer discovery. You can startBrowsingForPeers() and stopBrowsingForPeers() as you see fit.\nOnce you start browsing for peers, the browser will call two delegate methods:\nfunc browser(_ browser: MCNearbyServiceBrowser, foundPeer peerID: MCPeerID, withDiscoveryInfo info: [String : String]?) { print(\u0026#34;We found a peer!\u0026#34;) print(\u0026#34;ID: \\(peerID.displayName)\u0026#34;) print(\u0026#34;Device Type: \\(info?[\u0026#34;Device Type\u0026#34;] ?? \u0026#34;\u0026#34;)\u0026#34;) print(\u0026#34;Version: \\(info?[\u0026#34;OS Version\u0026#34;] ?? \u0026#34;\u0026#34;)\u0026#34;) } func browser(_ browser: MCNearbyServiceBrowser, lostPeer peerID: MCPeerID) { print(\u0026#34;We lost peer \\(peerID.displayName)\u0026#34;) } So, one by one, you will receive information about peers that show up and peers that disappear, easy as that.\nInviting devices to connect to us We are following the manual approach in this article, so we will do the manual connecting process.\nOnce we find a peer we want to connect to (with browser(foundPeer:peerID:withDiscoveryInfo), we need to create a MCSession. We use this object to connect to other peers.\nfunc invitePeerToConnect(peerID: MCPeerID) { session = MCSession(peer: myId) session?.delegate = self self.connectedPeer = peerID browser?.invitePeer(peerID, to: session!, withContext: nil, timeout: 30) } You need to set the session delegate to receive events regarding the session, including when the session state changes and when you receive any data.\nA bit of discussion on MCSession is in order. MCSession has more than one initializer. The second initializer can be used to create secure and encrypted communication channels between both devices. We will not discuss \u0026ldquo;secure\u0026rdquo; MCSessions in this article, but be aware of the init(peer:securityIdentity:encryptionPreference initializer, as there may need a case in which you need to verify a peer and/or you\u0026rsquo;ll have the need to share encrypted information. Encryption handling is very transparent. MCEncryptionPreference is just an enum, and you can use encryption without verifying the peer. in iOS 9 and above, it will require encryption by default.\nthe context parameter is an optional data that you can use to pass anything to provide even more context. Do not send any sensitive data with this. The connection has not been established yet, so if you are using encryption, this particular piece of data will not be encrypted.\nWhen you invite an advertiser to connect, the advertiser delegate will call the advertiser(didReceiveInvitationFromPeer peerID:context:invitationHandler delegate method.\nIn this example, we will immediately accept the invitation to connect:\nfunc advertiser(_ advertiser: MCNearbyServiceAdvertiser, didReceiveInvitationFromPeer peerID: MCPeerID, withContext context: Data?, invitationHandler: @escaping (Bool, MCSession?) -\u0026gt; Void) { print(\u0026#34;Invitation to connect from \\(peerID.displayName)\u0026#34;) print(\u0026#34;Accepting invite\u0026#34;) session = MCSession(peer: advertiserId) invitationHandler(true, session) } Sharing Data - The Session Phase. After the advertiser has accepted the invite, the session phase will start. When the connection state has changed, the session(peer:didChange) delegate method of MCSession gets called. When the state is .connected, we are ready to send data.\nfunc sendImage(toPeer peer: MCPeerID) { let bundledImage = Bundle.main.url(forResource: \u0026#34;cucoo\u0026#34;, withExtension: \u0026#34;png\u0026#34;)! let imageData = try! Data(contentsOf: bundledImage) DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(5)) { try! self.session?.send(imageData, toPeers: [peer], with: .reliable) } } On the receiving device, the session(_:didReceive:fromPeer:) from peer will get called, and you can process the image then.\nfunc session(_ session: MCSession, didReceive data: Data, fromPeer peerID: MCPeerID) { print(\u0026#34;Did receive data\u0026#34;) if let imageData = UIImage(data: data) { DispatchQueue.main.async { self.imageView.image = imageData } } } The session can receive other kinds of information as well, and it even supports streaming!\nfunc session(_ session: MCSession, didReceive stream: InputStream, withName streamName: String, fromPeer peerID: MCPeerID) { } func session(_ session: MCSession, didStartReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, with progress: Progress) { } func session(_ session: MCSession, didFinishReceivingResourceWithName resourceName: String, fromPeer peerID: MCPeerID, at localURL: URL?, withError error: Error?) { } Sample Project I have created a sample project of everything here. You can download it from here. You need to install it on two devices to see how it works. The UI simply contains three buttons: One to become an advertiser, one to search for devices, and another to send a default image. When you search for a peer, it will automatically send an invite to the first device it sees. After you tap \u0026ldquo;Search for Devices\u0026rdquo;, wait a few seconds and tap \u0026ldquo;send image\u0026rdquo; on either device. A glorious image of a cucoo will show up on the destination device.\nConclusion MultipeerConnectivity provides an easy interface to share data between devices. It will automatically choose the right medium to send data. There\u0026rsquo; a few things to keep in mind:\nIt currently supports 8 peers connected at the same time. When the state changes to .connected, the connection only lasts a bit when idle. You should try to send data as soon as the connection is established. We can get it to work with Bonjour and other APIs if we do manual peer management. That is out of the scope of this article. Conclusion Reflection is a very interesting feature that allows to create some sort of meta-programming in Swift. While not applicable to many use cases, it\u0026rsquo;s important to be aware of its existence.\n","tags":["swift","programming","apple","ios","ipados","tvos","multipeerconnectivity"]},{"id":"e55a3c26bea737aa40d08c8a12e48173","title":"New UIDatePicker in iOS 14","link":"/posts/new-uidatepicker-ios14/","content":"WWDC2020 brought many interesting and unexpected updates to many old and well known APIs. In this article, we will explore what\u0026rsquo;s new with UIDatePicker on iOS, an API that has existed since the dawn of time and hasn\u0026rsquo;t changed much since its introduction.\nA Short History on Pickers UIDatePicker is an API that has existed since the very early days of the iOS SDK - it goes all the way back to iOS 2.0.\nIf you have been developing for iOS for a while, you must remember this beauty:\nIn iOS 7, the whole system received a full redesign. Look at the huge update our old friend UIDatePicker went through:\n\u0026hellip; Not much of a chance for our old friend. But iOS 14 introduced a whole new date picker we can use. It\u0026rsquo;s much easier and flexible to use for our end users, and we don\u0026rsquo;t have to do much to adopt it.\nUIDatePicker in iOS 14 UIDatePicker Styles First things first, the old wheel-styled picker is not actually gone. Instead, UIDatePicker now has a property called datePickerStyle where you can let the system choose the best style with the .automatic style, or you can choose between .compact and .inline - both new to iOS 14 - or .wheel, which is the old style we have known for over a decade.\nThe .compact Style The .compact date picker style presents the user as a small UI the user can tap.\nThis tiny UI takes up less space, and the best part is it is interactive. When the user taps it, they will view the new full calendar view in all its glory:\nIn this full calendar view, your user has more flexibility to choose a time and a date, with arrows to move between months and more.\nThe picker is still as customizable as always. You can for example, show a prompt to select only the date or only the time instead of both as it is by default.\nThe .inline Style This style is essentially the same as .compact with the difference that your user will never see a little UI they have to tap. Instead, the calendar or time picker component will be there in all its glory ready to be used.\nFinally, in either .inline or .compact modes, your user can tap the top right label that shows the month and year and the system will show a wheel picker to let them quickly jump to a different month and year:\nConclusion Old and known APIs have received a deserved refresh in iOS 14. The new date picker is easy to implement and it provides your users with a faster way to check dates.\n","tags":["uikit","uidatepicker","swift","programming","apple","ios","ipados","wwdc2020","apple"]},{"id":"d3433f1a0eb2973f464d16d338c19a8d","title":"UIMenu Improvements in iOS 14","link":"/posts/uimenu-improvements-ios14/","content":"UIMenu is a new set of APIs that were originally introduced in iOS 13. The API allows us to add menus to different parts of our UIs, including binding actions to key combinations when using your iOS or iPadOS device with a keyboard. Starting on iOS and iPadOS 14 (and ported to macOS Catalyst), this object is more prevalent in the UI thanks to the fact it can be invoqued from different actions.\nTo understand what I mean, take a look at these screenshots I took from Safari and the Settings app on iOS:\nEssentially, we can now attach a menu to UIBarButtonItems and other UI APIs to do additional settings. By default, you can long-press a back button and it will show you a stack of views you are currently on top of, so you can quickly go back to another view. In Safari, we can quickly do more actions on our tabs, check our history, and even see our navigation history of the specific tab thanks to this API.\nQuick Introduction to UIMenu. A menu represents a series of actions we can perform. In its simplest form, the API consists of a UIMenu, which lets us define menus; and UIAction (subclass of UIMenuElement, which is the action we want to perform when our menu item is selected. Menus can be used in a wide array of places in the system, but we will explore how to use it in a few places as introduced in iOS 14.\nUIMenu with UIBarButtonItems Using the new features of UIMenu is possible with UIBarButtonItems regardless of whether they are in the navigation bar or toolbar. To adopt this functionality, UIBarButtonItem has twi new initializers:\ninit(title:image:primaryAction:menu systemItem:primaryAction:menu The primaryAction allows you to specify the UIAction that should be triggered when the user simply taps the item. You can think of it as a replacement (finally) for the default target/action we have had to deal with for years. This property can be nil, and when it is missing, the system will automatically show your menu when your user taps on it. If there is a default action, you can long-press the item to show the menu.\nThe menu parameter is a UIMenu item. This UIMenu item has a property called children which is an array of all the UIActionss you can call. You can configure your actions as you wish, assigning them text, images, and more properties.\nIn the below example, we will create a bar button item on the toolbar which by default it will do nothing, so the system will show our menu for us:\noverride func viewDidAppear(_ animated: Bool) { super.viewDidAppear(animated) navigationController?.isToolbarHidden = false let addNewItem = UIBarButtonItem(systemItem: .add, primaryAction: nil, menu: createMenu()) toolbarItems = [addNewItem] } func createMenu() -\u0026gt; UIMenu { let photoAction = UIAction( title: \u0026#34;Camera\u0026#34;, image: UIImage(systemName: \u0026#34;camera\u0026#34;) ) { (_) in print(\u0026#34;New Photo from Camera\u0026#34;) } let albumAction = UIAction( title: \u0026#34;Photo Album\u0026#34;, image: UIImage(systemName: \u0026#34;square.stack\u0026#34;) ) { (_) in print(\u0026#34;Photo from photo album\u0026#34;) } let fromWebAction = UIAction( title: \u0026#34;From the Web\u0026#34;, image: UIImage(systemName: \u0026#34;globe\u0026#34;) ) { (_) in print(\u0026#34;Photo from the internet\u0026#34;) } let menuActions = [photoAction, albumAction, fromWebAction] let addNewMenu = UIMenu( title: \u0026#34;\u0026#34;, children: menuActions) return addNewMenu } When you tap the bar button item, it will neashow your menu like this:\nTry adding a primaryAction now:\nlet defaultMenuAction = UIAction(title: \u0026#34;\u0026#34;) { (_) in print(\u0026#34;A default action has been triggered!\u0026#34;) } let addNewItem = UIBarButtonItem(systemItem: .add, primaryAction: defaultMenuAction, menu: createMenu()) toolbarItems = [addNewItem] Now when you tap your item, the default action is called. If you long press it, you will see your menu. Incredibly neat and useful! This is one of my favorite features.\nAnd to make it even better, you can get completely get rid of the non-Swifty target/action model we have used since times memorial, but providing a primary action, and passing in nil for the menu.\nlet dismissAction = UIAction(title: \u0026#34;\u0026#34;) { (_) in self.dismiss(animated: true, completion: nil) } let dismissItem = UIBarButtonItem( title: nil, image: UIImage(systemName: \u0026#34;xmark\u0026#34;), primaryAction: dismissAction, menu: nil) If having a menu on bar button items was blowing me away, I\u0026rsquo;m more blown away by the fact that we can finally modernize some old code by getting rid of target/action!\nUIDeferredMenuElement Introduced in iOS 14, this object allows you, asynchronously, build up your UIMenu. This is very cool, because it allows you to build your menu based on items from a web service or any other lengthy operations.\nTo show how this works, we are going to pretent we are fetching a dynamic menu from an API that lets us follow, list, and block users.\nTo do this, I am hosting a simple JSON file on this GitHub Gist, and it looks like this:\n[ { \u0026#34;title\u0026#34;: \u0026#34;Follow @AndyIbanezK\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;person.badge.plus.fill\u0026#34; }, { \u0026#34;title\u0026#34;: \u0026#34;Block @AndyIbanez\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;xmark\u0026#34; }, { \u0026#34;title\u0026#34;: \u0026#34;Add @AndyIbanez to List\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;text.insert\u0026#34; } ] title is the text that will be displayed by our menu elements, and icon is the SF Icon to display.\nOur menu struct looks like this:\nstruct RemoteItem: Codable { let title: String let icon: String } Now, to consume this service:\nfunc menuItemsForUser(completionHandler: @escaping (_ menuItems: [RemoteItem]?) -\u0026gt; Void) { let urlSession = URLSession(configuration: .default) let url = URL(string: \u0026#34;https://gist.githubusercontent.com/AndyIbanez/3e35465072db98848c2416fd588708a8/raw/07fdec07b1ee8a0068b47b8b79cd328ef69d0589/deferred_menu_example_jso\u0026#34;)! urlSession.dataTask(with: url) { (data, _, _) in DispatchQueue.main.async { if let data = data { let menuItems = try? JSONDecoder().decode([RemoteItem].self, from: data) completionHandler(menuItems) } else { completionHandler(nil) } } }.resume() } We will use try? when trying to parse to avoid error handling. You will naturally to do this properly in a real app.\nFinally, we will use this when creating our UIDeferredMenuElement object. This object takes a closure as its argument. We we will call the completion handler when we are done fetching the items.\nlet dynamicElements = UIDeferredMenuElement { completion in // 1 self.menuItemsForUser { (items) in if let items = items { // 2 let actions = items.map { item in // 3 UIAction(title: item.title, image: UIImage(systemName: item.icon)) { _ in print(\u0026#34;\\(item.title) tapped\u0026#34;) } } completion(actions) // 4 } else { let action = UIAction( title: \u0026#34;Error fetching menu\u0026#34;, image: UIImage(systemName: \u0026#34;xmark.octagon\u0026#34;), attributes: [.disabled]) { _ in } completion([action]) // 5 } } } And to handle the menu display:\nlet userMenu = UIMenu( title: \u0026#34;\u0026#34;, children: [dynamicElements]) let userItem = UIBarButtonItem( title: nil, image: UIImage(systemName: \u0026#34;person.fill\u0026#34;), primaryAction: nil, menu: userMenu) toolbarItems? += [userItem] Basically, what we are doing here:\nCreate a new UIDeferredMenuElement object, with a closure and completion handler. Unwrap the items if they exist. If they exist, we will map our RemoteItems into UIActions. Call the completion handler with our array of UIActions. If force unwrapping fails, we will create a new menu element that will be disabled to tell our users that loading the menu has failed. When you invoke your menu, you will see this first:\nIf the menu loads without an issue, you will see it just fine:\nFinally, if the menu fails to load (you can test this easily by changing the URL a little), your user will see this:\nOne last thing before we wrap up this article. You can combine static menu elements with dynamic ones just like this:\nlet viewProfileAction = UIAction( title: \u0026#34;View Profile\u0026#34;, image: UIImage(systemName: \u0026#34;person.fill\u0026#34;)) { (_) in print(\u0026#34;View profile selected\u0026#34;) } let userMenu = UIMenu( title: \u0026#34;\u0026#34;, children: [viewProfileAction, dynamicElements]) Conclusion UIMenu brings a bunch of interesting and unexpected features. Being able to dynamically load menu elements and mix them with static elements is a great feature I didn\u0026rsquo;t know I wanted. This article may or may not be updated as I learn more about the new features introduced for UIMenu and related APIs.\n","tags":["wwdc2020","swift","programming","apple","ios","ipados"]},{"id":"9ab8eb580b34cfdde0bc17391c60025f","title":"The secret entitlements behind Default Apps on iOS","link":"/posts/default-apps-may-not-be-possible-all-devs/","content":"I hate that my first WWDC article is going to be as lazy as this, but I thought I\u0026rsquo;d write about it anyway so as to at least give an starting point to devs who will want to try creating their own default web browser or e-mail client on iOS and iPadOS.\nPlease note the vast majority of my thoughts here are based on a very short response I received on the dev forums. I may be awfully wrong. I am leaving a link to my original question in the dev forums so you can check it out, and reach your own conclusions. The link can be viewed by anyone and it\u0026rsquo;s not locked behind an Apple Developer membership.\nI spent a good amount - if not all - of my free time today trying to figure out how someone would make an app that can be set as the default Web Browser or default E-Mail client on iOS. After not finding any documentation on how would devs create such an app, I asked on the Apple Dev Forums.\nThe answer I got makes me think that not all web browsers and e-mail clients may obtain the privilege of being used as default apps on iOS.\nTo be able to be set as a default default web browser, an iOS app must:\nGet the com.apple.developer.default-web-browser \u0026ldquo;managed entitlement\u0026rdquo;. By \u0026ldquo;managed entitlement\u0026rdquo;, I understand that only Apple can give you it. It wouldn\u0026rsquo;t be the first API hidden behind an entitlement that not everyone can get. You must adopt minimum functionality. This is fully expected and I wouldn\u0026rsquo;t argue against it as link handling would have to be done exactly the same way Safari does it. If you want more guidance on these steps, you have to email \u0026ldquo;default-app-requests@apple.com\u0026rdquo;. I was told to tell them about my app (I have no Web Browser in the works, so I won\u0026rsquo;t e-mail them just yet), so I\u0026rsquo;m thinking they will choose to give you the entitlement or not based on what you tell them. It looks like developers who want to create apps that can be set as a default for web browsing and e-mail will have to get through some bureocracy as of now.\nI understand why they\u0026rsquo;d make such a system, but hopefully, this will loosen with time. Maybe in a major release or two, the docs for default apps will be available to everyone and we won\u0026rsquo;t have to go through this process.\n","tags":["apple","wwdc2020"]},{"id":"80db1433805babaadb06d816a5a05be2","title":"Error Protocol Specializations in Swift","link":"/posts/error-protocol-specializations-swift/","content":"Earlier this week I was scrolling through my Twitter feed as usual and I found this tweet that made me realize I may have been handling errors incorrectly in Swift all my life. This prompted me to research a bit more about error handling in Swift, and it turns out there\u0026rsquo;s many specialized Error protocols you can conform to, and you should probably be using them over the default Error provided by the language. All these specializations conform to Error themselves. In this article, we will explore a few specializations we can use when dealing with errors in Swift.\nKeep in mind that they are part of the Foundation framework though, so they may not work when used outside Apple\u0026rsquo;s platforms.\nLocalizedError LocalizedError provides four properties to display your user information about errors in their native language.\nThe four properties are the following and they are all strings. They are required, but they provide a default implementation.\nerrorDescription failureReason helpAnchor - I wasn\u0026rsquo;t able to find what this one is for, specifically on iOS. recoverySuggestion A sample of implementation could be:\nenum NetworkError: LocalizedError { case noNetwork case unexpectedResponse var errorDescription: String { switch self { case .noNetwork: NSLocalizedString(\u0026#34;No network connection found\u0026#34;, comment: \u0026#34;\u0026#34;) case .unexpectedResponse: NSLocalizedString(\u0026#34;The server returned an unexpected response\u0026#34;, comment: \u0026#34;\u0026#34;) } } var failureReason: String? { switch self { case .noNetwork: NSLocalizedString(\u0026#34;Could not connect to the internet\u0026#34;, comment: \u0026#34;\u0026#34;) case .unexpectedResponse: NSLocalizedString(\u0026#34;The server is not working properly\u0026#34;, comment: \u0026#34;\u0026#34;) } } var recoverySuggestion: String? { switch self { case .noNetwork: NSLocalizedString(\u0026#34;Check your internet connection and try again\u0026#34;, comment: \u0026#34;\u0026#34;) case .unexpectedResponse: NSLocalizedString(\u0026#34;Contact support\u0026#34;, comment: \u0026#34;\u0026#34;) } } } There\u0026rsquo;s another neat detail about this type of error, and that is that, when bridged to Objective-C (or casted as NSError) all the properties of the protocol become keys of the NSError\u0026rsquo;s userInfo dictionary:\nNSLocalizedDescriptionKey for errorDescription NSLocalizedFailureReasonErrorKey for failureReason NSLocalizedRecoverySuggestionErrorKey for recoverySuggestion NSHelpAnchorErrorKey for helpAnchor So if you intended your errors to bridge to Objective-C, this is one specialization to consider.\nRecoverableError RecoverableError provides facilities to help your users attempt to recover from errors. This specialization provides one property and two methods:\nrecoveryOptions: This is an array of strings that you can show your user when attempting to recover from errors. This property is required and you are not provided with a default implementation. attemptRecovery(optionIndex:) -\u0026gt; Bool: Use this to try to recover from an error, and then return a Boolean indicating whether the operation was successful or not. The optionIndex corresponds to the index of the option in the recoveryOptions array. This is required, but you are provided with a default implementation. attemptRecovery(optionindex:completionHandler:) -\u0026gt; Void: Just like the previous method, use this to try to recover from the error. The difference is you use a closure to pass in the result of the recovery, so you can use this when you need to try to recover using asynchronous operations. A quick sample implementation:\nenum NetworkError: RecoverableError { case noNetwork case unexpectedResponse var recoveryOptions: [String] { switch self { case .noNetwork: return [ NSLocalizedString(\u0026#34;Retry\u0026#34;, comment: \u0026#34;\u0026#34;), NSLocalizedString(\u0026#34;Open Settings to Change Network\u0026#34;, comment: \u0026#34;\u0026#34;) ] case .unexpectedResponse: return [ NSLocalizedString(\u0026#34;E-Mail support\u0026#34;, comment: \u0026#34;\u0026#34;), NSLocalizedString(\u0026#34;Change server\u0026#34;, comment: \u0026#34;\u0026#34;) ] } } func attemptRecovery(optionIndex recoveryOptionIndex: Int) -\u0026gt; Bool { switch self { case .unexpectedResponse: if recoveryOptionIndex == 0 { // Mail support } else if recoveryOptionIndex == 1 { // Change server } return true default: return false } } // ... } Once again the properties can be accessed via NSError\u0026rsquo;s userInfo, by using the NSLocalizedRecoveryOptionsErrorKey for the recoveryOptions and the NSRecoveryAttempterErrorKey key to access the recovery options.\nCustomNSError Finally, the CustomNSError specialization provides us with properties to create a well-known NSError object, that has an error domain, error code, and the user info. All the properties are required, but you are provided with a default implementation for each:\nerrorDomain: If you worked with Objective-C, you know this one. It\u0026rsquo;s the domain of the error, in reverse DNS notation. errorCode: An error code, as an int. errorUserInfo: The userInfo, as a [String: Any] dictionary. enum NetworkError: CustomNSError { enum ErrorCode: Int { case noNetwork case unexpectedResponse } var errorDomain = \u0026#34;com.andyibanez.com.myApp.NetworkError\u0026#34; var appErrorCode: ErrorCode var errorCode: Int { return self.appErrorCode.rawValue } var errorUserInfo: [String : Any] { let dic = [ \u0026#34;URL\u0026#34;: //..., ] } } Also bridged to NSError, this is the \u0026ldquo;rawest\u0026rdquo; error I could find that can be bridged to Objective-C. Since you provide the userInfo yourself, you don\u0026rsquo;t have to worry about about what keys it has. It has a lot of flexibility, but more complicated to work with.\nMashing Them Together Remember that these are protocols, and you are allowed to conform to more than one protocol at the same time, so nothing prevents you from, say, creating a recoverable localized error.\nenum NetworkError: LocalizedError, RecoverableError { case noNetwork case unexpectedResponse // MARK: - LocalizedError var localizedDescription: String { switch self { case .noNetwork: return NSLocalizedString(\u0026#34;No network connection found\u0026#34;, comment: \u0026#34;\u0026#34;) case .unexpectedResponse: return NSLocalizedString(\u0026#34;The server returned an unexpected response\u0026#34;, comment: \u0026#34;\u0026#34;) } } var failureReason: String? { switch self { case .noNetwork: return NSLocalizedString(\u0026#34;Could not connect to the internet\u0026#34;, comment: \u0026#34;\u0026#34;) case .unexpectedResponse: return NSLocalizedString(\u0026#34;The server is not working properly\u0026#34;, comment: \u0026#34;\u0026#34;) } } // MARK: - RecoverableError var recoverySuggestion: String? { switch self { case .noNetwork: return NSLocalizedString(\u0026#34;Check your internet connection and try again\u0026#34;, comment: \u0026#34;\u0026#34;) case .unexpectedResponse: return NSLocalizedString(\u0026#34;Contact support\u0026#34;, comment: \u0026#34;\u0026#34;) } } var recoveryOptions: [String] { switch self { case .noNetwork: return [ NSLocalizedString(\u0026#34;Retry\u0026#34;, comment: \u0026#34;\u0026#34;), NSLocalizedString(\u0026#34;Open Settings to Change Network\u0026#34;, comment: \u0026#34;\u0026#34;) ] case .unexpectedResponse: return [ NSLocalizedString(\u0026#34;E-Mail support\u0026#34;, comment: \u0026#34;\u0026#34;), NSLocalizedString(\u0026#34;Change server\u0026#34;, comment: \u0026#34;\u0026#34;) ] } } func attemptRecovery(optionIndex recoveryOptionIndex: Int) -\u0026gt; Bool { switch self { case .unexpectedResponse: if recoveryOptionIndex == 0 { // Mail support } else if recoveryOptionIndex == 1 { // Change server } return true default: return false } } } Conclusion Error handling in Swift suddenly became easier when I learned about these Error specializations. Though, to be honest, they are more powerful when using them in macOS rather than the smaller OSes, because macOS has APIs to which you can provide your errors and let the system manage their displaying and even their recovery. in iOS, they aren\u0026rsquo;t as powerful, but they can still help us a lot to write better error handling code that works across the Foundation framework, and in the rest of the APIs.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","error handling"]},{"id":"bf7aa3d6f537cab2842e78eb0f02740b","title":"Please Help, Apple Is Threatening To Terminate My Apple Developer Account With No Clear Reason.","link":"/posts/please-help-apple-threatening-terminate-apple-developer-account/","content":"UPDATE\nJune 18, 2020 at 10:24 PM EST: I have made contact with a human at Apple after they reached to me via Resolution Center. We are working on solving the issues, and while I have not been told \u0026ldquo;yes, your account will not be terminated\u0026rdquo;, I believe in good faith we will work something out. Yes, the issue was my fault after all, but they are being very understanding and are letting me redeem myself by uploading a new binary. A proper update on this issue will come at a later date.\nSECOND AND FINAL UPDATE\nJune 19, 11:47 PM EST:\nAfter talking to Bill from Apple, I managed to avoid getting terminated.\nThe issue was indeed my fault. Turns out that at some point after the first public TestFlight build, I built some internal features to help me test the app easier. These features were not meant to reach any public builds, but they slipped (guess who didn\u0026rsquo;t know about #available a few years ago). One of these internal test tools was the ability to import data so I could test known servers that worked with the app. These testing features were found by the App Review team post-approval (many years after approval, in fact), and they decided to remove the app and flag me for termination because it looked like I was shadily deploying un-reviewed features to my users to bypass the App Store. Couple that with the fact the App had been on TestFlight for three years, and it really looked like I was bypassing the App Store breaking the rules.\nI was reached on the Resolution Center of my app after this article blew up and I was given a phone number I could call. I do not know if my article triggered a human to contact me, or if they were going to do it eventually, but I was told they read this. On the first call, I was explained what the problem was. After a few calls I was told that I was being given a second chance by the App Review team, and I have been working to fix the issue since.\nIt was hard to reach a human at Apple when my account was flagged, but after I finally managed to, everything progressed smoothly.\nThere are a few lessons to learn from this:\nIf you build internal functionality on your app, make sure it is completely removed from public builds. Apple can and will re-review apps years after they have been approved to check for compliance. This means both App Store and TestFlight apps. This is a good thing for users, as it helps fight really shady apps that start doing something else, probably with a server flag. We have known that Apple silently reviews App Store apps again years or months after they are approved - now we know this applies to TestFlight builds as well. Reaching humans is hard, but extremely rewarding when you manage to do it. To be clear, you can reach a human most of the time when dealing with App Review. They have forms and easy methods to do just that. But when your issue leaves the realm of App Review (in my case, I\u0026rsquo;m guessing my issue was handled by some sort of Fraud department), it\u0026rsquo;s hard. This is still speculation, but my guess that the app was on TestFlight for too long wasn\u0026rsquo;t an issue on its own. It\u0026rsquo;s the fact that a internal features were deployed AND it looked like I had been deploying these features secretely for years that got me flagged. I lean towards saying that having an app on TestFlight for years is not an issue on its own, but I will probably refrain from doing that for now on. At the very least, I will remove builds and force them to go through manual review every couple of months. Especially after WWDC, because I will be busy doing changes that work well for iOS 14 and I\u0026rsquo;m sure the app will be mutating a lot. :-) In this article, I said that I was ready to accept any punishment done to me if it indeed turned out it was my fault. Turns out I was entirely to blame, but Apple (specifically Bill), managed to prevent my termination from the program. I cannot thank Bill enough for his kindness and understanding, despite the fact that the issue was, in fact, quite big. It\u0026rsquo;s always great when you can reach a human, and it shouldn\u0026rsquo;t be complicated to do when you really need to reach out.\nORIGINAL POST\nHello guys.\nI have been holding off to write this in case I was able to solve this problem on my own (which I tried to do very patiently), but the fact that I cannot talk to a human at Apple has prompted me to write this. Today I received another generic response from them (probably from a bot), so I\u0026rsquo;m prompted to write this to try to reach out to someone who can help.\nYesterday at around 1PM EST, Apple opened and immediately closed an issue on an app I have on TestFlight. This is important, the app is on TestFlight, and not even the App Store.\nI will tell my version of the story, and I sincerely wish Apple would do the same, but they are not providing me with any information that can help me understand what I did wrong.\nThe app in question is Mignori. Mignori is a client for Image Board websites (we informally call \u0026ldquo;Boorus\u0026rdquo;). These image boards are popular in the anime community, although there can be image boards for anything you can think of. This app let you browse those websites implementing their APIs so you have access to all their features.\nThe app does not ship with any servers by default. The user has to add them all manually. Just like a web browser.\nWhile the first version of this app was on the App Store from 2014 to 2016, I removed it in that last year because the app stopped working properly with most Boorus, and it was broken for most users. Since then, I started developing a new version called \u0026ldquo;Mignori 3\u0026rdquo;, which has never hit the App Store. It has been on TestFlight for a while.\nApple cites \u0026ldquo;Fraud\u0026rdquo; as the termination reason for my app and therefore my account, and I\u0026rsquo;m trying to wrap my head around what they think is fraudulent in my app. Especifically, they cite a paragraph of the developer program.\n\u0026ldquo;You will not, directly or indirectly, commit any act intended to interfere with the Apple Software or Services, the intent of this Agreement, or Apple‚Äôs business practices including, but not limited to, taking actions that may hinder the performance or intended use of the App Store, Custom App Distribution, or the Program (e.g., submitting fraudulent reviews of Your own Application or any third party application, choosing a name for Your Application that is substantially similar to the name of a third party application in order to create consumer confusion, or squatting on application names to prevent legitimate third party use).\u0026rdquo;\nMy app is image browser app. The business model is clear from the get go. The app was intended to be free, and it was supposed to offer a Pro Version to unlock all the versions, as well as Theme Packs to let users customize the App and me getting a little bit of revenue without having to implement subscriptions. All the network requests the app ever made where the HTTP requests to the image board browsers. Because this app is essentially a web browser.\nI am not hindering or interacting with Apple\u0026rsquo;s servers in any way beyond implementing the required APIs for implementing my IAPs. Some of my IAPs use Apple\u0026rsquo;s Hosted Content API, but they aren\u0026rsquo;t that big. They are a few kilobytes in size and they are text files that contain information about the themes. In other words, they are theme files.\nApple cites \u0026ldquo;being involved with fraudulent reviews\u0026rdquo; to remove this app. But there\u0026rsquo;s two problems with this. First, the app is on TESTFLIGHT. I cannot receive ratings even if I want to. Second, I do not know of any app that does what mine is supposed to do, and even if I knew one, I am not a lame human being who would try to ruin their reputation with fake negative reviews, especially considering mine is not on the App Store yet and has been under development for four years.\nThe app name is \u0026ldquo;Mignori\u0026rdquo; is pretty unique as far as I know. It is not common enough to have a .com domain, which is why I was able to register it. If I see a problem here, is that \u0026ldquo;Mignori 3\u0026rdquo; is a different app than \u0026ldquo;Mignori\u0026rdquo;, both having two profiles on my developer account and two different bundle IDs. I did this, because when I killed the first version of Mignori, I was thinking some users still had some use for it, and the new version was written from scratch and it is not compatible with the old format at all. Mignori 3 was published on TestFlight in 2017 and Apple approved it. While I haven\u0026rsquo;t been able to reach a production state yet, I have been working with my testers to patch all the bugs, although slowly, because this app is a hobby, and real life happened.\nI am not \u0026ldquo;squatting\u0026rdquo; the name Mignori because it is not a common name. It is a name I genuinely use. I own the .com domain name for it. And even IF Apple wanted to free this name, I\u0026rsquo;m sure there are thousands of ways they could do so, without having to threaten to lock down my developer account.\nI know other reasons are misleading metadata (which I do not do), \u0026ldquo;bait-and-switch\u0026rdquo; schemes (which I would not do, and I CANNOT do because the app is not on the App Store) can also cause this. But I have evaluated the rules over and over again and looked at my TestFlight app and I cannot find a single reason it is considered a \u0026ldquo;fraud\u0026rdquo;.\nThe big problem is that when Apple tells you that the reasons \u0026ldquo;are not limited\u0026rdquo; the ones they listed, it could be anything. They could call my face ugly and remove me from the Developer Program under that reason and tell me it was because of \u0026ldquo;fraud\u0026rdquo;.\nMy intention is not to \u0026ldquo;Run to the press\u0026rdquo;, like they call it, but when you are stuck in a loop of attempted appeals, you cannot get ahold of a human, and all you get are automatic bot responses, what are your options? I am not a popular developer in the iOS community, so I am not sure how far this post will reach (hopefully far enough, please).\nThe saddest truth of the matter is that I am not the only guy who has had to dealt with this. Even Gui Rambo has had a problem similar to this, and we all know that Rambo has no reason to do anything illegal with the Apple Developer Program. If you search around, you will find lots of people with the same problem. I give these people the benefit of doubt that, like me, they did not break the Apple Developer Program rules in a way that would prompt termination of their accounts. None of them could ever reach a human at Apple. The only people I know managed to reach Apple where the really popular developers who were in the eye of the storm, and Apple ended up reaching out to them.\nRight now, this is the worst thing that happened to me, and right before WWDC as well. WWDC is my favorite event of the year. I look forward to it every single year and even ask for days off at work to watch the Keynote and Platform State of the Union at home. This uncalled for event has completely killed my hype for WWDC, but I will keep my hopes up that this can be rectified before WWDC actually arrives.\nWhat I Think I Did Wrong The only thing I can think of I did wrong is I had the app on TestFlight for far too long with a public invitation link. Ever since the app went live on TestFlight, I have had a public link on the Mignori website where people could register to use the beta of the app. Back in 2017, the development of the app was very active and moving smoothly, but in early 2018 real life happened, and I couldn\u0026rsquo;t work on the app as actively as I would have liked. The app has been sitting on TestFlight for 3 years now, it has around 200 beta users, and if anything, the only reason I can think of, is that Apple thinks I decided to unofficially deploy the app with TestFlight without going through the formal review. I wish I could talk to a human so they could comfirm this is the problem, but all I get are bots, bots, and more bots. If that is the reason why Apple wants to terminate my entire developer account, then perhaps removing the app from TestFlight would have sufficed? I do not know. In a sea of automated actions it is impossible to find anything that make sense.\nWhere I Stand Now Apple has taken no action on my other apps that never hit the App Store. I have a total of 8 apps on my account. Two were published a long time ago (2011, 2012) and I removed them because they don\u0026rsquo;t perform well anymore. The others are apps I worked on but never had the drive to finish - I will be happy to remove these if Apple is thinking that I got them to squat their names. Out all the apps I have there, one is on TestFlight (Mignori), and the other has been on the App Store since 2017 (Next Anime Episode). My App Store app is still downloadable. People can still search for it and download it. And people can still review it. In the last few days, Next Anime Episode has started to receive an unusual number of 1-Star reviews and all in a quick succession, so I am starting to think that someone is targetting me for god knows what reason. I can respond to reviews, and I responded to one today, but Apple has not approved it, and I do not know if they will.\nJust yesterday I uploaded a new version of Next Anime Episode with a small bugfix to see if I could still do everything on the Apple Developer Program, and I can. The upload went fine, although it has been waiting for review for almost 24 hours now. I do not know if they haven\u0026rsquo;t reviewed it because they working slower at reviews with WWDC around the corner or because they don\u0026rsquo;t take a look at Flagged apps.\nOne thing I find particularly weird is that I know Apple puts accounts \u0026ldquo;under investigation\u0026rdquo; for reasons unknown to the developers before they terminate them. Apple never put my account under investigation before telling me they are going to terminate my account from the program. This came out completely out of the blue. In fact, on June 8 of this year, a little bit over a week before Apple acted against Mignori, I submitted an update for Next Anime Episode and the review went by fast and smoothly. I know Apple doesn\u0026rsquo;t review apps of accounts under investigation, so I know I wasn\u0026rsquo;t being investigated.\nI know of developers who were instantly terminated and all their apps removed. Luckily this has not happened to me. I can still view my payments (I am 8 dolars away from getting my last $100 payment, and I hope I get them before my account is terminated because that way I can recoup the cost of the developer program I JUST RENEWED last week), and I can still do everything. I was even able to accept the latest developer agreement for paid apps.\nI know people don\u0026rsquo;t care about a small developer\u0026rsquo;s feelings, especially Apple, but that won\u0026rsquo;t stop me from saying I\u0026rsquo;m feeling incredibly bummed about this. I have been part of the Developer Program since 2011. I have been active on the iOS community since then. I started to blog about iOS in 2011, and I revised my blog last year to re-launch it and blog more often than ever. I have managed to write one article per week because I love the iOS community. Part of the reason I blog is because I can learn while I blog and that helps me become a more competent developer. I now I am not a popular developer, but I still want to say that I pour a lot of effort into what I do because I genuinely like(d) all this, and the iOS developer community is one of my favorite communities.\nI am bummed, because I have been making a living out of iOS development for 9 years and everything is suddenly coming to an end without me being able to talk to a human at Apple. All the skills I have built over the course of almost a decade are obsolete now, because I do not imagine myself working for other people as an iOS dev without having my own hobby iOS apps on the App Store. It feels like all the blogging I have been doing has been a waste because I cannot participate in the knowledge I myself write, and it\u0026rsquo;s pointless to engage in the knowledge of others if I cannot try what they write.\nIf by any chance this gets far enough for someone at Apple to see it\u0026hellip; Please, reach out. Get a human to send me an e-mail or make a call. I won\u0026rsquo;t even ask you to avoid terminating my developer account if you can tell me what, exactly, I did wrong. Mignori was never on the App Store. It has been on TestFlight all this time. All my other apps are fine. All I want is to talk to a human to understand where things went south.\n","tags":null},{"id":"0a454ff05b63e8fddb6b18cffc7abea6","title":"Document Scanning and Text Recognition With Vision and VisionKit on iOS","link":"/posts/scanning-and-text-recognition-with-visionkit/","content":"It is amazing what we can do with smartphones these days. Document scanning and text recognition are nothing new. But being able to have such a functionality in our pockets is pretty neat. These days we can create apps that have such features very quickly thanks to the push Apple has been doing to promote Machine Learning and Artificial Intelligence on their devices.\nStarting on iOS 11, we can natively scan documents with a system framework called VisionKit, and we can perform operations on images using a framework called Vision. It wasn\u0026rsquo;t until iOS 13 that we finally had the ability to recognize text on images ourselves using the Vision framework, without leveraging third party libraries. In this article we will explore how we can use the VisionKit framework to scan documents and the Vision framework to detect text as two separate tasks, so you can see how easy these two tasks are and you can learn to put them together.\nIntroducing the VisionKit Framework Apple introduced the Vision framework on iOS 11 and it offers very quick APIs to do document scanning. The framework comes with a view controller that you can use to do the scanning, so you don\u0026rsquo;t have to worry about wiring your own UI for this. The framework comes with a delegate so you can be notified as scanning events take place.\nScanning Documents with VNDocumentCameraViewController VNDocumentCameraViewController is the object we use to perform scanning. Setting it up is pretty straightforward. This object comes from the VisionKit framework, so make sure you import that. You will also need to conform to VNDocumentCameraViewControllerDelegate in order to receive events.\nimport VisionKit class ViewController: UIViewController, VNDocumentCameraViewControllerDelegate { var documentCamera: VNDocumentCameraViewController? //... func documentCameraViewControllerDidCancel(_ controller: VNDocumentCameraViewController) { documentCamera?.dismiss(animated: true, completion: nil) } func documentCameraViewController(_ controller: VNDocumentCameraViewController, didFailWithError error: Error) { print(\u0026#34;Document Scanner did fail with Error\u0026#34;) } func documentCameraViewController(_ controller: VNDocumentCameraViewController, didFinishWith scan: VNDocumentCameraScan) { print(\u0026#34;Did Finish With Scan.\u0026#34;) } //... } When you actually want to show a document scanner, just instantiate a new VNDocumentCameraViewController, assign your delegate, and present it:\nfunc showDocumentScanner() { guard VNDocumentCameraViewController.isSupported else { print(\u0026#34;Document scanning not supported\u0026#34;); return } documentCamera = VNDocumentCameraViewController() documentCamera?.delegate = self present(documentCamera!, animated: true, completion: nil) } Don\u0026rsquo;t forget to set NSCameraUsageDescription in your plist, otherwise your app will crash when you try to present it.\nWe will implement the logic to get the images in a sec, but for now, run it and try scanning something with it:\nThe scanner automatically grabs what it thinks is a document and scans it, and it automatically starts creating new pages based as more content is scanned. Pretty neat!\nNow we care about receiving the images, and for that, we will write some code in the documentCameraViewController(controller:didFinishWith:) method. This method gives us a VNDocumentCameraScan we can use and it has all the information about the scanning process, including the number of pages, and the images themselves. This object has two mere properties: title, pageCount; and a single method imageOfPage(at:) -\u0026gt; UIImage\nfunc documentCameraViewController(_ controller: VNDocumentCameraViewController, didFinishWith scan: VNDocumentCameraScan) { documentCamera?.dismiss(animated: true, completion: nil) documentCamera = nil print(\u0026#34;Finished scanning document \\\u0026#34;\\(String(describing: title))\\\u0026#34;\u0026#34;) print(\u0026#34;Found \\(scan.pageCount)\u0026#34;) let firstImage = scan.imageOfPage(at: 0) // .. Do something with the first image } And that\u0026rsquo;s it! You now know how to quickly scan documents and get results back.\nThe Vision Framework The Vision Framework contains APIs to let us analize images.\nDetecting Text in Images Using the Vision Framework. VNRecognizeTextRequest To use this framework, you create requests and handlers. A request performs the operation you want, and then you hand the request to a handler to execute your request.\nWe will start by creating our recognition request:\nfunc detectText(in image: UIImage) { guard let image = image.cgImage else { print(\u0026#34;Invalid image\u0026#34;) return } let request = VNRecognizeTextRequest { (request, error) in if let error = error { print(\u0026#34;Error detecting text: \\(error)\u0026#34;) } else { self.handleDetectionResults(results: request.results) } } request.recognitionLanguages = [\u0026#34;en_US\u0026#34;] request.recognitionLevel = .accurate performDetection(request: request, image: image) } First we need to convert out UIImage to CGImage, as we will need it later. Then, when we create our VNRecognizeTextRequest, the initializer takes a completion handler that gets called when the operation is completed. You can set a couple of properties in the recognition object to help it be more accurate, like the recognition language. You can set the recognition speed which allows you to specify if you want to be accurate or fast.\nTo actually execute the task, we will implement performDetection(request:image) as so:\nfunc performDetection(request: VNRecognizeTextRequest, image: CGImage) { let requests = [request] let handler = VNImageRequestHandler(cgImage: image, orientation: .up, options: [:]) DispatchQueue.global(qos: .userInitiated).async { do { try handler.perform(requests) } catch let error { print(\u0026#34;Error: \\(error)\u0026#34;) } } } The VNImageRequestHandler will actually execute our VNRecognizeRequest. You want to do this in another thread, as it can be a lengthy operation. When we create our object, we need to pass it the image, and the image orientation. It looks like the recognizer is not smart enough to recognize the orientation of images, so you need to tell it what position your text is in, probably providing a way in your UI to do just that.\nWhen our request finishes, we will call handleDetectionResults(results:), which is implemented as:\nfunc handleDetectionResults(results: [Any]?) { guard let results = results, results.count \u0026gt; 0 else { print(\u0026#34;No text found\u0026#34;) return } for result in results { if let observation = result as? VNRecognizedTextObservation { for text in observation.topCandidates(1) { print(text.string) print(text.confidence) print(observation.boundingBox) print(\u0026#34;\\n\u0026#34;) } } } } Everything this method does is to print the strings and how much confidence it has in them. The confidence is how accurate the recognizer thinks it is.\nA candidate is a piece of string of text the recognizer thinks it found. It\u0026rsquo;s probably not practical to get many candidates per iteration, but you should evaluate according to your needs. If the text is clear enough, you can get by with the first or first two candidates. The bounding box is the coordinates in the image where it found the strings.\nAnd that\u0026rsquo;s it! Using these APIs is actually very easy thanks to Apple\u0026rsquo;s push on machine learning. The results are very accurate most of the time, despite it using on-device machine learning instead of a whole cloud like Google backing it up. The API is trustworthy, and very powerful.\nConclusion We can create scanning and OCR apps very easily with the use of these APIs on iOS and iPadOS. Apple provides many and high-level APIs for these tasks that are easy to use and are also very fast and accurate.\n","tags":["swift","programming","apple","ios","ipados","visionkit","ocr","scanning","vision framework"]},{"id":"4d1c6ed659bbd25a8095e82027b1740b","title":"Using the iOS Keychain with Biometrics","link":"/posts/ios-keychain-touch-id-face-id/","content":"If you have been using the keychain on your iOS apps you may want to start using Face ID/Touch ID to let your user access your app and their data. This is a common use case but it\u0026rsquo;s very easy to do incorrectly.\nApple introduced Touch ID all the way back in 2013, and ever since then, every iOS device has come with some sort of biometric authentication method, be it Touch ID or Face ID. This has allowed developers to implement convenient unlocking into their apps to access sensitive data without having to ask for the passcode. If your app \u0026ldquo;locks\u0026rdquo; access in any way your users are probably expecting to \u0026ldquo;unlock\u0026rdquo; with their finger or Face ID, so it is your responsibility to implement in a way that is secure and can\u0026rsquo;t be vulnered.\nThe Wrong Way If you have implemented Touch ID or Face ID in your app before, you have probably seen articles or tutorials that let you to grab the boolean of a biometric authentication operation and work from there. Something like this:\nfunc requestBiometricUnlock() { let context = LAContext() var error: NSError? = nil let canEvaluate = context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: \u0026amp;error) if canEvaluate { if context.biometryType != .none { print(\u0026#34;We got a biometric\u0026#34;) context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: \u0026#34;To access your data\u0026#34;) { (success, error) in if success { print(\u0026#34;Authenticated successfully!\u0026#34;) } } } } } In the above code, first we check if we have any available biometrics. If we do, we will try authenticating with the existing biometric. Once the function calls our closure, it will contain a boolean indicating if the authentication succeeded or if it failed. If it was successful, you can access your data.\nThis is actually a very na√Øve approach because in theory, a jailbreak tweak could hook into your app, trick it to believe a successful biometric scan was performed, and steal any information behind that simple if true call.\nThis code probably has some uses and it should be used strictly for convenience and not for actual security. The right way to lock sensitive data in the keychain while allowing for biometric access is to create your keychain item with a specific access policy, also known as an access control.\nThere is a nice article here about how easy it is to bypass the Touch ID/Face ID prompt, using the Evernote and Dropbox iOS apps as examples.\nKeychain and Access Control When you create an access control, you specify two conditions under which a keychain item should be available:\nThe level of accessibility for the item: Whether you want the item to be accessible after the user unlocks the device, every time they authenticate, or other. The authentication level: This flag lets us specify if the item can be accessed any time, as in, only when the user is present, and more. This condition lets us set the biometric conditions to allow our keychain items to be accessed. These APIs are governed by the Security framework just like the keychain, so make sure you import it before moving on.\nCreating An Access Control. To create an access control, you use the SecAccessControlCreateWithFlags function. This function takes four parameters, of which we mostly care about the second and third one.\nlet accessControl = SecAccessControlCreateWithFlags( nil, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, .userPresence, nil) The first parameter is an allocator. When we use nil, we use the default one. I do not know when it would be appropriate to use a different allocator.\nThe second parameter allows us to specify the accessibility level. Using the kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly constraints the item into only being accessed when the device has a passcode set (the WhenPasscodeSet part of the constant name) - if the device has no passcode, trying to add a new keychain item is not going to do anything -, and for this device only (the ThisDeviceOnly part of the constant), meaning the item will not be shared via iCloud Keychain or even from a backup. It is exclusive to the device that created it.\nThe SecAccessControlCreateFlags.userPresence flag lets us specify that we want the user to be there when the keychain is accessed. To do this, under this specific flag, the system will prompt for a biometric authentication, falling back to the device\u0026rsquo;s passcode when necessary. You can restrict the item to use only biometric with .biometricCurrentSet or only the device passcode with .devicePasscode. You have a lot of flexibility, but .userPresence is the most used one, as it defaults to biometrics and fallbacks to passcode automatically.\nAdding Items With An Access Control. To add a new keychain item with your new access control, you don\u0026rsquo;t have to do much different like when you add an item with SecItemAdd. The only difference is your query will have a kSecAttrAccessControl key with your access control.\nlet accessControl = SecAccessControlCreateWithFlags( nil, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly, .userPresence, nil)! let query = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \u0026#34;andyibanez\u0026#34;, kSecValueData: \u0026#34;Pullip2020\u0026#34;.data(using: .utf8)!, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecAttrAccessControl: accessControl, kSecReturnData: true ] as CFDictionary var result: AnyObject? let status = SecItemAdd(query, \u0026amp;result) As you can see, our dictionary is not too different. One key to set the access control and that is all we need. From now on, whenever we need this item, we will need to authenticate the user, either with biometrics or passcode (because we used the .userPresent setting).\nRetrieving Items with Authentication To retrieve items, once again you just have to write a common query. But you do not have to specify the access control this time.\nlet searchQuery = [ kSecClass: kSecClassInternetPassword, kSecAttrAccount: \u0026#34;andyibanez.com\u0026#34;, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecMatchLimit: kSecMatchLimitOne, kSecReturnData: true, kSecReturnAttributes: true, kSecUseOperationPrompt: \u0026#34;Access your data\u0026#34; ] as CFDictionary var item: AnyObject? let status = SecItemCopyMatching(searchQuery, \u0026amp;item) The system is smart enough to prompt for the biometrics when it finds an item that was created with a given access control. The kSecUseOperationPrompt key allows us to specify a user-visible string, and it\u0026rsquo;s optional.\nYou may be wondering, how does this work when your query matches multiple items, some of which may not have an access control associated to them? If you want to perform a wide search, the query will return all the items that match, but it will ask you to provide authentication for every protected item. You can perform wide searches skipping the ones with a biometric access control by providing the kSecUseAuthenticationUI key with the kSecUseAuthenticationUISkip value in your search query.\nNote: To test this, you will need to run your code in a real device. Because you can\u0026rsquo;t set a device passcode in the simulator, this code runs and finishes immediately after you run it, even if you enroll Touch ID/Face ID in the simulator. This gives you the impression it is not working properly, so keep that in mind if you are using this feature.\nConclusion Using biometrics with the keychain is very easy, so you should definitely use it if you are planning to hide credentials behind Touch ID/Face ID. I\u0026rsquo;ve seen a lot of code who don\u0026rsquo;t do this, and it is dangerous to do. There\u0026rsquo;s very little use to use the LocalAuthentication framework directly when dealing with credentials, so use the keychain this way when you need to.\n","tags":["swift","programming","apple","ios","macos","ipados","keychain"]},{"id":"8cae0a8470b3d6b7c3c42cc065302fcc","title":"Using the iOS Keychain in Swift","link":"/posts/using-ios-keychain-swift/","content":"This article is an entirely rewritten version of an old tutorial I wrote years ago titled \u0026ldquo;Using the iOS Keychain\u0026rdquo;. Originally written in Objective-C, the old version has been archived but it is accessible here.\nThe Keychain is the place where you would store sensitive data. As secure as iOS currently is, the keychain is the right place to store passwords, authentication tokens, and other sensitive data. You should not store this kind of data in UserDefaults, even if iOS has made it harder to access that data for normal users in the latest versions.\nIn this article we will explore how to use the iOS keychain (which is also applicable to iPadOS, watchOS, and even tvOS) using Swift. The APIs are similar to the ones used in macOS, but the way both systems work with their keychain is different enough to consider them separate. The keychain APIs are very old and as such we will be written some \u0026ldquo;ugly\u0026rdquo; Swift code to get everything to work, although these days it\u0026rsquo;s much easier to do the bridging to Core Foundation and back. With that said, using the keychain isn\u0026rsquo;t too hard, and you should use it if you find yourself needing to store sensitive data.\nBasic Keychain Concepts Before we write some code, we need to get some terminology down. Keep these concepts in mind as you read through this article:\nKeychain: The keychain is a secure and encrypted storage place for sensitive data. You can think of it is a database of sensitive information. Keychain Item: This is a registry in the keychain. Item Class: You can think of a class as a template of information you want to store. The keychain offers classes for different common credentials, such as username/password pairs, a certificate, a generic password, and more. Please note that the keychain is tied to the developer provisioning profile used to sign the app and its bundle ID. If either of these change, the data becomes inaccessible.\nCommon Keychain Operations With that basic terminology out of the way, we can start doing basic operations: Adding new items to the keychain, searching for specific items, updating items, and deleting items.\nFirst things first, the keychain services are part of the Security framework, so don\u0026rsquo;t forget to add that import:\n# import Security Adding Items to the Keychain Adding Items To add items to the keychain, you use the SecItemAdd function. Again, these APIs are very old, so you may be surprised by what they take as arguments and what they return. The first parameter is a dictionary known as a query. The query specifies the data the keychain item will hold along with parameters we can use to find it - more on that later. Being an old (and low level) API, this argument is actually a CFDictionary.\nAt the very least, the keychain item should have:\nThe item class, specified with the kSecClass key. The actual data you want to hold, whether it is a plain password, or anything else. This should be stored as Data (or if you prefer, CFData). The key is kSecValueData. You can specify optional attributes and optional return types as well. We will see these in a bit.\nThe second parameter to this function is a UnsafeMutablePointer\u0026lt;CFTypeRef\u0026gt;? which may contain the data created. This is an unsafe generic pointer. This is low level stuff, but I promise it will make sense later.\nThis parameter makes more sense when are retrieving items from the keychain, but if you wanted to return the item you just created to check its data or do anything else with it, you can use this parameter to return it after creating it.\nThe function itself returns an OSStatus. OSStatus tells us the status of the operation we just performed, and you will see it in all the keychain APIs. If it returns 0 (or errSecSuccess), the operation finished successfully and our operation finished without an issue. In the case of SecItemAdd, that will mean our new item was added to the keychain.\nTo create a keychain item, this is the minimum code you would need:\nlet keychainItemQuery = [ kSecValueData: \u0026#34;Pullip2020\u0026#34;.data(using: .utf8)!, kSecClass: kSecClassGenericPassword ] as CFDictionary let status = SecItemAdd(keychainItemQuery, nil) print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) This will work fine, and it will print 0 for the status which is what we would expect (Yes, OSStatus is not bridged to Swift yet, so you won\u0026rsquo;t get the actual enum case name errSecSuccess). The problem with this code is that searching for this item later will be a bit harder. We will explore why when we explore how to retrieve items, but for now, try to add more context to your new items. We can do this by adding optional attributes. All the attributes we can use are also dictionary keys that have the kSecAttr prefix.\nDifferent classes have different attributes that make the keys unique. When using kSecClassInternetPassword, we can specify a username and the domain name of the website. Note that we are passing nil to the second argument, because we aren\u0026rsquo;t interested in returning the newly created item just yet.\nlet keychainItem = [ kSecValueData: \u0026#34;Pullip2020\u0026#34;.data(using: .utf8)!, kSecAttrAccount: \u0026#34;andyibanez\u0026#34;, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecClass: kSecClassInternetPassword ] as CFDictionary let status = SecItemAdd(keychainItem, nil) print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) Retrieving Newly-Added Records. SecItemAdd has a second argument we can use to return the newly created item if we want to use it instantly. This parameter is called result, and you will probably specify nil here most of the time, but it\u0026rsquo;s good to know that this function can return data after adding items, in case you ever need it.\nWhen we create a new item, we can specify four different return types that will be filled in the second argument. Remember this parameter is of type UnsafeMutablePointer\u0026lt;CFTypeRef\u0026gt;?, so it can result a pointer that can point to pretty much anything. This is a big mess, so we will explain the different return types before we move on. All the return types are specified with a key in the query that has the prefix kSecReturn.\nkSecReturnRef: When this is set to true, result will point to either a SecKeychainItem, SecKey, SecCertificate, SecIdentity, or CFData, depending on the kSecClass specified in the query. I couldn\u0026rsquo;t get this to return anything on iOS. kSecReturnPersistentRef: When this is set to true, result will contain CFData which you can use to persist on disk or pass to different processes. kSecReturnData: When this is set to true, this will return the actual sensitive data stored in the keychain item. The sensitive data will vary on the item class, but if your query contains a kSecValueData key, it will return that. kSecReturnAttributes: This will return all the attributes used to create the item in a CFDictionary. So\u0026hellip; Yes, it is a mess. The API is very old, and result can be pretty much anything. This API is not really friendly with Swift\u0026rsquo;s type safety, so we have to do a lot of casting when working with keychain services.\nCFTypeRef is bridged to AnyObject, so you can forget about CFTypeRef and use AnyObject everywhere instead.\nHere is an example of a query that returns the attributes, using kSecReturnAttributes:\nlet keychainItem = [ kSecValueData: \u0026#34;Pullip2020\u0026#34;.data(using: .utf8)!, kSecAttrAccount: \u0026#34;andyibanez\u0026#34;, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecClass: kSecClassInternetPassword, kSecReturnAttributes: true ] as CFDictionary var ref: AnyObject? let status = SecItemAdd(keychainItem, \u0026amp;ref) let result = ref as! NSDictionary print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) print(\u0026#34;Returned attributes:\u0026#34;) result.forEach { key, value in print(\u0026#34;\\(key): \\(value)\u0026#34;) } This will print:\nOperation finished with status: 0 Returned attributes: acct: andyibanez atyp: sha1: {length = 20, bytes = 0x589a101265fbb5cd7b596657d2109c13450533a1} path: sdmn: pdmn: ak mdat: 2020-05-24 19:33:51 +0000 sync: 0 cdat: 2020-05-24 19:33:51 +0000 ptcl: 0 srvr: pullipstyle.com agrp: 7X7FABXK4C.com.andyibanez.keychain port: 0 You will never use these keys directly. Always use the proper kSecAttr key to get your data:\nprint(\u0026#34;Website: \\(result[kSecAttrServer] ?? \u0026#34;\u0026#34;)\u0026#34;) // Website: pullipstyle.com You may have noticed the actual password is missing. To get the password, we need to specify the kSecReturnData key instead. kSecReturnData returns a CFData, and kSecReturnAttributes returns a dictionary, so they are incompatible types to begin with.\nTo retrieve the password itself:\nlet keychainItem = [ kSecValueData: \u0026#34;Pullip2020\u0026#34;.data(using: .utf8)!, kSecAttrAccount: \u0026#34;andyibanez\u0026#34;, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecClass: kSecClassInternetPassword, kSecReturnData: true ] as CFDictionary var ref: AnyObject? let status = SecItemAdd(keychainItem, \u0026amp;ref) let result = ref as! Data print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) let password = String(data: result, encoding: .utf8)! print(\u0026#34;Password: \\(password)\u0026#34;) Password: Pullip2020 \u0026hellip; But, you can actually return both at the same time! Even though using kSecReturnData and kSecReturnAttributes return different types, if you specify both keys at the same time and set them to true, SecItemAdd will return a CFDictionary that contains the attributes and the password. So, if you are aiming for consistency, and you always want result to have the same data type, if you specify more than one return key, you will always get a dictionary back.\nlet keychainItem = [ kSecValueData: \u0026#34;Pullip2020\u0026#34;.data(using: .utf8)!, kSecAttrAccount: \u0026#34;andyibanez\u0026#34;, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecClass: kSecClassInternetPassword, kSecReturnData: true, kSecReturnAttributes: true ] as CFDictionary var ref: AnyObject? let status = SecItemAdd(keychainItem, \u0026amp;ref) let result = ref as! NSDictionary print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) print(\u0026#34;Username: \\(result[kSecAttrAccount] ?? \u0026#34;\u0026#34;)\u0026#34;) let passwordData = result[kSecValueData] as! Data let passwordString = String(data: passwordData, encoding: .utf8) print(\u0026#34;Password: \\(passwordString ?? \u0026#34;\u0026#34;)\u0026#34;) Operation finished with status: 0 Username: andyibanez Password: Pullip2020 Retrieving Items from the Keychain In this section we will explore how to write queries that retrieve data from the keychain. If you want to work along, I have written this small piece of code that will populate the keychain with different but similar entries:\nlet usernames = [\u0026#34;andyibanez\u0026#34;, \u0026#34;alice\u0026#34;, \u0026#34;eileen\u0026#34;, \u0026#34;blackberry\u0026#34;] usernames.forEach { username in let keychainItem = [ kSecValueData: \u0026#34;\\(username)-Pullip2020\u0026#34;.data(using: .utf8)!, kSecAttrAccount: username, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecClass: kSecClassInternetPassword, kSecReturnData: true, kSecReturnAttributes: true ] as CFDictionary var ref: AnyObject? let status = SecItemAdd(keychainItem, \u0026amp;ref) let result = ref as! NSDictionary print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) print(\u0026#34;Username: \\(result[kSecAttrAccount] ?? \u0026#34;\u0026#34;)\u0026#34;) let passwordData = result[kSecValueData] as! Data let passwordString = String(data: passwordData, encoding: .utf8) print(\u0026#34;Password: \\(passwordString ?? \u0026#34;\u0026#34;)\u0026#34;) } To query the keychain and retrieve the items, we use the SecItemCopyMatching function. The two parameters it takes are actually the same ones as SecItemAdd. The way these two functions is the same: You specify a query, and get something in return, including nil. it returns a OSStatus like SecItemAdd.\nWhile SecItemCopyMatching has an optional second parameter, you probably want to specify it most of the time, otherwise you will never get any data back when working with it.\nYou write your query the same way you did when creating items, but there\u0026rsquo;s a few things we need to keep in mind. First, the queries can be as specific or as generic as you want. Second, you can force the keychain to return one or more items at once.\nOnce again this API is messy, because the result can once again return more than one type. The conditions are the same as when returning data from SecItemAdd, but there is one more type SecItemCopyMatching can return. If you specify the key kSecMatchLimit and give it a value bigger than 1, you will get a CFArray of CFDictionary.\nLet\u0026rsquo;s see this in action. You know you have many items that have pullipstyle.com as their kSecAttrServer. Despite that, the following query will only return one:\nlet query = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecReturnAttributes: true, kSecReturnData: true ] as CFDictionary var result: AnyObject? let status = SecItemCopyMatching(query, \u0026amp;result) print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) let dic = result as! NSDictionary let username = dic[kSecAttrAccount] ?? \u0026#34;\u0026#34; let passwordData = dic[kSecValueData] as! Data let password = String(data: passwordData, encoding: .utf8)! print(\u0026#34;Username: \\(username)\u0026#34;) print(\u0026#34;Password: \\(password)\u0026#34;) If the query doesn\u0026rsquo;t find any items to return, result will be nil, so make sure you check for that.\nTo return more than one, we will specify kSecMatchLimit to a high enough number to return all the entries:\nlet query = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecReturnAttributes: true, kSecReturnData: true, kSecMatchLimit: 5 ] as CFDictionary var result: AnyObject? let status = SecItemCopyMatching(query, \u0026amp;result) print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) let array = result as! [NSDictionary] array.forEach { dic in let username = dic[kSecAttrAccount] ?? \u0026#34;\u0026#34; let passwordData = dic[kSecValueData] as! Data let password = String(data: passwordData, encoding: .utf8)! print(\u0026#34;Username: \\(username)\u0026#34;) print(\u0026#34;Password: \\(password)\u0026#34;) } Now the code has been adapted to work with an array instead of a dictionary, and we can now get all the entries that match the query.\nOne annoying detail of specifying kSecMatchLimit is that when your query produces zero results, result will again be nil instead of an empty array, so keep that in mind.\nThe more attribute keys you add, the more specific your queries become.\nlet query = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecAttrAccount: \u0026#34;andyibanez\u0026#34;, kSecReturnAttributes: true, kSecReturnData: true, kSecMatchLimit: 5 ] as CFDictionary var result: AnyObject? let status = SecItemCopyMatching(query, \u0026amp;result) print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) let array = result as! [NSDictionary] array.forEach { dic in let username = dic[kSecAttrAccount] ?? \u0026#34;\u0026#34; let passwordData = dic[kSecValueData] as! Data let password = String(data: passwordData, encoding: .utf8)! print(\u0026#34;Username: \\(username)\u0026#34;) print(\u0026#34;Password: \\(password)\u0026#34;) } The above code will match both the server (pullipstyle.com) and the username (andyibanez). This returns one item only in our specific case. Luckily since kSecMatchLimit is bigger than one, we still get an array and not a dictionary.\nOperation finished with status: 0 Username: andyibanez Password: andyibanez-Pullip2020 Updating Items To update items in the keychain, you use the SecItemUpdate function which also returns an OSStatus. Unlike SecItemAdd and SecItemCopyMatching, this function takes two CFDictionaries as its arguments. The first one is the query which you know and love. The second one contains the attributes you want to update and their new values.\nWhen specifying the query, you really need to be careful with how specific it is. If it isn\u0026rsquo;t specific enough, you may end up updating multiple items at once when you didn\u0026rsquo;t intend to.\nlet query = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, ] as CFDictionary let updateFields = [ kSecValueData: \u0026#34;newPassword\u0026#34;.data(using: .utf8)! ] as CFDictionary let status = SecItemUpdate(query, updateFields) print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) This will successfully modify the password of all kSecClasses whose kSecAttrServer is pullipstyle.com. It will update ALL the entries, because our query is too general and it matches many entries. Always try to make the query more specific to avoid these problems, especially if your keychain stores a lot of sensitive data.\nIn this case it would better to also specify the username (kSecAttrAccount) of the user we want to update:\nlet query = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \u0026#34;pullipstylew.com\u0026#34;, kSecAttrAccount: \u0026#34;andyibanez\u0026#34; ] as CFDictionary let updateFields = [ kSecValueData: \u0026#34;newPassword\u0026#34;.data(using: .utf8)! ] as CFDictionary let status = SecItemUpdate(query, updateFields) print(\u0026#34;Operation finished with status: \\(status)\u0026#34;) Deleting Items To delete an item, use the SecItemDelete function. This function only takes one parameter, the query, and returns an OSStatus.\nJust like when we are updating items, make sure your query is very specific so you only delete what you intend to delete. If you don\u0026rsquo;t you may delete extra entries accidentally.\nlet query = [ kSecClass: kSecClassInternetPassword, kSecAttrServer: \u0026#34;pullipstyle.com\u0026#34;, kSecAttrAccount: \u0026#34;andyibanez.com\u0026#34; ] as CFDictionary SecItemDelete(query) Conclusion Using the keychain to store sensitive data is the way to go. While it is a low-level API, the bridging to Swift has become more bearable in the last few years. You generally won\u0026rsquo;t worry too much about the bridging types, but it\u0026rsquo;s worth keeping into amount that the operations that return data back can return different data types.\nWe explored the basic usage of the keychain services APIs. We learend how to add, search, update, and delete entries, but the keychain can actually do quite a lot more than just that. Hopefully this article helped you get started to write more secure storage for sensitive data in your own apps.\n","tags":["swift","programming","apple","ios","macos","tvos","watchos","ipados","keychain"]},{"id":"265b11a4e32a039996f6cfee4f9fd574","title":"Writing Content Blockers for iOS","link":"/posts/content-blockers-in-ios/","content":"A few years ago, Apple introduced the Content Blocking APIs to Safari. Using these APIs, developers are able to write extensions that allow Safari to block content users do not want to see.\nMost commonly used for ads, content blockers are not really ad blockers. While they can, and commonly do, block ads, developers can write content blockers for all kind of content, including profanity, or other questionable content.\nContent Blocking VS Ad Blocking. Content Blockers are actually very limited in terms of what they can do. We cannot really achieve the level of functionality especialized extensions such as AdBlock Plus have to offer. Apple\u0026rsquo; implementation has two main focuses in mind:\nPrivacy Performance Privacy When we write content blockers, we are just writing a set of rules that we hand to Safari, and then Safari takes care of the blocking based on those rules. The app that handed the browser these rules will never get any callbacks or notifications back from Safari when it finds content it needs to block. It is set-and-forget.\nThis has some privacy implications. First, developers have no access whatsoever to anything Safari blocks. There are some browser extensions that allow you to see statistics about blocked websites on the desktop. Because we don\u0026rsquo;t have this level of control, we cannot really implement a feature similar to this.\nDevelopers cannot track the content users block, and this goes in hand with Apple\u0026rsquo;s policies on user data.\nPerformance Normal extensions that run in a browser have more access to resources, because they are packed with features. Because content blockers can\u0026rsquo;t really execute any code on their own, the performance is blazing fast. Safari\u0026rsquo;s parsing of these rules is incredibly efficient, and users are unlikely to see a negative impact on performance from this system.\nFun little fact: Content blockers were introduced in iOS 9, but only devices that had a 64-Bit processor could execute them. This means anything starting on the A7. The iPhone 5, while it did support iOS 9, it wasn\u0026rsquo;t able to run content blockers.\nWriting Content Blockers Here\u0026rsquo;s the fun bit about content blockers:\nYou don\u0026rsquo;t need any actual code at all\nYep. You read that right. At the most elemental level, content blockers are rules represented in a JSON file. Everything all the Content Blocker apps in the App Store do is create a JSON file that gets handed to Safari. You could theorically create an extensions that all it does is hand a static JSON file to Safari without writing a line of code.\nIf you create a new Content Blocking Extension on Xcode, the target has a blockList.json file. If you open it, it has content like this:\n[ { \u0026#34;action\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;block\u0026#34; }, \u0026#34;trigger\u0026#34;: { \u0026#34;url-filter\u0026#34;: \u0026#34;webkit.svg\u0026#34; } } ] The extension does provide a Swift file called ContentBlockerRequestHandler.swift. This file has the bare minimum to create and work with your extension. You don\u0026rsquo;t need to touch it at all, but know that you can use this file to customize your content blocker.\nThe blockList.json Back to the meaty parts of content blockers, the JSON file lets you add all the rules you want to use for blocking. And they are quite configurable, too. The JSON has two main keys:\naction: This is the action you want to perform on content that match the trigger. trigger: This is the condition that should be met in order to execute your action.\nTriggers The trigger can be a combination of:\nurl-filter: This matches the URL in the navigation bar of the browser. It can be a regular expression. url-filter-is-case-sensitive: You can decide if the URL matching should be case sensitive. By default, it is case insensitive. resource-type: This is an array that let\u0026rsquo;s you specify what kind of content should be blocked. Some valid values are script and image, but there\u0026rsquo;s others. load-type: Is another array, you can specify if you want to let the website load its own content (first-party) and/or content from other URLs (third-party) if-domain and unless-domain let you specify a website to include or exclude from the rule. Actions Actions describe how the blocking should take place.\nblock: Blocks a content entirely, rewriting the HTML. block-cookies: allows you to block the cookies set by certain requests. css-display-none: Modifies the CSS to hide the content. When using this type, you need to provide a CSS selector (with the selector JSON property) to target the CSS you want to modify. ignore-previous-rules: You can override previous rules if they match a certain criteria. Writing Simple Content Blockers. With that knowledge in hand, you could block Google and a bunch of their services writing a code like this:\n[ { \u0026#34;action\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;block\u0026#34; }, \u0026#34;trigger\u0026#34;: { \u0026#34;url-filter\u0026#34;: \u0026#34;.*google.*\u0026#34; } } ] This simple rule will prevent Google from loading at all, and any URL that has google in it won\u0026rsquo;t load, either.\nIf you wanted to block content that leads to Buzzfeed, you would write something like this:\n[ { \u0026#34;action\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;css-display-none\u0026#34;, \u0026#34;selector\u0026#34;: \u0026#34;a[href*=\u0026#39;buzzfeed\u0026#39;]\u0026#34; }, \u0026#34;trigger\u0026#34;: { \u0026#34;url-filter\u0026#34;: \u0026#34;.*\u0026#34; } } ] This will block all Buzzfeed content, across all URLS.\nConclusion Content blockers are an old but very powerful extension. They allow us to write performant rules for blocking content in Safari while respecting our user\u0026rsquo;s privacy.\n","tags":["swift","programming","apple","ios","macos"]},{"id":"dfc373a80b677e822738463e779c6b00","title":"Dependency Injection with Storyboards on Apple Platforms","link":"/posts/dependency-injection-storyboards/","content":"Every iOS developer has written a line of code like this one at least once:\nclass DollInfoViewController: UIViewController { var dollModel: Doll? override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. } } Or in the worst case, you may have seen code like this:\nvar dollModel: Doll! Then, when you want to create a view controller of that type you\u0026rsquo;d do:\n// First we need to check if we can actually instantiate the view controller. guard let dollInfoVc = storyboard?.instantiateViewController(withIdentifier: \u0026#34;DollInfo\u0026#34;) as? DollInfoViewController else { fatalError(\u0026#34;Unable to load view controller.\u0026#34;) } // Then we pass in the data we want to work with. dollInfoVc.dollModel = doll Code like this is very error prone. The worst part is that up untul iOS 13, it was pretty much necessary to pass data around from view controller to view controller. It\u0026rsquo;s not possible to do this in any different way in different iOS versions.\niOS 13 solves this very elegantly, by introducing Dependency Injection on Storyboards.\nA Quick Introduction to Dependency Injection Dependency injection is nothing more than to pass the data to the object that need them in order to work. Generally, you do this as part of an object\u0026rsquo;s initializer. When working with Storyboards, it was never possible to pass the data to the view controllers that need them directly. You always needed to specify a property for the data and then fill in that data later. This is why Storyboards are usually plagued with (forced unwrapped) optionals.\niOS 13 intoruces new APIs to make dependency injection possible, without having to fill the destination view controller with optionals.\nDependency injection with Storyboards. iOS 13 introduced the instantiateViewController(identifier:creator:) method to UIStoryboard. This method takes a identifier, which is the identifier of the storyboard itself which you know and love, and a creator block. The creator block includes your custom initialization code for your storyboard. The creator block gives you a NSCoder object which you need to complete the initialization of your view controller.\nTo use this method, we need to do a few things.\nFirst, you can finally create an initializer in your view controller that takes in the data you require. This initializer must take a NSCoder. Because of this, our dollInfo property also loses the question mark. Neat!\nclass DollInfoViewController: UIViewController { var dollModel: Doll override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. } init(coder: NSCoder, doll: Doll) { self.dollModel = doll super.init(coder: coder) } } Second, you should make the default init(coder:) initializer to fail. You need to do this, because this view controller now REQUIRES a dollModel, which is what you want.\ninit(coder: NSCoder) { fatalError(\u0026#34;You must provide a Doll object to this view controller\u0026#34;) } The rest of the work takes place in the view controller that want to call you.\nguard let vc = storyboard?.instantiateViewController(identifier: \u0026#34;DollInfo\u0026#34;, creator: { coder in return DollInfoViewController(coder: coder, doll: doll) }) else { fatalError(\u0026#34;Failed to initialize view controller\u0026#34;) } With this, we can finally initialize view controllers using dependency injection! You now longer need to specify public properties for your objects, and better yet, you no longer have to deal with optionals that can be error prone.\nConclusion Dependency injection is nothing new. Unfortunately, using it with Storyboards has never been directly possible. Thanks to iOS 13 we can now do this. Eliminating optionals has never felt better!\n","tags":["swift","programming","apple","ios","macos","watchos","tvos","storyboard"]},{"id":"4b85c79c20e8c649d93901f08dc9d18d","title":"Quick Introduction Reflection in Swift","link":"/posts/quick-introduction-reflection-swift/","content":"If you have been programming for a few years, you have undoubtedly come across the term Reflection. This feature allows us to inspect and work with the members of a type.\nif this doesn\u0026rsquo;t make sense, suppose you wanted to check what members a type has. How would you do this? Ideally you\u0026rsquo;d like to iterate over its members and print them. This is a very basic application of Reflection, but it should let think of other potential uses for it.\nIntroducing Mirror Mirror is an object that allows us to inspect the members of a type - it can be class, struct, or even a protocol. It\u0026rsquo;s simplest use doesn\u0026rsquo;t give much of a challenge.\nYou start by creating your object:\nstruct Person { let name: String let age: Int } Then create an object, and reflect it:\nlet andy = Person(name: \u0026#34;Andy Ibanez\u0026#34;, age: 28) let andyMirror = Mirror(reflecting: andy) andyMirror.children.forEach { print(\u0026#34;Member: \\($0.label)\u0026#34;) print(\u0026#34;Value: \\($0.value)\u0026#34;) } The above code would print:\nMember: Optional(\u0026#34;name\u0026#34;) Value: Andy Ibanez Member: Optional(\u0026#34;age\u0026#34;) Value: 28 We iterate over each property, and print its value.\nConclusion Reflection is a very interesting feature that allows to create some sort of meta-programming in Swift. While not applicable to many use cases, it\u0026rsquo;s important to be aware of its existence.\n","tags":["swift","programming","apple","dynamism","reflection","mirror","metaprogramming"]},{"id":"e76790d31e42d84817dba8352cc1c463","title":"Understanding @dynamicMemberLookup and @dynamicCallable in Swift","link":"/posts/understanding-dynamicmemberlookup-dynamiccallable-swift/","content":"If you have written code in a programming language such as Python or PHP, you can find many direct comparisons to Swift. For one, Swift is statically typed, whereas PHP and Python are not - Swift is considered a safe language as it has a bunch of features to protect you against mistakes - static typing, error throwing, optionality for dealing with nulls, to name a few -, whereas PHP and Python do not.\nSwift started adding features that allows it to behave closer to the behavior of more dynamic languages. The long term implication is that this allows Swift to work alongside such languages without too many downsides.\nIn this article we will talk about two features Swift has added in the last two major versions to make this possible, and how they work without necessarily weakening Swift\u0026rsquo;s features that ultimately make it a safe language.\nAccessing Member Properties with @dynamicMemberLookup Introduced in Swift 4.2, Swift introduced @dynamicMemberLookup. Marking your objects with this attribute will require them to a implement a subscript with the following signature:\nsubscript(dynamicMember member: String) -\u0026gt; AnyObject Where AnyObject can be any type. @dynamicMemberLookup allows you to specify any property in your class - even if it doesn\u0026rsquo;t exist -, and return a value for it.\nConsider the following example:\n@dynamicMemberLookup class Country { subscript(dynamicMember member: String) -\u0026gt; String { let properties = [\u0026#34;name\u0026#34;: \u0026#34;Bolivia\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;South America\u0026#34;] return properties[member, default: \u0026#34;NOT FOUND\u0026#34;] } } This class has no real members to speak of, but because it was marked with @dynamicMemberLookup, we can try to access any property we can think of. We chose this implementation to return a String, so Swift\u0026rsquo;s type safety is still pretty valid.\nlet country = Country() print(country.name) print(country.location) print(country.population) All the property accessors will go through the subscript method and return a value for it. In the example above we provide a default value of the subscript to return when the expected property does not exist.\nThe code above will print:\nBolivia South America NOT FOUND You can implement multiple subscript methods to return different types. In the following example we will add a new subscript(dynamicMember) subscript to return ints, which can be the population of a country:\nclass Country { subscript(dynamicMember member: String) -\u0026gt; String { let properties = [\u0026#34;name\u0026#34;: \u0026#34;Bolivia\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;South America\u0026#34;] return properties[member, default: \u0026#34;\u0026#34;] } subscript(dynamicMember member: String) -\u0026gt; Int { let properties = [\u0026#34;population\u0026#34;: 11_673_021] return properties[member, default: 0] } } If you try to run the new code as is:\nlet country = Country() print(country.name) print(country.location) print(country.population) Swift is actually not knowing to know what to do. Because we have more than one subscript(dynamicMember) now, Swift is not sure which one to call. To solve this, we need to move the properties to variables, and explicitly specify their type. The following code will compile and work as expected:\nlet country = Country() let name: String = country.name let location: String = country.location let population: Int = country.population print(name) print(location) print(population) Bolivia South America 11673021 Using @dynamicMemberLookup doesn\u0026rsquo;t mean that you have to stop using properties altogether, consider the following:\n@dynamicMemberLookup class Country { let name: String init(name: String) { self.name = name } subscript(dynamicMember member: String) -\u0026gt; String { let properties = [\u0026#34;name\u0026#34;: \u0026#34;Bolivia\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;South America\u0026#34;] return properties[member, default: \u0026#34;\u0026#34;] } subscript(dynamicMember member: String) -\u0026gt; Int { let properties = [\u0026#34;population\u0026#34;: 11_673_021] return properties[member, default: 0] } } let country = Country(name: \u0026#34;Chile\u0026#34;) let name: String = country.name let location: String = country.location let population: Int = country.population print(name) print(location) print(population) Chile South America 11673021 Swift will first try to get an actual member with the name you specify, and if it doesn\u0026rsquo;t find one, then it will call the relevant subscript method.\nKeep in that, if you find use for @dynamicMemberLookup, you will lose autocomplete for all the properties you expect it to cover. There\u0026rsquo;s currently no way for the IDE to see missing properties, as these ones are added on the runtime.\nMarking Types as Directly Callable with @dynamicCallable Introduced in Swift 5, @dynamicCallable allows your types to be callable types. What this means is that you can use your types directly to execute some code.\nWhen you mark your classes with @dynamicCallable, you need to at least one of the following methods:\nfunc dynamicallyCall(withArguments args: [AnyObject]) -\u0026gt; AnyObject func dynamicallyCall(withKeywordArguments args: KeyValuePairs\u0026lt;String, AnyObject\u0026gt;) -\u0026gt; AnyObject The difference is that the first one is used when you don\u0026rsquo;t want to use argument labels (like foo(1, 2)), or if you would rather have them (foo(firstValue: 1, secondValue: 2).\nIn the case of the first function, it doesn\u0026rsquo;t take an array, but rather a ExpressibleByArrayLiteral, so you can specify an array, a set, or anything other that conforms to it.\nThe following case will allow you to change the capitalization of any string. To demonstrate the use of @dynamicCallable, we will implement it with both signatures.\nThe first one doesn\u0026rsquo;t label the parameters, so it\u0026rsquo;s like an old C-Style call:\n@dynamicCallable class CaseChanger { enum Case: String, RawRepresentable { case uppercase = \u0026#34;uppercase\u0026#34; case lowercase = \u0026#34;lowercase\u0026#34; } func dynamicallyCall(withArguments args: [String]) -\u0026gt; String? { guard let casing = args.first, let string = args.last else { return nil } let casingType = Case(rawValue: casing.lowercased()) ?? Case.lowercase return casingType == .uppercase ? string.uppercased() : string.lowercased() } } let caseChanger = CaseChanger() let changedCase = caseChanger(\u0026#34;uppercase\u0026#34;, \u0026#34;Katarina Claes\u0026#34;) print(changedCase) Optional(\u0026#34;KATARINA CLAES\u0026#34;) The dynamism here allows us to do a lot of manual checking, but it\u0026rsquo;s part of the price we pay to get this neat dynamism. withArguments gives an array of the all the arguments passed to the function call so you can operate on them as needed. In this example we assume the first parameter is the casing we want, and the second one the string we want to change the case of.\nThe second variation lets us create dynamic calls specifying an argument label. This is the \u0026ldquo;swiftier\u0026rdquo; way.\n@dynamicCallable class CaseChanger { enum Case: String, RawRepresentable { case uppercase = \u0026#34;uppercase\u0026#34; case lowercase = \u0026#34;lowercase\u0026#34; } func dynamicallyCall(withKeywordArguments args: KeyValuePairs\u0026lt;String, String\u0026gt;) -\u0026gt; String? { guard let casingPair = args.first, let stringPair = args.last else { return nil } guard casingPair.key == \u0026#34;casing\u0026#34; \u0026amp;\u0026amp; stringPair.key == \u0026#34;string\u0026#34; else { return nil } let casingType = Case(rawValue: casingPair.value.lowercased()) ?? Case.lowercase return casingType == .uppercase ? stringPair.value.uppercased() : stringPair.value.lowercased() } } let caseChanger = CaseChanger() let changedCase = caseChanger(casing: \u0026#34;lowercase\u0026#34;, string: \u0026#34;IT WAS MANY AND MANY A YEAR AGO\u0026#34;) print(changedCase) Optional(\u0026#34;it was many and many a year ago\u0026#34;) Of course, thanks to the dynamism we have a lot of work to do with the checking. You may want to check that you have all the required labels, that they are in the correct order, and more. Your checks can be as complex as necessary depending on your case.\nThis is a very powerful feature, but you should probably sty clear, depending on your needs.\nConclusion Starting on Swift 4.2, the language has received many updates to make interoperability with dynamic languages easier. @dynamicMemberLookup and @dynamicCallable are very powerful features, but they have a lot of considerations and you should ask yourself twice if you want to use them.\n","tags":["swift","programming","apple","dynamism","swift-evolution","dynamiccallable","dynamicmemberlookup"]},{"id":"4510a6cfaad5826f65fc7a5092944396","title":"Writing Command Line Tools in Swift Using ArgumentParser, Part 6: Releasing And Installing Our Command Line Tool","link":"/posts/writing-commandline-tools-argumentparser-part6/","content":"I wasn\u0026rsquo;t sure if I should include this article as part of this series. But for the sake of completion, I decided to include it. This article is very short, but it tells us how to actually install our own tool in a system so we can start using it without writing its full path.\nTo recap, and before I end my series in Swift\u0026rsquo;s ArgumentParser, let\u0026rsquo;s give a quick overview of everything we have learned so far:\nWe learned the very basics of ArgumentParser, and we learned about the basic building blocks. We learned how to validate user input and deal with errors. We learned how to organize our command line tool in subcommands. We learned how to customize our pages to customize help. Finally, we learned how to make use of asynchronous APIs within our tool. While ArgumentParser is not ready to be used in production, you can finally start using it for your own projects.\nCompiling for Release and Installation Compiling To compile your command line tool, we need to use Xcode to create an Archive of it.\nOn Xcode, you can directly go to Product \u0026gt; and Archive. When the the project is done archiving, you will see the organizer window. Right click your project here and select \u0026ldquo;Show in Finder\u0026rdquo;.\nRight click the xcarchive file and select Show Package Contents.\nYour final binary is located inside the Products \u0026gt; usr \u0026gt; local \u0026gt; bin \u0026gt; YOUR_BINARY\nInstalling By default, Terminal programs a set of directories they search the command line tools in. Installing our command line tool is as easy as moving our binary to one of these default directories.\nOne such directory is actually seen above. UNIX systems have a /usr/local/bin directory where they keep their command line tools. This directory is part of the famous $PATH variable, which you have undoubtedly heard about. All the directories that are part of the $PATH are search paths for command line tools. When you execute a command line tool, such as cat, vim, tail, or others, the Terminal will look for their binaries in these folders.\nSo copy the binary you obtained from the previous section. Then in Finder, press Cmd + Shift + G. It will open a tiny window that lets you go to any directory in your system. Write /usr/local/bin, and press Enter.\nThen simply copy your command line tool here.\nNow we can use our command line from any Terminal window without having to specify its full path.\nandyibanez@Andys-iMac / % MyCommandLineTool 1 ---------------------------------------------------------- INFO FOR POK√âMON: 1 ESPECIES: bulbasaur ---------------------------------------------------------- Conclusion Our Command-Line tools can be installed by simply pasting them in a directory specified in the user\u0026rsquo;s $PATH variable. The user may configure some additional paths, but there\u0026rsquo;s a few default ones we can use. Once our tool is there, our users can use our tools very naturally, without having to specify their full name.\n","tags":["swift","programming","apple","ArgumentParser"]},{"id":"56e5fe819b9bdf3af67dd2e1d2f85024","title":"Writing Command Line Tools in Swift Using ArgumentParser, Part 5: Tools with Asynchronous APIs","link":"/posts/writing-commandline-tools-argumentparser-part5/","content":"In the past four weeks we have explored many of the features available to us via ArgumentParser and how to use them. Here\u0026rsquo;s a recap of everything we learned so far:\nWe learned the very basics We learned how to validate user input We explored a way to separate our tool into subcommands. And finally, we learned how we can improve our documentation pages In this article, we will not explore a feature exposed to us via ArgumentParser. Instead, we will learn how to do something very essential: Creating tools that require asynchronous APIs.\nThe Need for Asynchronous APIs. If you have been programming for Apple platforms for a while, you have most likely used asynchronous APIs. URLSession, for example, is a fully asynchronous API, as network requests are unpredictable, they can take long, and therefore they need to be executed in a different thread.\nThe problem with this is that command line tools in general are very linear. They have a beginning point of execution, and an end. They don\u0026rsquo;t really jump around different threads to do their job. In fact, if you ran a command line tool to do anything asynchronous, you\u0026rsquo;d see that it finishes up instantly without doing anything.\nBelow I have written an example that makes use of the PokeApi. It is, for the most part, the same code I used when we talked about Modern Background Tasks in iOS 13.\nstruct Pokemon: Codable { struct Species: Codable { let name: String } struct Sprites: Codable { let backDefault: URL? let backShiny: URL? let frontDefault: URL? let frontShiny: URL? enum CodingKeys: String, CodingKey { case backDefault = \u0026#34;back_default\u0026#34; case backShiny = \u0026#34;back_shiny\u0026#34; case frontDefault = \u0026#34;front_default\u0026#34; case frontShiny = \u0026#34;front_shiny\u0026#34; } } let species: Species let sprites: Sprites } class PokeManager { static let urlSession = URLSession(configuration: .default) static func pokemon(id: Int, completionHandler: @escaping (_ pokemon: Pokemon) -\u0026gt; Void) { let pokeUrl = buildPokemonURL(id: id) let task = urlSession.dataTask(with: pokeUrl) { (data, _, _) in let pokemon = try! JSONDecoder().decode(Pokemon.self, from: data!) DispatchQueue.main.async { completionHandler(pokemon) } } task.resume() } private static func buildPokemonURL(id: Int) -\u0026gt; URL { var urlComponents = URLComponents() urlComponents.scheme = \u0026#34;https\u0026#34; urlComponents.host = \u0026#34;pokeapi.co\u0026#34; urlComponents.path = \u0026#34;/api/v2/pokemon/\\(id)\u0026#34; return urlComponents.url! } } struct Pokedex: ParsableCommand { static let configuration = CommandConfiguration( commandName: \u0026#34;pokedex\u0026#34;, abstract: \u0026#34;Allows you to fetch info from a Pok√©mon with its Pok√©dex number.\u0026#34;, discussion: \u0026#34;\u0026#34;) @Argument(help: \u0026#34;number\u0026#34;) var number: Int func run() throws { PokeManager.pokemon(id: number) { (pokemon) in self.printInfo(for: pokemon) } } func printInfo(for pokemon: Pokemon) { print(\u0026#34;----------------------------------------------------------\\n\u0026#34;) print(\u0026#34;INFO FOR POK√âMON: \\(number)\\n\u0026#34;) print(\u0026#34;ESPECIES: \\(pokemon.species.name)\\n\u0026#34;) print(\u0026#34;----------------------------------------------------------\\n\u0026#34;) } } Pokedex.main() If you try to run this now, you will see the command line tool exits without printing anything at all:\nandyibanez@Andys-iMac Debug % ./MyCommandLinetool Error: Missing expected argument \u0026#39;\u0026lt;number\u0026gt;\u0026#39; Usage: pokedex \u0026lt;number\u0026gt; andyibanez@Andys-iMac Debug % ./MyCommandLinetool 1 andyibanez@Andys-iMac Debug % Making Asynchronous Tasks Behave Synchronously As of right now, ArgumentParser has no tools to offer for us to be able to run asynchronous tasks such as network requests. So we have to figure out a way to do this ourselves. The concurrent APIs (the Dispatch APIs) provided to us by Cocoa and Cocoa Touch allow us to force execution of asynchronous tasks in the same process our command line tool is running.\nBut forcing the entire task to run asynchronously can be overkill. So what I like to do is to pause the execution of the thread that needs the resource, and continue it when another task finishes its execution. There are many ways to do this, but my favorite method is to use a Semaphore so we can force the static pokemon(id:) method to return the Pok√©mon with the return keyword instead of passing it in a completion handler.\nLet\u0026rsquo;s turn our attention to the method in question:\nstatic func pokemon(id: Int, completionHandler: @escaping (_ pokemon: Pokemon) -\u0026gt; Void) { let pokeUrl = buildPokemonURL(id: id) let task = urlSession.dataTask(with: pokeUrl) { (data, _, _) in let pokemon = try! JSONDecoder().decode(Pokemon.self, from: data!) DispatchQueue.main.async { completionHandler(pokemon) } } task.resume() } We want this to return the Pok√©mon traditionally. No completion handlers or anything like that. URLSession is fully asynchronous, so it doesn\u0026rsquo;t have offer a way for us to do this either.\nFun fact: You could still use the old NSURLConnection APIs and get synchronous behavior for network requests, but I prefer to use URLSession because it\u0026rsquo;s more modern and we never know when NSURLConnection will go away - not to mention, it\u0026rsquo;s good to know how to do this because not all asynchronous APIs are necessarily network-related.\nFirst change the signature to this:\nstatic func pokemon(id: Int) -\u0026gt; Pokemon We are about to do the magic that returns the Pok√©mon.\nRemember to deal with errors properly in a real world application. I\u0026rsquo;m skipping everything to do with error validation here. In a real app, you may want to return a tuple with an optional Pok√©mon and an Optional error, or handle errors in a different way.\nNow replace the entire body of the method with this:\nlet pokeUrl = buildPokemonURL(id: id) var pokemon: Pokemon! let semaphore = DispatchSemaphore(value: 0) let task = urlSession.dataTask(with: pokeUrl) { (data, _, _) in pokemon = try! JSONDecoder().decode(Pokemon.self, from: data!) semaphore.signal() } task.resume() semaphore.wait() return pokemon This implementation uses a Semaphore. This is not an article on concurrent programming, so let\u0026rsquo;s just provide a very quick explanation of what a semaphore is, and how it works.\nIn concurrent programming, a semaphore controls access to a shared resource, ensuring that only one entity may access it at any given time.\nWhen we call wait on the semaphore, it will wait until someone else calls signal on it. So essentially, this code will execute all the way down to semaphore.wait. The thread will pause until the completion handler is executed and assigns the Pok√©mon. After assigning the Pok√©mon, it will call signal so our previous thread can continue execution. because we will have a Pok√©mon before the return statement, we can just return the Pok√©mon.\nNote that we did not switch threads or anything like that: All we did was to pause the thread that pok√©mon(id:) is executing in until the thread with the network request\u0026rsquo;s completion handler is done executing.\nYou can read more about semaphores here.\nNext change the implementation of your run method:\nfunc run() throws { let pokemon = PokeManager.pokemon(id: number) printInfo(for: pokemon) } And we are done! Build and run your tool and it will properly fetch content from the network:\nandyibanez@Andys-iMac Debug % ./MyCommandLinetool 1 ---------------------------------------------------------- INFO FOR POK√âMON: 1 ESPECIES: bulbasaur ---------------------------------------------------------- If your command line tool is fully asynchronous, you can just move the semaphore calls to the tool\u0026rsquo;s run body.\nConclusion Command line tools that require asynchronous operations are very common. Even more so tools that connect to the network and do something with it. Thanks to Foundation\u0026rsquo;s Dispatch APIs, we can return content that would otherwise need a completion handler. It\u0026rsquo;s very useful to know this, because command line tools that need a network connection are very common.\n","tags":["swift","programming","apple","ArgumentParser"]},{"id":"6630944b729447beee3234902d67ad0c","title":"Writing Command Line Tools in Swift Using ArgumentParser, Part 4: Customizing Help","link":"/posts/writing-commandline-tools-argumentparser-part4/","content":"Writing Command Line Tools in Swift Using ArgumentParser, Part 4: Customizing Help\nIn the past few weeks, we have explored how to use ArgumentParser and many of its features. It\u0026rsquo;s great that ArgumentParser provides a lot of functionality for free, but it wouldn\u0026rsquo;t make sense to build great tools that users can\u0026rsquo;t figure out how to use. This week is all about that.\nWe saw how ArgumentParser can build a lot of documentation for free, but we can actually do more. This week, we will explore how we can improve the documentation generated for our command line tools.\nCustomizing Help For Options, Arguments, and Flags @Argument, @Option, and @Flag can take a help property which we can use to describe the parameter and how to use it. But not only can this take a string, it can also take an ArgumentHelp object (despite it being called ARGUMENTHelp, it can be used in all the property wrappers).\n@Argument(help: ArgumentHelp( \u0026#34;The string parameter will be counted against the specified character sets\u0026#34;, discussion: \u0026#34;This obligatory parameter will be used to count the characters of.\u0026#34;, valueName: \u0026#34;theString\u0026#34;, shouldDisplay: true)) var string: String andyibanez@Andys-iMac Debug % ./MyCommandLineTool --help USAGE: character-count \u0026lt;theString\u0026gt; [--whitespace] [--numbers] [--vowels] ARGUMENTS: \u0026lt;theString\u0026gt; The string parameter will be counted against the specified character sets This obligatory parameter will be used to count the characters of. OPTIONS: --whitespace/--numbers --vowels -h, --help Show help information. You can use this object to customize every aspect of the parameter\u0026rsquo;s help. The discussion is a short description next to the parameter name; the valueName is a customized name you can use if you don\u0026rsquo;t want the framework to generate one for you automatically; Finally, shouldDisplay is a boolean that triggers whether the parameter should be shown or not. This is handy when you want to hide certain properties.\nCustomizing a Command\u0026rsquo;s Help Via CommandConfiguration We explored how to use CommandConfiguration when we talked about subcommands, this little object can do much more, including customize our command\u0026rsquo;s entire help page. In other words, what your users see when they run your tool with the -h or --help flags.\nstatic let configuration = CommandConfiguration( commandName: \u0026#34;CharacterCounter\u0026#34;, abstract: \u0026#34;Allows you to count the number of characters in a string\u0026#34;, discussion: \u0026#34;A string is a made up of multiple characters. A character can be human-readable or a control character. When counting characters, you may need to know if you want to consider control characters or not, as the results may vary.\u0026#34;) The CommandName is the name we want our tool to have, the name we want our users to invoke when they want to use our command line tool. This is helpful if you do not necessarily want the command name to be the executable name.\nThe abstract is a short description of what the command line tools. It should give your users a quick overview of what your tool does.\nThe discussion can be a longer description. You can format it using Swift heredoc-style strings. Your command line tool can give more information and context by using this property.\nWhen your user runs your tool with -h, they will see this:\nandyibanez@Andys-iMac Debug % ./MyCommandLineTool -h OVERVIEW: Allows you to count the number of characters in a string A string is a made up of multiple characters. A character can be human-readable or a control character. When counting characters, you may need to know if you want to consider control characters or not, as the results may vary. USAGE: CharacterCounter \u0026lt;string\u0026gt; ARGUMENTS: \u0026lt;string\u0026gt; String to count OPTIONS: -h, --help Show help information. And that\u0026rsquo;s it! Configuring our help pages is really use, and we can write user-facing documentation with a few lines of code.\nConclusion Your command line tool should provide as much help as possible for your users. ArgumentParser makes it very easy to write them, by providing ArgumentHelp and CommandConfiguration.\n","tags":["swift","programming","apple","ArgumentParser"]},{"id":"cecb15b30139c546014c5dfcd4835485","title":"Writing Command Line Tools in Swift Using ArgumentParser, Part 3: Subcommands","link":"/posts/writing-commandline-tools-argumentparser-part3/","content":"We have been having a lot of fun with ArgumentParser in the last two weeks, and the fun is not about to end any time soon. We have explored how we can build basic commands with the basic building blocks of the framework, and how we can perform advanced validation and error handling. This week, we will something very useful: Subcommands.\nSubcommands If you have used git directly from the command line before, you have used subcommands before.\nConsider the following example:\ngit add . In ArgumentParser talk, git would be a command - something that inherits directly from ParsableCommand. What\u0026rsquo;s with the add? An @Argument? You can actually probably find a way to implement this with an @Argument, but there is actually an easier way to implement something like this.\nBy using subcommands, we can create commands that wrap different subcommands. In the above example, git is the main command, and add is a subcommand. It can be a good idea to separate your command line tool into different subcommands as it grows. The beautiful thing about ArgumentParser is that it provides many features to make this separation easier, in the Swiftiest way possible.\nWe will explore these features by creating sub commands for our CharacterCount tool: One to count characters for a string we passed directly; One to count the characters from a local file; and finally, one to count the characters from a remote URL.\nThe ParsableArguments Protocol Implement this protocol when you need to create properties that will be shared across your subcommands. Types that conform to this protocol can parse arguments handed through the command line, but they cannot run on their own.\nstruct CharacterCount: ParsableCommand { enum CountingConfiguration: String, CaseIterable { case all case uppercaseOnly case lowercaseOnly } struct Options: ParsableArguments { @Flag(default: CountingConfiguration.all, help: \u0026#34;The kind of characters to count\u0026#34;) var countingConfig: CountingConfiguration @Flag(help: \u0026#34;If set, ignores whitespace characters\u0026#34;) var ignoringWhitespace: Bool @Option(default: 1, help: \u0026#34;Multiplies the end result by the specified number\u0026#34;) var multiplier: Int } } So far nothing too fancy. We have created an Options struct that conforms to ParsableCommand and we have added a few properties there.\nCreating Subcommands To actually create a subcommand, we need to define them just the same way you would define a parent command, conforming to ParsableCommand and all. Then, you need to tell your parent command that it contains the subcommands with their name.\nYou can begin separating your code in separate files for organization purposes. And then you can define the subcommands within extensions of the parent command.\nextension CharacterCount { struct DirectString: ParsableCommand { @Argument(help: \u0026#34;The string to count the characters of\u0026#34;) var string: String func run() { print(string.count) } } } This is the basic implementation. We will implement the options in a bit.\nNext, to actually create the relationship that your parent command has subcommands, we need to create a CommandConfiguration property where we can specify each subcommand that belongs to it. We will explore CommandConfiguration in depth in a later article. For now, you can use it like this to define your subcommands. Add the following property to your parent command:\nstatic let configuration = CommandConfiguration(subcommands: [DirectString.self]) With all that done, we can now call our subcommand:\n./MyCommandLineTool direct-string \u0026#34;Alice\u0026#34; 5 The direct-string name was generated for you for free. The help page for the parent command now has a SUBCOMMANDS section:\n./MyCommandLineTool USAGE: character-count \u0026lt;subcommand\u0026gt; OPTIONS: -h, --help Show help information. SUBCOMMANDS: direct-string CommandConfiguration can also take a defaultCommand to run, which you can use when your command is run without specifying a subcommand.\nPropagating Options with @OptionGroup Introducing now a new property wrapper to your ArgumentParser toolbox, we have @OptionGroup. This property wrapper allows us to receive the arguments defined in a ParsableArguments type.\nTo use, simply add a line like the following in a subcommand:\n@OptionGroup() var parentOptions: Options Where Options is the type we defined in the parent.\nWe can now use them in our DirectString command. The full implementation for this subcommand looks like this:\nextension CharacterCount { struct DirectString: ParsableCommand { @Argument(help: \u0026#34;The string to count the characters of\u0026#34;) var string: String @OptionGroup() var parentOptions: Options func run() { let whiteSpacechars = string.filter { $0 == \u0026#34; \u0026#34; }.count let alwaysSubtract = parentOptions.ignoringWhitespace ? whiteSpacechars : 0 let mult = parentOptions.multiplier if parentOptions.countingConfig == .all { print((string.count - alwaysSubtract) * mult) } if parentOptions.countingConfig == .uppercaseOnly { let count = string.filter { $0.isUppercase }.count print((count - alwaysSubtract) * mult) } if parentOptions.countingConfig == .lowercaseOnly { let count = string.filter { $0.isLowercase }.count print((count - alwaysSubtract) * mult) } } } } You can now use all the options defined in the parent, and all subcommands that belong to the parent belong can use the options in the same way. As a reference, in our program you\u0026rsquo;d use the options as:\n./MyCommandLineTool direct-string \u0026#34;Pullip Classical Alice\u0026#34; 22 ./MyCommandLineTool direct-string \u0026#34;Pullip Classical Alice\u0026#34; --ignoring-whitespace 20 ./MyCommandLineTool direct-string \u0026#34;Pullip Classical Alice\u0026#34; --ignoring-whitespace --multiplier 3 60 Implementing The Other Commands You have now learned how to implement subcommands and how to use OptionGroup, so you have all the tools you need to implement the other subcommands. If you don\u0026rsquo;t feel like doing so, I will leave their implementations below:\nextension CharacterCount { struct LocalFile: ParsableCommand { @Argument(help: \u0026#34;A path to a local file to count the characters of\u0026#34;) var localFile: String @OptionGroup() var parentOptions: Options func run() { do { let string = try String(contentsOfFile: localFile) processString(string: string, options: parentOptions) } catch { print(\u0026#34;Unable to open local file\u0026#34;) } } } } extension CharacterCount { struct RemoteFile: ParsableCommand { @Argument(help: \u0026#34;The URL of the remote file to count the characters of\u0026#34;, transform: { URL(string: $0)! }) var remoteFile: URL @OptionGroup() var parentOptions: Options func run() { do { let string = try String(contentsOf: remoteFile) processString(string: string, options: parentOptions) } catch { print(\u0026#34;Unable to open local file\u0026#34;) } } } } func processString(string: String, options: CharacterCount.Options) { let whiteSpacechars = string.filter { $0 == \u0026#34; \u0026#34; }.count let alwaysSubstract = options.ignoringWhitespace ? whiteSpacechars : 0 let mult = options.multiplier if options.countingConfig == .all { print((string.count - alwaysSubstract) * mult) } if options.countingConfig == .uppercaseOnly { let count = string.filter { $0.isUppercase }.count print((count - alwaysSubstract) * mult) } if options.countingConfig == .lowercaseOnly { let count = string.filter { $0.isLowercase }.count print((count - alwaysSubstract) * mult) } } And don\u0026rsquo;t forget to add them as subcommands in the parent command:\nstatic let configuration = CommandConfiguration( subcommands: [ DirectString.self, RemoteFile.self, LocalFile.self ] ) Conclusion Separating your command line tool into subcommands is very easy to do thanks to ArgumentParser\u0026rsquo;s parser features. You can configure children commands very easily in a parent command\u0026rsquo;s configuration, and, if your subcommands take the same options, flags, and arguments, you can declare them in a type conforming to ParsableArgument, so all subcommands that need them can simply use the @OptionGroup property wrapper to access them.\n","tags":["swift","programming","apple","ArgumentParser"]},{"id":"27b431f46aabf5b5ca31ff71b7e5e14b","title":"Writing Command Line Tools in Swift Using ArgumentParser, Part 2: Validation \u0026 Errors","link":"/posts/writing-commandline-tools-argumentparser-part2/","content":"Last week we explored how we can build a simple command line tool. We learned how to use @Argument, @Option, and @Flag as the building blocks for ArgumentParser command line tools. We we saw last week was enough to build many simple tools, but there\u0026rsquo;s still a lot to explore, and cool things to learn.\nThis week we will learn about input validation and errors, so we can build better tools that take more constrained parameters when relevant.\nArgumentParser Validation ArgumentParser has all the facilities you need to validate your input, both before you need them and when exception occurs when you are using it.\nArgumentParser allows you to perform two types of validation: Pre-Running Validation, which lets you check your arguments before your run() function is reached, and Post-Validation errors, which allows you to throw errors when an exception occurs with an otherwise valid input.\nCommand-Line Input Validation The framework already does a lot of validation for you for free. It will validate the data types you are passing so they conform to the types specified in each property wrapper.\nBut you may want to do some additional validations that the framework can\u0026rsquo;t do. Consider our CharacterCount tool from the last article. Suppose we want to restrict it to strings that are at least 3 character long.\nParsableCommand has a validate() method that you can implement, and you can do any custom validations within it.\nTo use it, implement custom checks and throw ValidationErrors when the condition fails.\nstruct CharacterCount: ParsableCommand { @Argument(help: \u0026#34;String to count the characters of\u0026#34;) var string: String mutating func validate() throws { if string.count \u0026lt; 3 { throw ValidationError(\u0026#34;\u0026#39;string\u0026#39; must contain at least 3 characters.\u0026#34;) } } func run() { print(string.count) } } Of course, you could naively do the validation within run itself, but implementing validate lets you do separation of concerns way easier.\nNow when you try to run this program with a string with less than 3 characters, you will get an error like this:\n./CharacterCount \u0026#34;hi\u0026#34; Error: \u0026#39;string\u0026#39; must contain at least 3 characters. Usage: character-count \u0026lt;string\u0026gt; For the record, validation is not limited to @Argument. You can use it with @Option and @Flag as well.\nPost-Validation Errors We can use the validate() method to ensure additional constraints are fulfilled before our program runs, but what happens when the conditions are fine, but something else fails?\nConsider a program that takes a path to a local file. The framework will take care of validating that the user is indeed passing you a string which is the string to the file, but you can\u0026rsquo;t check if the file is in a valid format until you try opening it.\nTo write checks against this cases, you can use a version of the run function that throws errors.\nstruct CharacterCount: ParsableCommand { @Argument(help: \u0026#34;File to count the characters of\u0026#34;) var filePath: String func run() throws { let contents = try String(contentsOfFile: filePath, encoding: .utf8) print(contents.count) } } Trying to run the program with an invalid file will produce the following output:\n./CharacterCount path_to_file Error: Error Domain=NSCocoaErrorDomain Code=260 \u0026#34;The file ‚Äúpath_to_file‚Äù couldn‚Äôt be opened because there is no such file.\u0026#34; UserInfo={NSFilePath=path_to_file, NSUnderlyingError=0x7fc2ec40ebe0 {Error Domain=NSPOSIXErrorDomain Code=2 \u0026#34;No such file or directory\u0026#34;}} Of course, because this will throw Errors to the console, there\u0026rsquo;s cases when whatever it prints may be cryptic for your users, so you should minimize throwing errors directly and only use them when there\u0026rsquo;s absolutely no other way to check for them before hand.\nIn our specific program, there\u0026rsquo;s two possible errors that can happen when we try to open files:\\\nThey don\u0026rsquo;t exist. they cannot be opened as plain text files. The former case can be dealt with easily, as we can write a check for it, using the FileManager API:\nmutating func validate() throws { if !FileManager.default.fileExists(atPath: filePath) { throw ValidationError(\u0026#34;\u0026#39;filePath\u0026#39; does not exist\u0026#34;) } } And now we can at least show a more user-friendly error when the file does not exist.\nBut the latter isn\u0026rsquo;t really easy to figure out until you try opening it. You can probably figure out a way to check the first bytes of the file or do anything else crazy before you read the entire file. But it may not be worth it, and in that case, i\u0026rsquo;d just throw the error to the console directly.\nThe following example will try opening a PDF file I have in my ~/downloads folder.\n./CharacterCount /Users/andyibanez/downloads/Formulario.pdf Error: Error Domain=NSCocoaErrorDomain Code=261 \u0026#34;The file ‚ÄúFormulario.pdf‚Äù couldn‚Äôt be opened using text encoding Unicode (UTF-8).\u0026#34; UserInfo={NSFilePath=/Users/andyibanez/downloads/Formulario.pdf, NSStringEncoding=4} You could, of course, wrap it inside a do-catch block and only print the error when your catch is reached. But then, you have to balance. When do I want to show a friendly message? When do I want to show the entire error for the purpose of diagnostics? The good news is that ArgumentParser allows you to deal with errors easily, so you just need to think about whether showing an entire error makes sense or not.\nConclusion ArgumentParser lets you validate input and run time exceptions easily. You can write command lines with stricter constrains so your users don\u0026rsquo;t run your tool with weird input.\n","tags":["swift","programming","apple","ArgumentParser"]},{"id":"472359b3b751d91e8064bb28c500fe78","title":"Writing Command Line Tools in Swift Using ArgumentParser, Part 1: Introduction \u0026 Basic Usage","link":"/posts/writing-commandline-tools-argumentparser-part1/","content":"A few weeks ago, the Swift project introduced the ArgumentParser package. This package makes it easy to write command line tools by providing automatic parsing, documentation generation, and more.\nIn this article, we will explore ArgumentParser, and how we can start building some command line tools with it, using the basic building blocks, which are three Property Wrappers called Argument, Option, and Flag.\nProject Configuration Open Xcode and create a new project of type \u0026ldquo;Command Line Tool\u0026rdquo;. You cannot use this project type for iOS/iPadOS, so if you don\u0026rsquo;t find it, head over to the Mac tab.\nGo through the rest of the prompts, and when you are done, click over your project\u0026rsquo;s blueprint, and under the \u0026ldquo;Project\u0026rdquo; section (NOT targets), click your project blueprint again. You will now see the \u0026ldquo;Swift Packages\u0026rdquo; tab. Click the \u0026ldquo;+\u0026rdquo; button and add the following package:\nhttps://github.com/apple/swift-argument-parser We can now write some code.\nWriting A Simple Command Line Tool We will see how ArgumentParser works by creating a simple program that lets us count the characters in a string. While it sounds simple, we will add more options as we go along.\nThe package allows you to create tools very easily that follow the conventions you\u0026rsquo;d find in most command line tools. You can create tools that take arguments, options, and flags, and it exposes all this functionality through Property Wrappers. The framework also takes care of a lot of automatic configuration for you. For example, it can automatically create short-letter options for your commands (-c as another way of calling --count). In This section we will explore the three property wrappers that make ArgumentParser: @Argument, @Option, and @Flag.\nThe @Argument Property Wrapper A command line tool is a struct that conforms to the ParsableCommand protocol. This protocol does a lot of magic behind the scenes for us.\nstruct CharacterCount: ParsableCommand { @Argument(help: \u0026#34;String to count the characters of\u0026#34;) var string: String func run() throws { print(string.count) } } CharacterCount.main() This command line tool will allow us to count the number of characters in a string. The Argument property wrapper indicates that the property should be retrieved from the command line. The name of the argument is derived from its variable name marked as @Argument. Swift also takes care of the data type for us thanks to its static typing. If you pass in a number to this tool, Swift will treat it as a string, but if you specify the argument to be an Int instead, Swift will treat it as such and fail when it can‚Äôt detect it as a number. The help in @Argument will synthesize a description for the argument when the user views your command\u0026rsquo;s help page.\nYou need to call your ParsableCommand\u0026rsquo;s main() method in order to run your tool.\nTesting Your Command Line Tool You may be tempted to press Run in Xcode to use your tool, just to find that Xcode terminates it immediately with an error similar to this:\nError: Missing expected argument \u0026#39;\u0026lt;string\u0026gt;\u0026#39; Usage: character-count \u0026lt;string\u0026gt; Program ended with exit code: 1 First, notice how Xcode is telling you it can\u0026rsquo;t run your tool because \u0026lt;string\u0026gt; is missing. This is part of the functionality you get for free.\nTo actually run your program, you have two options. The first one, is to edit your \u0026ldquo;Run\u0026rdquo; scheme to launch your tool with command line arguments. To do this, you can long-click your command tool name near the Run button in Xcode and select Edit Scheme:\nYou will see this window where you can pass in your arguments. I\u0026rsquo;m passing \u0026ldquo;Alice\u0026rdquo; as a string.\nNow when you run your command line tool, it will show the following in Xcode.\n5 Program ended with exit code: 0 \u0026hellip; But this is actually a very annoying way to do it. You would have to modify the launch arguments every time you want to test something new.\nA better way to test your command line tool is to go to Xcode, File \u0026gt; Preferences \u0026gt; Locations. Open the Derived Data location, and locate the folder for your tool. The folder you are looking for is called \u0026ldquo;\u0026rdquo; concatenated with some random string. My project is called \u0026ldquo;MyCommandLineTool\u0026rdquo;, so my folder is MyCommandLineTool-egtvueadzoycpmgvxbashkvkircq. Inside your folder, dig all the way down, using the Terminal, to Build/Products/Debug (my full path was /Users/andyibanez/Library/Developer/Xcode/DerivedData/MyCommandLineTool-egtvueadzoycpmgvxbashkvkircq/Build/Products/Debug. Your command line tool\u0026rsquo;s binary is here, and you can run it as so:\n./MyCommandLineTool Alice So now instead of having to modify the arguments through Xcode, you can directly launch your tool via the Terminal, and have a feel of how it will work in the real world.\nAnother handy tip, and part of all the functionality you get for free, is a help page and usage instructions generated for you. If you just run:\n./MyCommandLine With no arguments, the command line will show:\nError: Missing expected argument \u0026#39;\u0026lt;string\u0026gt;\u0026#39; Usage: character-count \u0026lt;string\u0026gt; Even better, you get a free help page displayed when you use the --help flag.\n./MyCommandLineTool --help ARGUMENTS: \u0026lt;string\u0026gt; String to count the characters of OPTIONS: -h, --help Show help information. The description of the \u0026lt;string\u0026gt; argument comes directly from what you specified as the help parameter in the @Argument property wrapper.\nAs you can see, ArgumentParser provides us with a a lot of free functionality out of the box. And we are just getting started.\nMore @Argument Usage Command line tools can take a variable amount of @Arguments, though keep in mind you must have at least one.\nstruct CharacterCount: ParsableCommand { @Argument(help: \u0026#34;String to count the characters of\u0026#34;) var string: String @Argument(help: \u0026#34;A second string to count the characters of\u0026#34;) var string2: String func run() throws { print(string.count) print(string2.count) } } ./MyCommandLineTool Pullip Alice 6 5 The above example will require you pass in both \u0026lt;string\u0026gt; and \u0026lt;string2\u0026gt;, and if you just pass in one, it will complain \u0026lt;string2\u0026gt; is missing. But you can mark Arguments as optionals, and they no longer become mandatory.\nstruct CharacterCount: ParsableCommand { @Argument(help: \u0026#34;String to count the characters of\u0026#34;) var string: String @Argument(help: \u0026#34;A second string to count the characters of\u0026#34;) var string2: String? func run() throws { print(string.count) if let str2 = string2 { print(str2.count) } } } ./MyCommandLineTool Pullip 6 And yes, you can just specify an array of strings as the argument, and it will work as you expect.:\nstruct CharacterCount: ParsableCommand { @Argument(help: \u0026#34;Strings to count the characters of\u0026#34;) var strings: [String] func run() throws { strings.forEach { print($0.count) } } } ./MyCommandLineTool Pullip Classical Alice 6 9 5 Keeping in mind that, if you want to treat \u0026ldquo;Pullip Classical Alice\u0026rdquo; as a single string, you have to wrap it in quotes:\n./MyCommandLineTool \u0026#34;Pullip Classical Alice\u0026#34; 22 You can also use any kind of data type and it will be parsed accordingly:\n@Argument(help: \u0026#34;String to count the characters of\u0026#34;) var string: String @Argument(help: \u0026#34;Multiplier\u0026#34;) var multiplier: Int func run() throws { print(string.count * multiplier) } Arguments are the basic blocks of command line tools, and ArgumentParser makes it very easy to parse them out.\nTransforming Arguments Because the package will receive everything as strings first, you have the opportunity to transform arguments before they are ready to be used. For this, the @Argument property wrapper has an optional transform property you can use.\nSuppose you want to make a string longer when you receive. You can do something like this:\n@Argument(help: \u0026#34;String to count the characters of\u0026#34;, transform: ({ return \u0026#34;\\($0)makeItLonger\u0026#34; })) var string: String ./MyCommandLineTool Alice 17 Very useful in many cases. You could, for example, transform your argument into a URL if you let users perform network requests through your tool:\n@Argument(help: \u0026#34;URL to retrieve\u0026#34;, transform: ({ return URL(string: $0)!})) var string: URL Configurable Options via the @Option Property Wrapper Options are key-value pairs that allow users to modify the behavior of their command line tool.\nIn a previous example, we used a multiplier argument to multiply the result of count by something else. While it works, it semantically makes no sense to use multiplier this way. Instead, we should use it as an @Option, that the user can specify if they want:\n@Option(help: \u0026#34;The number to multiply the count against.\u0026#34;) var multiplier: Int The code above will force users to provide the multiply parameter, which we can do as so:\n./MyCommandLineTool Alice --multiplier 3 15 But there\u0026rsquo;s more! By default, options will provide a lot of free functionality. You can call your option with an equal sign between its name and its value:\n./MyCommandLineTool Alice --multiplier=3 Doing More With @Option @Option actually has a lot of configuration options. Way more than @Argument.\nConfiguring an @Option\u0026rsquo;s Name When you use @Option, the name of the option will be exposed in the tool as the name of the variable. But we can change it by using the name property of the Property Wrapper, which takes a NameSpecification.\nThe .long value will grab the variable name directly and expose it as such, separating words with a hyphen when the framework detects the option has multiple words in its name. This is the default, which exposes our multiply variable as --multiply.\nThe .short value will create an option which starts with the first letter of the variable name. In other words, our multiply variable will simply be exported as a -m option. Notice the single hyphen. A convention used for command line tools is, options that have more than one letter have two hyphens, and those that are a single letter have a single hyphen.\n@Option(name: .short, help: \u0026#34;The number to multiply the count against.\u0026#34;) var multiplier: Int ./MyCommandLineTool Alice -m 3 15 The --help page also reflects this:\nandyibanez@Andys-iMac Debug % ./MyCommandLineTool Alice --help USAGE: character-count \u0026lt;string\u0026gt; -m \u0026lt;m\u0026gt; ARGUMENTS: \u0026lt;string\u0026gt; String to count the characters of OPTIONS: -m \u0026lt;m\u0026gt; The number to multiply the count against. -h, --help Show help information. Apparently, the framework cannot do anything when it finds two options that start with m and you are using .short. I tried adding a second option whose name starts with m, and I couldn\u0026rsquo;t get it to run by specifying two ms when calling the command, so keep in that mind.\nTo go around that, NameSpecification also provides .customShort(string:) and .customLong(string:), which let you change completely the names of the options when exposed to the command line.\n@Option(name: .customLong(\u0026#34;multi\u0026#34;), help: \u0026#34;The number to multiply the count against.\u0026#34;) var multiplier: Int ./MyCommandLineTool Alice --multi 3 15 @Option(name: .customShort(\u0026#34;w\u0026#34;), help: \u0026#34;The number to multiply the count against.\u0026#34;) var multiplier: Int ./MyCommandLineTool Alice -w 3 15 Command line tools usually offer both long and short names for their options. You can do this as well, by using the .shortAndLong value.\n@Option(name: .shortAndLong, help: \u0026#34;The number to multiply the count against.\u0026#34;) var multiplier: Int ./MyCommandLineTool --help USAGE: character-count \u0026lt;string\u0026gt; --multiplier \u0026lt;multiplier\u0026gt; ARGUMENTS: \u0026lt;string\u0026gt; String to count the characters of OPTIONS: -m, --multiplier \u0026lt;multiplier\u0026gt; The number to multiply the count against. -h, --help Show help information. If you have looked at the autocomplete suggestions, you may be aware that there\u0026rsquo;s no way to specify both a .customShort and .customLong at the same time. But you can actually pass in an array of options, so really, you can add as many names as you want to an option.\nTo use both .customLong and .customShort, you can use this:\n@Option(name: [.customShort(\u0026#34;w\u0026#34;), .customLong(\u0026#34;multi\u0026#34;)], help: \u0026#34;The number to multiply the count against.\u0026#34;) var multiplier: Int But you can specify a bunch of other names as well. If you think users are likely to use many names for multiplier, you could use something like this:\n@Option( name: [ .customLong(\u0026#34;multiplier\u0026#34;), .customLong(\u0026#34;multi\u0026#34;), .customLong(\u0026#34;mult\u0026#34;), .customLong(\u0026#34;multiplicador\u0026#34;), .customLong(\u0026#34;multiplierr\u0026#34;)], help: \u0026#34;The number to multiply the count against.\u0026#34;) var multiplier: Int andyibanez@Andys-iMac Debug % ./MyCommandLineTool Alice --help USAGE: character-count \u0026lt;string\u0026gt; --multiplierr \u0026lt;multiplierr\u0026gt; ARGUMENTS: \u0026lt;string\u0026gt; String to count the characters of OPTIONS: --mult, --multi, --multiplicador, --multiplier, --multiplierr \u0026lt;multiplierr\u0026gt; The number to multiply the count against. -h, --help Show help information. Needless to say, you should only do this in exceptional cases.\nPassing In Default Values @Option has a default parameter you can use to specify a default value when it is missing. Its usage is pretty straightforward:\n@Option(default: 1, help: \u0026#34;The number to multiply the count against.\u0026#34;) var multiplier: Int Your help page will also reflect this.\n--multiplier \u0026lt;multiplier\u0026gt; The number to multiply the count against. (default: 1) Transforming Options Just like with @Argument, we can specify a closure to call when we receive the option to operate on it and transform it before our tool can use it.\nIn the following example, we will check the value of the option. If we receive 0, we will turn it into 1. Any other value will be used as-is.\n@Option( default: 1, help: \u0026#34;The number to multiply the count against.\u0026#34;, transform: ({ Int($0)! == 0 ? 1 : Int($0)! })) var multiplier: Int Be careful of your optionals, because the framework will pass you the value as it was received, so there\u0026rsquo;s no guarantee it will actually be a string.\nConfigurable Options With @Flag Very similar to @Option, @Flag allows your users to change how your command line tool behaves. The difference is that @Option works with key-value pairs, whereas the existence of a @Flag tells us if a value exists or not. Usually used with Booleans, @Flag allows us to create options that can simply be toggled by our users.\nstruct CharacterCount: ParsableCommand { @Argument(help: \u0026#34;String to count the characters of\u0026#34;) var string: String @Flag(help: \u0026#34;When set, it ignores whitespace characters\u0026#34;) var ignoringWhiteSpace: Bool func run() throws { print(ignoringWhiteSpace ? string.filter { $0 != \u0026#34; \u0026#34; }.count : string.count) } } ./MyCommandLineTool \u0026#34;Pullip Classical Alice\u0026#34; --ignoring-white-space 20 Just by specifying --ignoring-white-space, the ignoringWhiteSpace variable becomes true. Also, flags cannot be marked as optional.\nConfiguring @Flags. Just like you can configure @Argument and @Option, you can configure @Flags.\nSpecifying Names for Your Flags You can configure a flag\u0026rsquo;s name in the same way you can modify the name of an option. Pass in the name parameter and you can use the same NameSpecification as in @Option.\n@Flag(name: .short, help: \u0026#34;When set, it ignores whitespace characters\u0026#34;) var ignoringWhiteSpace: Bool Specifying Prefixes You can create matching flag names so it\u0026rsquo;s always explicit whether your user wants to enable a flag or not.\n@Flag(inversion: .prefixedEnableDisable, help: \u0026#34;When set, it ignores whitespace characters\u0026#34;) var ignoringWhiteSpace: Bool andyibanez@Andys-iMac Debug % ./MyCommandLineTool --help USAGE: character-count \u0026lt;string\u0026gt; [--enable-ignoring-white-space] [--disable-ignoring-white-space] ARGUMENTS: \u0026lt;string\u0026gt; String to count the characters of OPTIONS: --enable-ignoring-white-space/--disable-ignoring-white-space When set, it ignores whitespace characters (default: false) -h, --help Show help information. This will create two flags for our @Flag, and prefix them with enabled- or disabled- so the user always has to specify one.\nFlags with Enumerations @Flags can work with enumerations so you can allow users to pick more options, but limiting the number parameters that the flags can take.\nTo do this, your enumeration must conform to a RawRepresentable (such as String) and with CaseIterable. The below example will let us specify what characters we care about.\nstruct CharacterCount: ParsableCommand { enum CharSet: String, CaseIterable { case whitespace case numbers case vowels } @Argument(help: \u0026#34;String to count the characters of\u0026#34;) var string: String @Flag(help: \u0026#34;Character sets to ignore\u0026#34;) var characterSets: [CharSet] func run() throws { var allChars = [String]() if characterSets.contains(.whitespace) { string.forEach { if $0 == \u0026#34; \u0026#34; { allChars += [String($0)] } } } if characterSets.contains(.numbers) { let numbers = (0...9).map { \u0026#34;\\($0)\u0026#34; } string.forEach { if numbers.contains(String($0)) { allChars += [String($0)] } } } if characterSets.contains(.vowels) { let vowels = [\u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;o\u0026#34;, \u0026#34;u\u0026#34;] string.forEach { if vowels.contains(String($0.lowercased())) { allChars += [String($0)] } } } print(allChars.count) } } ./MyCommandLineTool \u0026#34;Pullip Al1ce\u0026#34; --whitespace --numbers 2 The value names (--whitespace, --numbers, etc) are derived from the raw values.\nConclusion It looks like we covered a lot of ground here, but all we really covered is how to use the building blocks of ArgumentParser. @Argument, @Option, and @Flag are used to create command line tools, and they provide a lot of functionality for free, all the way from parsing to documentation generation. We will be covering more about this package in the upcoming weeks, as it is one of the most exciting things in the community this year so far for me.\n","tags":["swift","programming","apple","ArgumentParser"]},{"id":"73bb874542306d222059f5a7d2bc1b28","title":"Understanding Function Builders in Swift","link":"/posts/understanding-function-builders/","content":"WWDC2020 is just around the corner*, and it hasn\u0026rsquo;t been one year since WWDC2019 took place. There is still a lot of ground to cover regarding the new tools and APIs demonstrated then. and In this article we will focus on a feature new to Swift itself: Function Builders.\n*: Maybe. :(\nIf you have been hacking away at SwiftUI, you have probably been wondering how it makes it possible to build great UIs with very nice syntactic sugar. Other than property wrappers, SwiftUI is also possible thanks to Function Builders. In this article, we will briefly mention how SwiftUI uses Function Builders, and later we will create our own function builders that have nothing not do with SwiftUI. This way, it will become evident why Function Builders are really neat, and why they don\u0026rsquo;t have to be strictly tied to SwiftUI.\nUnderstanding Function Builders \u0026ldquo;Function Builder\u0026rdquo; is a very fancy name for something very simple. Function Builders are nothing more and nothing less than syntactic sugar. With function builders, you can create more natural syntax for your code to make it more intuitive and easier to use and understand.\nFunction builders make it easier to build complex objects by providing more natural syntax for their creation.\nIf you have played with SwiftUI, you have most likely used HStack and VStack objects. They are objects though, so how come we can do something like this?:\nHStack { Text(\u0026#34;Hey\u0026#34;) Text(\u0026#34;I\u0026#39;m Andy\u0026#34;) } The answer is that part of HStack\u0026rsquo;s constructor takes a ViewBuilder called content:\ninit(alignment: VerticalAlignment = .center, spacing: CGFloat? = nil, @ViewBuilder content: () -\u0026gt; Content) So when we use the content parameter, we are instructing SwiftUI to create a HStack composed of multiple different views within - a complex view. SwiftUI will later convert it into in an object behind the scenes (a TupleView\u0026lt;View, View\u0026gt;, to be more specific) that it uses internally in order to render it. You can theoretically use SwiftUI without the syntactic sugar provided by Function Builders, but your code would look like a soup of generics in a world with no horizontal limits.\nSwiftUI has multiple objects that work like HStack. Wouldn\u0026rsquo;t it be interesting if we could create our own function builders? To better understand Function Builders and have a better idea of what SwiftUI does behind the scenes with them, we are going to build a few them to get the concept across.\nBuilding Custom Function Builders To create a function builder, you need to declare a struct marked as @_functionBuilder. Next, your struct must have a static method called buildBlock, and this method must take at least one argument of any type. This argument will be what you write inside the curly braces when calling your function builder. In SwiftUI, these are Views. Finally, the buildBlock function can return something to the caller, which can be any type as well.\nA Simple Function Builder In the following example, we are going to create a function builder that takes strings, and returns their lengths. We will later explore how to use it:\n@_functionBuilder struct StringCharacterCounterBuilder { static func buildBlock(_ strings: String...) -\u0026gt; [Int] { return strings.map { $0.count } } } Utilizing Function Builders Now that we have the function builder, the only thing left to do is to use it.\nTo do that, we will create a class with an initializer that takes an argument marked with our function builder:\nclass CharacterCounter { let counterArray: [Int] init(@StringCharacterCounterBuilder _ content: () -\u0026gt; [Int]) { counterArray = content() } func showCounts() { counterArray.forEach { print($0) } } } And finally, we can call our initializer like this:\\\nlet characterCounts = CharacterCounter { \u0026#34;Andy\u0026#34; \u0026#34;Ibanez\u0026#34; \u0026#34;Collects Pullip\u0026#34; } Call the showCounts() to see it contains the content you expect:\ncharacterCounts.showCounts() 4 6 15 Now, I realize this is a very abstract example, but hopefully you can see how function builders are used, and how they work.\nIn short, Function Builders:\nLet you create syntactic sugar to make code easier to understand and make it more intuitive. Transform content and hand it to the caller. Allows us to create neat Domain Specific Languages (DSL), which is what SwiftUI essentially is. The above example was contrived, but if you understood how it works, let\u0026rsquo;s try building something more interesting.\nBuilding a Real Function Builder The previous example was extremely generic and its main purpose was to show how function builders work and the syntax around them. In this section we will explore a real function builder you may want to use in your own projects. We will create function builders to create UIAlertControllers declaratively.\nEasier to Use UIAlertControllers With Function Builders If I had to give an opinion on UIAlertController, is that it is one of the most tedious APIs to use on iOS development. First, you have to create your alert controller, and then you have to create each action item separately, just to add each one of them, one by one, to the alert controller manually. You can make it easier by extending UIAlertController to add a variable amount of actions, but we can make it even easier (and more interesting), if we create a small DSL just to create UIAlertControllers with actions.\nOur end goal will allow us to create UIAlertControllers writing code like this:\nlet alert = AlertController( title: \u0026#34;Delete all data?\u0026#34;, message: \u0026#34;All your data will be deleted!\u0026#34;, style: .alert) { AlertAction { DestructiveTitle(\u0026#34;Yes, Delete it All\u0026#34;) AlertHandler { print(\u0026#34;Deleting all data\u0026#34;) } } AlertAction { DefaultTitle(\u0026#34;Show More Options\u0026#34;) AlertHandler { print(\u0026#34;showing more options\u0026#34;) } } AlertAction { CancelTitle(\u0026#34;No, Don\u0026#39;t Delete Anything\u0026#34;) AlertHandler() } } present(alert.alertController, animated: true) In contrast, building this same UIAlertController in pure UIKit would be longer than it needs to be:\nlet alert = UIAlertController( title: \u0026#34;Delete all data?\u0026#34;, message: \u0026#34;All your data will be deleted!\u0026#34;, preferredStyle: .alert) let deleteAction = UIAlertAction(title: \u0026#34;Yes, Delete it All\u0026#34;, style: .destructive) { (_) in print(\u0026#34;Deleting all data\u0026#34;) } let moreOptionsAction = UIAlertAction(title: \u0026#34;Show More Options\u0026#34;, style: .default) { (_) in print(\u0026#34;Show more options\u0026#34;) } let cancelAction = UIAlertAction(title: \u0026#34;No, Don\u0026#39;t Delete Anything\u0026#34;, style: .cancel, handler: nil) alert.addAction(deleteAction) alert.addAction(moreOptionsAction) alert.addAction(cancelAction) present(alert, animated: true) The former is a more declarative approach, and it\u0026rsquo;s both much quicker and easier to type.\nSupporting Classes We will start by defining a few basic classes. These classes cover the title styles for the alerts, and the action to execute when one of them is tapped.\nThis small protocol definition will be used for the buttons:\nprotocol AlertActionStyleProtocol { var title: String { get } var style: UIAlertAction.Style { get } } struct DefaultTitle: AlertActionStyleProtocol { let title: String let style: UIAlertAction.Style init(_ title: String) { self.title = title self.style = .default } } struct CancelTitle: AlertActionStyleProtocol { let title: String let style: UIAlertAction.Style init(_ title: String) { self.title = title self.style = .cancel } } struct DestructiveTitle: AlertActionStyleProtocol { let title: String let style: UIAlertAction.Style init(_ title: String) { self.title = title self.style = .destructive } } One thing to keep in mind is that, when we write declarative code, we sometimes have to write more code in order to make the end result easier to write. You can probably make this better using inheritance, but I don\u0026rsquo;t think there\u0026rsquo;s a much of a problem doing it this way here.\nThe last independent class we need is the one that will handle the alert:\nstruct AlertHandler { let action: () -\u0026gt; Void init(_ action: @escaping () -\u0026gt; Void = {}) { self.action = action } } Now we can start writing the function builders.\nThe Function Builders The first function builder we will build will allow us to create the UIAlertActions.\n@_functionBuilder struct UIAlertActionBuilder { static func buildBlock ( _ style: AlertActionStyleProtocol, _ alertHandler: AlertHandler ) -\u0026gt; UIAlertAction { return UIAlertAction(title: style.title, style: style.style) { _ in alertHandler.action() } } } The object that will make use of this function builder is the following:\nclass AlertAction { let alertAction: UIAlertAction init(@UIAlertActionBuilder _ content: () -\u0026gt; UIAlertAction) { alertAction = content() } } So far, all the code we have written allows us to create UIAlertActions with this new syntax:\nAlertAction { DestructiveTitle(\u0026#34;Yes, Delete it All\u0026#34;) AlertHandler { print(\u0026#34;Deleting all data\u0026#34;) } } The body of the AlertAction calls the function builder. You can think of each statement as a parameter to the function builder.\nThe last function builder will allow us to create UIAlertActions from UIAlertActions, an we will use that to create the final AlertController:\nstruct AlertControllerBuilder { static func buildBlock(_ actions: AlertAction...) -\u0026gt; [UIAlertAction] { return actions.map { $0.alertAction } } } Finally, the class that will make use of the AlertControllerBuilder will create the UIAlertController:\nclass AlertController { let alertController: UIAlertController init ( title: String, message: String, style: UIAlertController.Style, @AlertControllerBuilder _ content: () -\u0026gt; [UIAlertAction] ) { let alert = UIAlertController( title: title, message: message, preferredStyle: style ) content().forEach { alert.addAction($0) } self.alertController = alert } } You can now use the code in the top of the session to create UIAlertControllers much easier, faster, and with nice declarative syntax.\nI will be curious to see if you have any ideas to improve this. If you play around with this idea and come up with any interesting improvements, please let me know.\nConclusion Swift 5 introduced many fascinating features to Swift. From property wrappers to function builders. If you use them responsibly, you can create DSLs for many tasks no matter how specific, and simplify the use of common APIs along the way.\nI have converted the AlertController into a Swift Package you can add to your own projects. Its name is DeclarativeAlertController, and you can find it here.\n","tags":["swift","programming","apple","function builders","wwdc2019"]},{"id":"77cff9288af1e0018d074a3b68323a00","title":"Finding Related Words with NLEmbedding","link":"/posts/using-nlembeddings/","content":"There may be cases in which you need to find related words to others. With the NSLEmbedding class, you can find related strings based on the proximity of their vectors.\nUsing NLEmbedding Using NLEmbedding is very straight forward. A simple task is to get an array of related words, which come as an array of (String, NLDistance) back.\nThe distance between words tells you how \u0026ldquo;related\u0026rdquo; they are\nlet embedding = NLEmbedding.wordEmbedding(for: .english) let foundWords = embedding!.neighbors(for: \u0026#34;family\u0026#34;, maximumCount: 3) print(foundWords) In this example, it will print:\n[(\u0026#34;life\u0026#34;, 0.8834981918334961), (\u0026#34;child\u0026#34;, 0.8971378207206726), (\u0026#34;parent\u0026#34;, 0.8989249467849731)] The shorter the number, the shorter the distance is between your word and the related words. Said another way, if the distance is too small, the smaller the distance, the more related the words are.\nWhat I find interesting is how expansive its vocabulary is. If you pass in the word \u0026quot;anime\u0026quot;, you will get:\n[(\u0026#34;manga\u0026#34;, 0.7037466764450073), (\u0026#34;comic\u0026#34;, 0.9883537888526917), (\u0026#34;fanfic\u0026#34;, 1.0021240711212158)] There\u0026rsquo;s a few more things you can do with this class. You can, for example, find the distance between two words to see how related they are:\nprint(embedding!.distance(between: \u0026#34;house\u0026#34;, and: \u0026#34;potato\u0026#34;)) 1.2890079021453857 There is a version of this method that takes a NLDistanceType, but it doesn\u0026rsquo;t seem to be very useful right now, as this enum only has one value at this time.\nWhat we saw here are some common tasks that can be done with this class. They are likely to cover most of your needs, but feel free to explore the documentation to find more uses for it.\nConclusion NLEmbedding can be used to find \u0026ldquo;related\u0026rdquo; words to each other. You know how google can show alternatives for words related to the ones used in your query? That\u0026rsquo;s the magic of natural language embedding. Use this class if you need to support similar functionality in your apps.\n","tags":["swift","programming","apple","ios","ipados","tvos","watchos","macos","natural language"]},{"id":"a282491d55f2a0d839a517d4fcb1c753","title":"Analyzing Natural Language Text with NLTagger","link":"/posts/analyzing-text-nltagger/","content":"In the past few weeks, we have explored how we can tokenize natural language text and how to recognize the language a natural language text is written in. This week we will continue exploring more natural language APIs provided by the NaturalLanguage framework. We will learn about the NLTagger class, which allows us to to analyze natural language text to find parts of speech, lexical classes, lemma, scripts, and more. This API, introduced in iOS 12, implements machine learning to work, and just like the other NaturalLanguage classes, is very easy to use.\nIntroducing NLTagger NLTagger is the class of the NaturalLanguage framework that allows us to analyze text and find its components. We have explored classes to tokenize text and to detect the language - now it\u0026rsquo;s time to actually do more interesting tasks with the provided text.\nWhen working with NLTagger, you specify the components you are interested in (part of speech, lexical class, etc) by specifying an array of NLTagScheme.\nUsing NLTagger Using NLTagger With Simple Words Define the string you want. Then, create the NLTagger object passing an array of NLTaggerSchemes. In the following example we will define a simple word string, we will analyze all of it, and we are interested in getting its lexical class (The lexical class tells whether the word is a noun, verb, or other grammatical component).\nvar stringToRecognize = \u0026#34;visit\u0026#34; let tagger = NLTagger(tagSchemes: [.lexicalClass]) Then, assign the string you want to analyze to the tagger\u0026rsquo;s string property. Once you do that, you will be able to get the independent tag:\ntagger.string = stringToRecognize let tag = tagger.tag(at: stringToRecognize.startIndex, unit: .word, scheme: .lexicalClass) We are getting the tag of a .word unit. In this case, the tag is of type otherWord, because there is not enough context to deduce its lexical class. If you change the word to use the string \u0026quot;visiting\u0026quot;, then the tag will be verb.\nAs an important aside, you shouldn\u0026rsquo;t this class in a multithreaded environment.\nUsing NLTagger with Longer Text We talked about identifying single words, but in a real-world case you are more interested in analyzing longer strings of natural language text. We saw how we could iterate over all the tokens when using NLTokenizer, and the good news is that we can do something very similar with NLTagger.\nAfter you define your string, define the range you want to analyze. You can then use NLTaggers enumerateTags(in:unit:scheme) to go through all of the words:\nvar stringToRecognize = \u0026#34;I will visit you tonight. The house is empty.\u0026#34; let range = stringToRecognize.startIndex ..\u0026lt; stringToRecognize.endIndex let tagger = NLTagger(tagSchemes: [.lexicalClass]) tagger.string = stringToRecognize tagger.enumerateTags(in: range, unit: .word, scheme: .lexicalClass) { (tag, range) -\u0026gt; Bool in print(\u0026#34;Word [\\(stringToRecognize[range])] : \\(tag!.rawValue)\u0026#34;) return true } This will print something like this:\nWord [I] : Pronoun Word [ ] : Whitespace Word [will] : Verb Word [ ] : Whitespace Word [visit] : Verb Word [ ] : Whitespace Word [you] : Pronoun Word [ ] : Whitespace // .... When it comes to the English language, the whitespace might just be noise and you may not care about it. So we can configure the tagger from excluding some elements:\nlet options: NLTagger.Options = [.omitPunctuation, .omitWhitespace, .joinNames] let tagger = NLTagger(tagSchemes: [.lexicalClass]) tagger.enumerateTags(in: range, unit: .word, scheme: .lexicalClass, options: options) { (tag, range) -\u0026gt; Bool in print(\u0026#34;Word [\\(stringToRecognize[range])] : \\(tag!.rawValue)\u0026#34;) return true } This will correctly ignore all the whitespace characters.\nWord [I] : Pronoun Word [will] : Verb Word [visit] : Verb Word [you] : Pronoun Word [tonight] : Noun Word [.] : SentenceTerminator Word [The] : Determiner Word [house] : Noun Word [is] : Verb Word [empty] : Adjective Word [.] : SentenceTerminator Working with Constrains Now all languages may support the same tag schemes, so it may be important to know what schemes are supported in certain scenarios. For this, NLTagger has a availableTagSchemes(for:language:) class method.\nThe following example shows you all the possible tag schemes for English and Japanese:\nlet enSchemes = NLTagger.availableTagSchemes(for: .word, language: .english) print(\u0026#34;English\u0026#34;) print(enSchemes.map ({ $0.rawValue })) let jpSchemes = NLTagger.availableTagSchemes(for: .word, language: .japanese) print(\u0026#34;Japanese\u0026#34;) print(jpSchemes.map ({ $0.rawValue })) English [\u0026#34;Language\u0026#34;, \u0026#34;Script\u0026#34;, \u0026#34;TokenType\u0026#34;, \u0026#34;NameType\u0026#34;, \u0026#34;LexicalClass\u0026#34;, \u0026#34;NameTypeOrLexicalClass\u0026#34;, \u0026#34;Lemma\u0026#34;] Japanese [\u0026#34;Language\u0026#34;, \u0026#34;Script\u0026#34;, \u0026#34;TokenType\u0026#34;] Utilizing NLTagger to Perform Sentiment Analysis One interesting feature of NLTagger is that it can be used to perform sentiment analysis. If you are not familiar with this term, sentiment analysis is the application of machine learning to learn whether a piece of text can be considered \u0026ldquo;positive\u0026rdquo; or \u0026ldquo;negative\u0026rdquo;. You can think of it whether a text speaks positively or negatively about something.\nTo perform sentiment analysis, you need to use the .paragraph unit, and you must also use the .sentimentScore tag scheme. Other than that, its use is pretty straightforward:\nvar stringToRecognize = \u0026#34;Andy Ibanez is awesome\u0026#34; let tagger = NLTagger(tagSchemes: [.sentimentScore]) tagger.string = stringToRecognize let (sentimentScoreTag, _) = tagger.tag(at: stringToRecognize.startIndex, unit: .paragraph, scheme: .sentimentScore) let sentimentScore = sentimentScoreTag?.rawValue ?? \u0026#34;0\u0026#34; print(\u0026#34;Score: \\(sentimentScore)\u0026#34;) 0.6 The sentiment analysis has a score from -1.0 for negative to 1.0 for positive.\nSentiment Analysis is available on iOS 13 and later.\nConclusion NLTagger allows you to analyze a piece of natural language text to get its components and understand how a sentence is formed. The analysis can be done in different ways for different languages. We can also perform sentiment analysis on strings starting on iOS 13. NLTagger has many features and it\u0026rsquo;s easy to use.\n","tags":["swift","programming","apple","ios","ipados","tvos","watchos","macos","natural language"]},{"id":"5db6930f427dbae9d3ba17b6f1cd9f73","title":"Recognizing the language in a Natural Language Text with NLanguageRecognizer","link":"/posts/recognizing-language-nllanguagerecognizer/","content":"Continuing my trend of writing about language processing, today I want to discuss about identifying the language of a body of text. This is an interesting task we can do thanks, once again, to Apple\u0026rsquo;s investment in APIs linked to machine learning.\nToday we will explore the NLLanguageRecognizer object. Introduced in iOS 12, this class can do a lot of language recognizing, from detecting the \u0026ldquo;dominant language\u0026rdquo; of a string, to all the possible languages.\nIntroducing NLLanguageRecognizer **Important Note!** Don\u0026rsquo;t try to use one instance of this object through multiple threads.\nThis class is actually very easy to use. It has very few methods, and the easiest task to perform is one static method away. You need to import NaturalLanguage to use it.\nQuickly Recognizing a Language in a String. If all you need to do is to quickly recognize a language in a string, you can use the static dominantLanguage(for:) method. This method takes the string to recognize and returns an optional NLLanguage object, which contains the language itself. If the string cannot recognize a language at all, it will be nil.\nvar stringToRecognize = \u0026#34;This is an awesome string.\u0026#34; if let lang = NLLanguageRecognizer.dominantLanguage(for: stringToRecognize) { print(lang.rawValue) // prints \u0026#34;en\u0026#34; } And the fun part is, because the method can return the dominant language, you can mix multiple languages together and it will return the one with most presence.\nvar stringToRecognize = \u0026#34;This is an awesome string. Cuando yo estaba por ah√≠ en las calles decid√≠ preguntar el significado de la vida\u0026#34; if let lang = NLLanguageRecognizer.dominantLanguage(for: stringToRecognize) { print(lang.rawValue) // prints \u0026#34;es\u0026#34; } The above example uses a string with both English and Spanish. Because Spanish is the dominant language, it prints \u0026ldquo;es\u0026rdquo;.\nAdvanced Usage That\u0026rsquo;s probably a bad title, because using the other features o this class is not complicated at all.\nFirst, we can detect all the languages in a string. Although this will not be accurate all the time, an instance of this class offers the languageHypotheses(withMaximum) method, which tries to return all the languages found in a string. The return type is a dictionary of type [NLLanguage: Double]. The double is the probability of each language. The withMaximum parameter is the maximum number of languages to return.\nTo use an instance instead of the static methods of this class, you have to call the processString method, which takes a string and returns nothing. After you call this method, NSLanguageRecognizers will have its dominantLanguage property filled. You will also be able to use languageHypotheses(withMaximum) method. Calling processString is essential to do anything interesting with this class. And like you are able to tell, everything happens in the same thread, so remember not to use one instance concurrently.\nThe following example gets all the possible languages in the string:\nvar stringToRecognize = \u0026#34;This is an awesome string. Cuando yo estaba por ah√≠ en las calles decid√≠ preguntar el significado de la vida\u0026#34; let langRecognizer = NLLanguageRecognizer() langRecognizer.processString(stringToRecognize) for (lang, perc) in langRecognizer.languageHypotheses(withMaximum: 10) { print(\u0026#34;Probability of \\(lang.rawValue): \\(perc)\u0026#34;) } It will output something like the following:\nProbability of de: 0.0011527120368555188 Probability of sk: 0.0013781085144728422 Probability of hu: 0.001778516685590148 Probability of it: 0.003761883592233062 Probability of pt: 0.01308358833193779 Probability of nl: 0.0018757604993879795 Probability of ro: 0.0038427249528467655 Probability of hr: 0.0007617694209329784 Probability of en: 0.09818074852228165 Probability of es: 0.8707313537597656 You should try to give the withMaximum parameter a more reasonable value if you have any idea of what the dominant languages are going to be. We can observe that English and Spanish have the bigger percentages.\nYou can also guide the recognizer by specifying the languageHints and languageConstraints properties. I wasn\u0026rsquo;t able to find much use for languageHints because it takes a dictionary similar to the one returned by languageHypotheses(withMaxium:), but by using languageConstraints you can limit the languages you want to recognize.\nIf we add the following code to the piece of code above\nlangRecognizer.languageConstraints = [.english, .spanish] It will print:\nProbability of es: 0.8986690044403076 Probability of fr: 0.0 Probability of hr: 0.0 Probability of da: 0.0 Probability of en: 0.10133091360330582 Probability of cs: 0.0 Probability of fi: 0.0 Probability of de: 0.0 Probability of hu: 0.0 And it would be good to assign withMaxium to 2 here, as we know we only want to recognize two languages.\nConclusion Recognizing a language in iOS is as easy as using the NLLanguageRecognizer API introduced in iOS 12 and calling a few lines of code. The system will do its best to determine the dominant language or all the possible languages in a string, and you can use this information for natural-language apps.\n","tags":["swift","programming","apple","ios","ipados","tvos","watchos","macos","natural language"]},{"id":"52b3a75773c69eebea92b2f706b986dd","title":"Tokenizing Natural Language into Semantic Units in iOS","link":"/posts/tokenizing-nltokenizer/","content":"Working with Natural Language is possible thanks to machine learning. Starting on iOS 12, Apple has provided many APIs just for this task. In this article we will explore how to use NLTokenizer to separate natural language text into its proper units.\nIntroduction to Natural Language Tokenizing If you are not familiar with the inner workings of Natural Language processing, tokenizing simply means that we separate a string and analyze it to find its semantic units. If you are writing a program that processes text, you may be tempted to split the string using a separator. For example, if you wanted to get all the words in a natural sentence string in an array, you would write something like this:\n\u0026#34;This should be separated into words using the space\u0026#34;.split(separator: \u0026#34; \u0026#34;) And this naive approach may work under very specific constraints. Specifically, you know it will work if the language you are using is English. But languages such as Japanese don\u0026rsquo;t separate their sentences with spaces. So what do you do if you need to support different languages? This is where the tokenizer comes into play.\nUsing NLTokenizer Start by importing the NaturalLanguage framework.\nimport NaturalLanguage To create the NLTokenizer object, call the NLTokenizer(using:) method, to which you have to specify what NLTokenUnit you want to use. At the time of this writing, you can use .document, .paragraph, .sentence, .word. The unit allows you to specify the linguistic unit. If you choose .word, the tokenizer will take every word and give it back to you. As you use the other units, you will get bigger portions of text.\nIn the example below, we will tokenize a simple sentence.\nvar stringToTokenize = \u0026#34;It was many and many a year ago, in a kingdom by the sea.\u0026#34; let tokenizer = NLTokenizer(unit: .sentence) tokenizer.string = stringToTokenize Since we have a single sentence, we will use the .sentence unit, and the first phrase of my favorite poem (Annabel Lee, by Edgar Allan Poe).\nIt\u0026rsquo;s worth noting that you can specify the language to use. By default the system will use your default language, but you can specify a different language. To be more explicitly, I will set the language to English.\ntokenizer.setLanguage(.english) And we can finally go through the words:\ntokenizer.enumerateTokens(in: fullStringRange) { (range, attributes) -\u0026gt; Bool in print(stringToTokenize[range]) return true } The return indicates the enumerator if it should continue going through each token. If you return false, the enumerator will stop.\nThe output for the above code is the following:\nIt was many and many a year ago in a kingdom by the sea Tokenizing Different Languages Some languages don\u0026rsquo;t separate words in a sentence the same way, so it can be expected that they may also separate other words with different symbols. We will now tokenize a Japanese string into words.\nvar stringToTokenize = \u0026#34;ÁßÅ„ÅØÊØéÊó•Â§™„Å£„Å¶„ÅÑ„Åæ„Åô\u0026#34; let tokenizer = NLTokenizer(unit: .word) tokenizer.string = stringToTokenize tokenizer.setLanguage(.japanese) let fullStringRange = stringToTokenize.startIndex..\u0026lt;stringToTokenize.endIndex tokenizer.enumerateTokens(in: fullStringRange) { (range, attributes) -\u0026gt; Bool in print(stringToTokenize[range]) return true } Output:\nÁßÅ „ÅØ ÊØéÊó• Â§™„Å£ „Å¶ „ÅÑ „Åæ„Åô So, even if Japanese is a \u0026ldquo;run-on\u0026rdquo; written language, where there\u0026rsquo;s no visual way to separate words from each other, the tokenizer knows where each word begins and ends.\n**Important Note!** If any point you have troubles with the tokenizer, and the enumeration function doesn\u0026rsquo;t give you anything, try setting the language before the string. For some reason, at least with the NSLanguage being .spanish, I had to set the language first.\nConclusion Separating a string with a token is a common task, but doing it naively will not account for all possible cases. NLTokenizer is very smart as it can process words in many languages and already knows about a lot of special cases. If you are tokenizing strings in natural language, you should use this class instead of trying to do it manually.\n","tags":["swift","programming","apple","ios","ipados","tvos","watchos","macos","natural language"]},{"id":"4eefec7b91adebea8b7eaf57ffe0f062","title":"Matching Natural Language Text for Predefined Data Patterns on Apple's Devices","link":"/posts/matching-nl-nsdatadetector/","content":"iOS has a lot of APIs that deal with natural language detection. One such class is NSDataDetector. This class allows you to match different kinds of data in text, including dates, time, links, and more. This class, actually introduced a very long time ago (in the iOS 4.0 days!) makes it very easy to find this kind of data in strings. In this article we will explore how to use this very old class - whose documentation is Objective-C only at this time - in Swift, and how to do common tasks with it.\nThis class is a subclass of NSRegularExpression, so you can expect it to not be entirely perfect with some data. For example, my country\u0026rsquo;s addresses do not follow any kind of format used in developed countries, so address detection fails for me most of the time.\nThat said you can expect it to work with most data. Phone numbers, URLs, and dates/times are likely to be recognized without an issue.\nFinding Patterns in Natural Language. When you create an instance of this class, you specify what kind of content you want to find. A checking type is a NSTextCheckingResult.CheckingType object, and you can specify more than one at a time.\nIn the below example, we will create a data detector that can find links and dates in a string:\nlet detector = try! NSDataDetector( types: NSTextCheckingResult.CheckingType.link.rawValue | NSTextCheckingResult.CheckingType.date.rawValue ) As we said earlier, this is an Objective-C API that comes from the early iOS days, so it may look a little bit weird (and ugly), but it works.\nWe need to use the rawValues of the types, and we need to or them together. Swift cannot even infer the types, so we need to write quite a bit of verbose code.\nNow we can use the detector to match content in a string.\nWe start by defining the string we want to match in, a few regex matching options, and the range of the string to check in.\nlet string = \u0026#34;Make sure you check out my website andyibanez.com tomorrow at 8 and on Friday\u0026#34; let range = NSRange(0..\u0026lt;string.count) let foundContent = detector.matches( in: string, options: [], range: range) Once again, this being an old API, we need to use the good ol\u0026rsquo; NSRange instead of the Swift\u0026rsquo;s range. Other than that, nothing too bothersome here.\nThat will return an array of NSTextCheckingResults, and you can just iterate over the elements:\nfoundContent.forEach { content in switch content.resultType { case NSTextCheckingResult.CheckingType.link: print(\u0026#34;URL: \\(content.url!)\u0026#34;) case NSTextCheckingResult.CheckingType.date: print(\u0026#34;DATE: \\(content.date!)\u0026#34;) default: break } } There are different result types for different objects. The good news is, that once you know we have a certain type in the switch, we can just force-unwrap the expected element. The code above prints the following in my machine:\\\nURL: http://andyibanez.com DATE: Optional(2020-01-30 12:00:00 +0000) DATE: Optional(2020-01-31 16:00:00 +0000) Dates are in UTC, so you may need to operate on them when you receive them. If your string contains text that can be used to deduce the timezone, you can access the timezone property of NSTextCheckingResult.\nlet string = \u0026#34;Visit me tomorrow at 8 UTC+4\u0026#34; //... case NSTextCheckingResult.CheckingType.date: print(\u0026#34;DATE: \\(content.date!) \\(content.timeZone)\u0026#34;) //... // DATE: 2020-01-30 04:00:00 +0000 Optional(GMT+0400 (fixed)) Note that the link was detected in a very smart way and you didn\u0026rsquo;t even need to specify the protocol.\nConclusion NSDataDetector is an old but still very powerful API. What we saw today is just the type of the iceberg of its features. This object can match other types of content as well. If you are interested, I encourage you to check out the documentation. It has some limitations, but it will for many cases.\n","tags":["swift","programming","apple","ios","ipados","tvos","watchos","macos","natural language"]},{"id":"f0ceed501ffb46881052673e7d2cad19","title":"Recognizing Speech Locally on an iOS Device Using the Speech Framework","link":"/posts/speech-recognition-sfspeechrecognizer/","content":"As iOS becomes more advanced, features that we thought belonged to the long future start becoming more common place in today\u0026rsquo;s software. One such feature is speech recognition, which allows a device to take verbal input from a user, transcribe it into text, and do something with it.\nIn iOS, we can do this using a framework called Speech, and an object called SFSpeechRecognizer. With this class, you can perform all kinds of speech recognition tasks.\nSFSpeechRecognizer supports many languages (far from them all, though), and you can specify which one to use. It also supports different audio inputs of audio to recognize the speech from. So you can choose to recognize speech from a file, or from the device\u0026rsquo;s microphone.\nImplementing SFSpeechRecognizer Initial Setup The Speech framework is one of those tools that require you set a string letting your user know what you are going to recognize the speech for. So in your app\u0026rsquo;s Info.plist, add the key NSSpeechRecognitionUsageDescription of type string, and add a short text describing what you are going to use it for.\nThen we need to actually ask for permission. The following method will request for permission and return the status of the operation:\nSFSpeechRecognizer.requestAuthorization { (status) in switch status { case .notDetermined: print(\u0026#34;Not determined\u0026#34;) case .restricted: print(\u0026#34;Restricted\u0026#34;) case .denied: print(\u0026#34;Denied\u0026#34;) case .authorized: print(\u0026#34;We can recognize speech now.\u0026#34;) @unknown default: print(\u0026#34;Unknown case\u0026#34;) } } You should also check if the speech recognizer is available before you try to use it. For that, instances of SFSpeechRecognizer have a property called isAvailable you can use to quickly check for availability.\nif let speechRecognizer = SFSpeechRecognizer() { if speechRecognizer.isAvailable { // Use the speech recognizer } } There is also a supportsOnDeviceRecognition property. When this is true, the framework will perform on-device speech recognition. When it isn\u0026rsquo;t, it will use the network and send the input to Apple\u0026rsquo;s servers. Make sure you check if this variable if network usage matters.\nOne little annoyance is that, to instantiate this class, you need to check for optionals. SFSpeechRecognizer has two initializers you can use. The default one attempts to construct an object with the device\u0026rsquo;s default language, and if that fails it will try to use the language used for keyboard string recognition. When both conditions fail, it can return nil.\nThe other initializer takes a Locale object. This method can also return nil when you pass a locale that isn\u0026rsquo;t available. To see all the available locales, you can call the supportedLocales() method, which will return a set of locales you can instantiate a SFSpeechRecognizer with.\nWith that out of the way, we can start using SFSpeechRecognizer now.\nRecognizing Speech Speech Recognizing Tasks After you have created a SFSpeechRecognizer object, you instruct it to execute tasks, which are subclasses of SFSpeechRecognitionRequest. At the time of this writing, there\u0026rsquo;s two possible tasks: SFSpeechURLRecognitionRequest, to recognize speech in local files, and SFSpeechAudioBufferRecognitionRequest, which can take a constant input of audio to recognize speech.\nThe SFSpeechRecognitionRequest superclass offers a few interesting properties you can use to configure your tasks. You can force the request to use on-device speech recognition by setting requiresOnDeviceRecognition to true; you can force it to report partial results with shouldReportPartialResults, and you can provide an array of phrases that should be recognize even when they don\u0026rsquo;t exist in the system\u0026rsquo;s vocabulary with contextualStrings. This last one is interesting because you can even make it recognize made-up words. The documentation recommends you keep these to 100 or less.\nRecognizing Speech in Audio Files with SFSpeechURLRecognitionRequest Remember to check if the speech recognizer is actually available.\nif recognizer!.isAvailable { // Use the speech recognizer } Once you know it is, you can start using it.\nWhen you call recognitionTask, you specify a recognition handler. This is an asynchronous operation that will call you back when it has recognized more speech. If you don\u0026rsquo;t want to use completion handlers, you can use a SFSpeechRecognitionTaskDelegate instead.\nUsing this request is very straightforward. All you need to do is to specify the URL to the file in the constructor. You can then configure the recognitionTask with the parameters you need. In our case, we will force it to use on-device speech recognition.\nThen we call the recognitionTask on the your recognizer, and specify a callback for success or error. If you get a correct result you can grab the transcribed results.\nThe below example will recognize text in a generic audio file, and print its contents:\nprivate var recognitionTask: SFSpeechRecognitionTask? func recognizeFromFile() { let fileUrl = // ... URL To file let request = SFSpeechURLRecognitionRequest(url: fileUrl) speechRecognizer?.supportsOnDeviceRecognition = true speechRecognizer?.recognitionTask( with: request, resultHandler: { (result, error) in if let error = error { // handle error } else if let result = result { print(result.bestTranscription.formattedString) } }) } Recognizing Speech in Audio Streams with SFSpeechAudioBufferRecognitionRequest If you need to capture audio from a real time source, such as the user\u0026rsquo;s microphone, you can use this request. It works very similar to SFSpeechURLRecognitionRequest, but you need to explicitly end the recognition by calling the endAudio() method.\nThe following example will recognize speech provided from the device\u0026rsquo;s microphone. Brace yourself, as this code is much longer than the previous one.\nlet speechRecognizer = SFSpeechRecognizer()! var recognitionRequest: SFSpeechAudioBufferRecognitionRequest? var recognitionTask: SFSpeechRecognitionTask? let audioEngine = AVAudioEngine() func startRecording() throws { // Cancel the previous recognition task. recognitionTask?.cancel() recognitionTask = nil // Audio session, to get information from the microphone. let audioSession = AVAudioSession.sharedInstance() try audioSession.setCategory(.record, mode: .measurement, options: .duckOthers) try audioSession.setActive(true, options: .notifyOthersOnDeactivation) let inputNode = audioEngine.inputNode // The AudioBuffer recognitionRequest = SFSpeechAudioBufferRecognitionRequest() recognitionRequest!.shouldReportPartialResults = true // Force speech recognition to be on-device if #available(iOS 13, *) { recognitionRequest!.requiresOnDeviceRecognition = true } // Actually create the recognition task. We need to keep a pointer to it so we can stop it. recognitionTask = speechRecognizer.recognitionTask(with: recognitionRequest!) { result, error in var isFinal = false if let result = result { isFinal = result.isFinal print(\u0026#34;Text \\(result.bestTranscription.formattedString)\u0026#34;) } if error != nil || isFinal { // Stop recognizing speech if there is a problem. audioEngine.stop() inputNode.removeTap(onBus: 0) recognitionRequest = nil recognitionTask = nil } } // Configure the microphone. let recordingFormat = inputNode.outputFormat(forBus: 0) // The buffer size tells us how much data should the microphone record before dumping it into the recognition request. inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { (buffer: AVAudioPCMBuffer, when: AVAudioTime) in recognitionRequest?.append(buffer) } audioEngine.prepare() try audioEngine.start() } (Code provided and adapted from Apple)\nThat code is a bit of a mouthful, because it uses Apple\u0026rsquo;s AVFoundation framework, which is used to get audio and visual input from a device.\nAVFoundation is out of the scope of this article, so we will briefly describe the relevant parts.\nWhen we configure the recognizer, we will use the locale on the user\u0026rsquo;s device. In my case my phone is set to English, so it works on my device. You may need to specify the locale, in case the recognizer does not work with the one specified on your device.\nThe completion handler in the recognition handler will be report back results received from the microphone. Because we set shouldReportPartialResults to true, as you speak, the device will print results on the console before you are done talking. On iOS 13 we will force the device to use on-device speech recognition setting requiresOnDeviceRecognition to true. The speech recognizer will also know when it has finished recognizing, so you can stop the session when you receive that.\nFor the microphone\u0026rsquo;s configuration, we will dump the contents of the buffer every 1024 bytes. Strictly speaking, The Speech Recognizer cannot detect speech in real time. The microphone will dump its recent speech into it when the buffer fills to the size you specified. When we dump the contents of the session, the recognizer will recognize the last text dumped into it (by calling append). If you make the buffer bigger, it may make this process slower, but it will recognize more text which may make it more accurate. But if you make it smaller the recognizer may not be able to keep up. I found 1024 bytes is a good size for this.\nGetting More Data Out of a Recognition Task You can get more data out of the result of a recognition task. This data includes the speaking rate (the number of words spoken per minute) (SFSpeechRecognitionResult.speakingRate); Additionally, the result contains a property called segments, which is an array of SFTranscriptionSegment). Segments contain data about parts of the spoken text, such as the confidence level, which gives us how much a word is likely to match the spoken word. The timestamp and duration properties tell you the position of the segment in the audio stream, and a voiceAnalytics (SFVoiceAnalytics) from which you can get the pitch, jitter, and shimmer. You can build very interesting apps with these properties.\nAdditional Setup Options If you liked what you say, take a look at the documentation. There\u0026rsquo;s some more configuration options you can use, including the queue where recognition handlers should be executed on. You can also provide a defaultTaskHint, which can help the recognizer be slightly more accurate.\nGotchas Keep in mind that not all setups will support on-device speech recognition. The first requirement is to support iOS 13. I haven\u0026rsquo;t found any cases in which the device supports iOS 13 and not on-device speech recognition, but you should always add the proper checks for this in your code.\nAlso remember that not all languages are supported just yet. You should always check if your user\u0026rsquo;s locale matches one of the values provided by SFSpeechRecognizer.supportedLocales().\nYou need to keep your audio duration sessions to one minute at most. Speech recognizing can take a lot of battery, and in the case of not having on-device speech recognition, high network usage. The framework will stop recognizing past the one-minute mark.\nConclusion Despite a few limitations, on-device speech recognition is finally a thing. While this feature is available on iOS 13, previous iOS devices can use speech recognizing, although it will require an internet connection to work. The API is very easy to use, and you have the option to provide different input sources.\n","tags":["swift","programming","apple","ios","ipados","watchOS","iOS13","wwdc2019","speech","speech recognition"]},{"id":"5c9a4204767dde73f90e333b555df5f7","title":"Generating Feedback Haptics with UINotificationFeedbackGenerator","link":"/posts/haptics-with-uinotificationfeedbackgenerator/","content":"A few weeks ago, we talked about how we could play custom haptic feedbacks with CHHapticEngine. We saw how powerful and flexible that class is, letting us create different haptics for any context.\nSometimes though, you want to play simpler haptics to let the user know that something has occurred. The CHHapticEngine class can be overkill, and finding the right parameters to have interaction feedback can be very time consuming.\nThere is a subclass of UIFeedbackGenerator that actually exists since way before we got all the power CHHapticEngine: UINotificationFeedbackGenerator contains pre-made haptics to let users know when an action finished successfully, with an error, or a \u0026ldquo;warning\u0026rdquo; in the context of your app.\nSimpler Haptics with UINotificationFeedbackGenerator In the previous post, we saw how we could configure all the parameters, like the sharpness and intensity. UINotificationFeedbackGenerator, introduced all the way back in iOS 10, is much more simpler than that. In fact, the class has one single method, and that single method can only take three parameters.\nStart by creating a UINotificationFeedbackGenerator:\nlet feedbackGenerator = UINotificationFeedbackGenerator() And then you can use it as so, calling the notificationOccured(notificationType:) method:\nfeedbackGenerator.notificationOccured(.success) And that\u0026rsquo;s it! notificationOccured(notificationType:) takes a UINotificationFeedbackGenerator.FeedbackType enum, which can take one of the following three values:\\\nerror: When an error occurs, it will play a harsh feedback. success: When an operation finishes successfully, it plays a light feedbacl. warning: Feedback in between error and success. It\u0026rsquo;s very easy to add this type of feedback, so I recommend you add it whenever it makes sense in your app to have haptics, whether it is something like saving a file successfully, tweeting something successfully, a network error, and so on.\nConclusion Haptics are a core part of the iOS experience, and implementing them doesn\u0026rsquo;t have to be complicated. If you need a lot of control over your feedbacks, use CHHapticEngine directly. If you need simple feedbacks that respond to user interaction, the UINotificationFeedbackGenerator class is likely to cover your needs.\n","tags":["swift","programming","apple","ios","macos","watchos"]},{"id":"786fc2000116adfc4fdc983c7d01f929","title":"CryptoKit and the Secure Enclave","link":"/posts/cryptokit-secure-enclave/","content":"CryptoKit and the Secure Enclave\nApple\u0026rsquo;s CryptoKit introduced this year is full of amazing features. Not only does it offer very easy to use cryptography, but it also offers an interface to a security feature that Apple introduced less than a decade ago: The Secure Enclave.\nThe Secure Enclave is a hardware feature for helping the system work with cryptographically secure data. In this article, we will build upon our previous CryptoKit knowledge (see the article linked above), and we will also learn what the Secure Enclave is all about.\nThe Secure Enclave Before we dive into writing some code, we need to understand what the Secure Enclave actually is. For some, it is nothing more than a buzzword from the past few years. But for developers and security-conscious people, it is a hardware feature for cryptographic tasks.\nThe Secure Enclave first appeared on the Apple A7 chip, released on the iPhone 5S all the way back to 2013. Ever since then, all new iOS and iPadOS devices support it, and it\u0026rsquo;s even available in MacBooks with a TouchBar. The iPhone 5S is also the first Apple device to support biometric authentication. Coincidence?\nSecure Enclave and Touch ID/Face ID go hand in hand. When you enroll your fingerprint or face for biometric unlock on your device, a mathematical representation of it is stored on the Secure Enclave - an actual photo of your face or your fingerprints themselves are never stored in the Secure Enclave. Your device passcode is also handled by the Secure Enclave.\nThe Secure Enclave runs its own operating system separate from iOS, and iOS never has direct access to the data in the Secure Enclave, or the other way around. Instead, when iOS needs anything from it, it queries it with a question and the Secure Enclave responds with an answer. In other words, when you unlock your phone, iOS takes a reading of your face, generates mathematical representation of it, and it asks the Secure Enclave \u0026ldquo;does this face data matches the one you have?\u0026rdquo; - If the Secure Enclave responds \u0026ldquo;yes\u0026rdquo;, then the phone is unlocked. If it isn\u0026rsquo;t, you see an error. The Secure Enclave does not return the face data to iOS, so iOS itself cannot do the checking. The data in the Secure Enclave is truly secure and it never leaves its cozy place.\nFor us developers, how the Secure Enclave deals with biometrics is not the most exciting part about it, because we cannot query it directly. Even our biometric APIs are constrained and they are fully handled by the system, so we cannot really do much work on top of that. The real exciting thing is that we as developers can leverage the Secure Enclave to encrypt and decrypt information with keys that are specific to a specific setup in a specific device.\nWe can create asymmetric keys directly on the Secure Enclave with both the old Security framework, or through CryptoKit. We cannot create a cryptographic key on some other platform or non-Secure Enclave piece of code and import it into the Secure Enclave later. But we can use CryptoKit to generate a key pair whose private key is stored on the Secure Enclave. This means that we can encrypt data that is only accessible via the device that encrypted it. Because keys created directly on the Secure Enclave cannot be retrieved, you cannot decrypt the info on another device. Moreover, when I say that the keys are specific to that specific setup and device, I mean that the key is specific that installation of iOS. If you do a clean install of your phone, the Secure Enclave is wiped clean. If your users restore a version of your app that had information encrypted by the secure enclave on another device than the original one, that information also becomes inaccessible.\nAt the time of this writing, the Secure Enclave offers 4MB of Flash Storage for keys, and it only supports P256 elliptic curve keys. That said, 4MBs of storage is plenty of storage for a bunch of keys.\nWith all that said, CryptoKit can ask the Secure Enclave to sign data, and to perform key agreement with a set of keys. The API you already know from the previous article doesn\u0026rsquo;t change much when dealing with the Secure Enclave.\nCryptoKit and the Secure Enclave. **Important Note!** The Secure Enclave is only available on physical iOS devices with the A7 chip and later. As such, the code here will not work on the simulator. You need to run it on an iPhone 5S or another iOS/iPadOS device that came after it.\nTo actually interact with the Secure Enclave, CryptoKit offers the SecureEnclave enum. The first thing you may want to do is to check if the Secure Enclave is available in the device your app is running:\nif SecureEnclave.isAvailable { // Secure Enclave is available. } Once you know the Secure Enclave is available, you can start using it. I find it helpful to think of iOS and the Secure Enclave as two different parties who want to share secret information with each other. To do this, each party needs their own public key pair, and then they need to exchange their public keys. Then when they send information to each other, they need to sign it with their private keys and generate a shared secret with each other\u0026rsquo;s public key.\nThe below example will generate two key pairs: One within iOS (nonEnclaveKeys) and one within the Secure Enclave enclaveKeys. As we said before, the enclave only supports P256 keys for now, so we will use that.\nlet enclaveKeys = try! SecureEnclave.P256.KeyAgreement.PrivateKey() You can get the data representation of the private key file and store it in the keychain, or even on a plain file, if you so decide. After all, you need to persist the key if you want to use it again.\nlet dataRepresentation = enclaveKeys.dataRepresentation We are not going to explore all the cryptographic operations you can do with the SecureEnclave - The way you utilize the SecureEnclave is exactly the same as the other common cryptographic operations without using the Enclave, but we have a few other things to discuss.\nThe Data Representation of A Private Key. If you have been paying attention, you may be confused at the fact that you can get a data representation of the private key, which is supposed to be stored on the Secure Enclave. Aren\u0026rsquo;t keys stored on the Secure Enclave supposed to be entirely inaccessible by the device? Why can we get a data representation of a private key stored on the Secure Enclave? What\u0026rsquo;s going on here?\nIf you think about it, you do need a way to get a private key from the Secure Enclave. Otherwise, you would create thousands of one-time keys (surprisingly, was not able to find a way to delete Secure Enclave keys with CryptoKit), and you\u0026rsquo;d need to share a new public key every time you want to share encrypted data with someone.\nIt turns out that, keys you store in the Secure Enclave have a data representation as well as other CryptoKit keys, but in the case of the Secure Enclave keys, they are not the raw keys. Rather, the Secure Enclave gives you an encrypted block that only the Secure Enclave itself can later use to restore the real key. So it all works as you would expect: We have no access to the raw keys on the Secure Enclave, but just a representation of it.\nYou don\u0026rsquo;t have to take my word for it. The documentation states:\nKeys that you store in the Secure Enclave expose a raw representation as well, but in this case the data isn‚Äôt the raw key. Instead, the Secure Enclave exports an encrypted block that only the same Secure Enclave can later use to restore the key.\nIf you have two devices, you can do a little experiment to verify that the rawRepresentation of a Secure Enclave key generated on one device cannot be used on another device.\nGenerate a key pair, save it to disk:\ntry! nonEnclaveKeys.rawRepresentation.write(to: pathToUrl) And on the other device, import this key (you can just enable iTunes File Sharing on a test app), and open it:\nlet keyData = try! Data(contentsOf: pathToFile) let nonEnclavekeys = P256.KeyAgreement.PrivateKey(rawRepresentation: keyData) If you print the data in both the original device and the other device, you will see it is the same. CryptoKit will also have no issue \u0026ldquo;loading\u0026rdquo; the key on the other device.\nBut, the moment you try to use the key on the other device, you will see that it doesn\u0026rsquo;t work. That\u0026rsquo;s because the Secure Enclave on the new device is trying to open the key with its internal keys, and because the encrypted blob was made by another device, it cannot do that.\nUsing CryptoKit with the Secure Enclave ensures that encrypted data created on a device can only be decrypted by the same device, on the same setup. If you do a restore of the device, the data will no longer be accessible.\nCryptoKit, SecureEnclave, and Local Authentication There is one specific API that is not available to non-Secure Enclave keys: We can make private key representations available only after an user has authenticated themselves (with LAContext) and the conditions under which a key will be available (SecAccessControl). For that, SecureEnclave.P256.KeyAgreement.PrivateKey has the following initializer:\ninit(compactRepresentable:accessControl:authenticationContext:) If you are not familiar with these security APIs, LAContext allows you to ask the device to authenticate the user with biometrics (Touch ID or Face ID) or with their password, and SecAccessControl allows you to specify an access control to instruct the system under which conditions should a key be available. These conditions can be that the user should be authenticated first, the app needs a specific password, an specific application password, and more. The usage looks like this:\nimport LocalAuthentication // For LAContext import Security // For SecAccessControl // ... let authContext = LAContext(); let accessControl = SecAccessControlCreateWithFlags( kCFAllocatorDefault, kSecAttrAccessibleWhenUnlockedThisDeviceOnly, [.privateKeyUsage, .userPresence, .biometryCurrentSet], nil )!; let privateKey = try! SecureEnclave.P256.KeyAgreement.PrivateKey( accessControl: accessControl, authenticationContext: authContext) We are creating a private key that will only be available after a user has been authenticated. LAContext will take care of doing the authentication itself.\nThis will return you another raw representation of the private key you can store. To load a key created with conditions, you can use the init(dataRepresentation:authenticationContext:) initializer:\ntry! CryptoKit.SecureEnclave.P256.KeyAgreement.PrivateKey(dataRepresentation: keyData, authenticationContext: context) You only need the context to perform the authentication. The access control is only created at the time you create the key and the key persist under those conditions.\nConclusion In this article, we learned a little bit more CryptoKit by exploring how it can integrate with the Secure Enclave. The Secure Enclave is an area that stores secret information and no information can ever leave it. We also learned how we can use other device features - such as Touch ID and Face ID - to further secure our keys within the Secure Enclave.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","cryptokit","wwdc2019"]},{"id":"9dbfbc14d92fd8a931aa64b0db2de508","title":"Implementing Parametrizable Shortcut Actions for your iOS Apps","link":"/posts/parametrized-shortcuts/","content":"All the way back to 2016, a group of very talented iOS developers released Workflow, a very popular app to let users create actions of different kinds within the system\u0026rsquo;s constraints. You could create and automate different tasks, such as controlling a server via SSH, downloading all the images from a website, and more\u0026hellip; Much, much more.\nApple saw the power of the app and acquired it in March 2017. This was very exciting, but we didn\u0026rsquo;t hear anything from the app since. Until WWDC 2018. Apple revealed a new app: Shortcuts. This app was built on top of Workflow, and as an Apple app, it allowed it to do many things that Workflow just wasn\u0026rsquo;t allowed to do, such as toggling system settings, integrating it with other apps (!!), and it was also natively integrated into Siri.\nThis was in iOS 12, and as the initial release of Shortcuts, it was still very limited. Developers could integrate Shortcuts into their apps, but they were limited and there was no way to parametrize them.\nIn iOS 13, the Shortcuts app is now better than ever. And developers can now create actions that permit users to customize them. This allows them to create powerful shortcuts, with your action serving as a functional organ in them.\n**Note** A Shortcut is made of Actions. A shortcut executes a series of Actions to get to a result. Apps can expose different actions to Siri and the Shortcuts app.\nYou can go beyond want to creating simple shortcuts: you can create conversational Siri actions. This is very cool, because allows Siri to respond differently depending on how the user replies to her queries.\nIn this article, we will create a few actions with parameters to explain how the system works, so you can start writing your own parametrizable actions for your own apps. The sample project we created will be attached at the end of this article.\nThinking About Parametrized Shortcuts. You may be wondering why parametrized shortcuts are useful. Prior to iOS 13, we could get similar behavior to parametrized shortcuts by leveraging the clipboard to move data inside and outside your action.\nWith parametrized shortcuts, you can think of them as if they were functions - the traditional functions you know from the programming world. A function is a black box which takes input (parameters) and produces some output.\nThis way, you can let users pass in variables or results from other actions into your own action, operate on it, and optionally produce an output.\nImplementing Parametrized Shortcuts in Your iOS App. We will create a few parametrized shortcuts that allow you do basic math operations. Along the way, we will modify the shortcuts to show what kind of features you can implement.\nProject Setup The setup is the same as it is in iOS 12, so feel to skip this section if your app already uses the Intents extension.\nTo add these type of shortcuts in your App, you will need to add the Siri capability in your Signing \u0026amp; Capabilities tab of your main app\u0026rsquo;s target. You will also need to add a new Target of type Intents Extension (File -\u0026gt; New -\u0026gt; Target -\u0026gt; Intents Extension). This will also link against the SiriKit framework.\nCreating the Intent Definition File Next, you need to add a intentdefinition file and share it across all your targets. To do this, right-click your project blueprint on the Navigator and select \u0026ldquo;Add New File\u0026rdquo;. Search for \u0026ldquo;SiriKit Intent Definition File\u0026rdquo; and click Next. Finally, on the Inspector, add it to all your Targets.\nif you have done this prior to iOS 13, prepare to see a lot of changes here.\nAn Intent is a definition of something users could want to do. If you want to create an action to let users add two numbers, that action is an Intent. There\u0026rsquo;s a bunch of pre-defined intents provided by the system, such as Messages, Photo Search, and more, but we will not be talking about them today.\nNow that you have created the intentdefinition file, you can start working on your Shortcuts.\nThis file allows you to structure your shortcuts and to create all the custom types involved in their execution. Here, you can define what variables take part of your Actions. You can define the combinations of variables allowed, default values for them, constraints, and more. You structure your actions in Intents, which have variables, and you can configure them as you see fit.\nCreating Intents. Open the intentdefinition, scroll to the bottom, of the left pane, click the \u0026ldquo;+\u0026rdquo; button, and select New Intent.\nWe will create the Intent to add two numbers together.\nFor now, copy the following configuration. I\u0026rsquo;m just showing the configuration for firstNumber, but you need to do the same thing for secondNumber:\nBefore we move on, let\u0026rsquo;s talk about the different configurations each action can take.\nIntents Configuration Basic Configuration and Variable Configuration The Category is a way to classify your action. This helps the system organize the entire actions from across all the apps into categories. We use the Generic Run category here, because it\u0026rsquo;s hard to categorize in a different way.\nThe Title is the title of the action in the Shortcuts app. The Description is a small description of the action. You can write what it does and show short instructions to explain your users how to use it.\nYou can also set a default image, and whether the user should always be asked before running the Shortcut.\nNext, you configure the variables themselves. They are nicely named \u0026ldquo;Parameters\u0026rdquo; in the UI. The user will see the Display Name of the parameter in the Shortcuts Action UI. The Type defines what kind of parameter it is (String, Int, a custom type as an enum, etc). You can also pass in a list of these numbers (so you could create an action that adds all the numbers in a list, for example).\nThe User-Facing option is what allows the user to customize the action in Shortcuts. If you disable this, users cannot supply their own values.\nThe Dynamic Options constraints the variable to a pre defined list of values. The user cannot provide this value if it\u0026rsquo;s checked.\nIn the Relationship section, we can define a Parent Variable. With this variable, you can choose whether to show this variable or not to the user depending on the value of the parent.\nNow that all the configurations starting on Relationship are only accesible if you have the User-Facing box checked.\nThe Input section allows to define the UI and constraints for our values. The configurations here are self-explanatory: In case of Integers, you can decide if you want a textfield or stepper to let your end user interact with your action, or and you can set max, min, and a default value for that particular variable.\nIf you run the app, it will automatically add your Intents to the Shortcuts app. Open the app, create a new Shortcut, and search for your Add Two Numbers action. When you add the action, it will look like this:\nBut we can make it look a little bit prettier and more user friendly.\nShortcuts app Configurations Parameters and Inputs The Input Parameter allows you to define what variable will receive the value outputted from the previous action. There\u0026rsquo;s no way to define more receiving variables at this time, but users can configure variables in the action and pass in more data that way.\nThe Key Parameter will let Siri Suggestions suggest values for the chosen variable.\nThe next section is more interested, as it allows you to define different variable combinations. You can define what kind of combinations should work, so the user has a sense of optional values to configure the action further. Along with the combinations, you can pass in a summary. This summary a user-facing string, and you can customize it as such. You can display variables in this screen, and the UI will show a string with place holders to the user.\nIf you add the string \u0026ldquo;Add firstNumber and secondNumber together\u0026rdquo;, while you write your string, you will get suggestions to add the variables as placeholders. At the end, it will look like this:\nBuilding and running the app will update the Shortcut Action to look like this:\nIn order to actually configure different Supported Combinations, you need to make parameters dependent of others with the Parent Parameter configuration. In our case we need two numbers to add together, so we won\u0026rsquo;t be using different combinations.\nOutputs and Results Before we can write code, we have to finish up the Shortcut Intent Configuration. We have configured the Inputs, so let\u0026rsquo;s deal with the Outputs now.\nBelow the AddNumbers intent, there\u0026rsquo;s a \u0026ldquo;Response\u0026rdquo;. Here you can configure the outputs for your Shortcut. Copy this simple Response output:\nYou can define multiple properties that your Action can output. Give it a Display Name for your user to see, a Type (in our case, an Integer, since we are adding Integers), and whether it\u0026rsquo;s an array of multiple values. On Output choose Addition, and this way our Shortcut can now be chained to other actions from other apps, including system ones.\nImplementing Shortcut Action Logic Now is a good time to add logic to our new action. The idea is to illustrate how parametrized actions work before we talk about more advanced configuration options.\nOpen the ‚ÄåIntentHandler.swift file. You will notice that Apple provides a lot of code for handling message intents as an example. We don\u0026rsquo;t really need all that, so let\u0026rsquo;s simplify the entire content of this class. You can replace the whole file with this:\nclass IntentHandler: INExtension { override func handler(for intent: INIntent) -\u0026gt; Any { return self } } The way I write my handlers is by letting the default IntentHandler class launch my own handlers. Like the name implies, this class handles Shortcuts for you.\nCreate a new file called AddNumbersIntentHandler.swift in your Intents target. I implemented mine as so:\nclass AddNumbersIntentHandler: NSObject, AddNumbersIntentHandling { func handle(intent: AddNumbersIntent, completion: @escaping (AddNumbersIntentResponse) -\u0026gt; Void) { let firstNumber = intent.firstNumber! let secondNumber = intent.secondNumber! let result = NSNumber(value: firstNumber.intValue + secondNumber.intValue) let response = AddNumbersIntentResponse.success(addition: result) completion(response) } func resolveSecondNumber(for intent: AddNumbersIntent, with completion: @escaping (AddNumbersSecondNumberResolutionResult) -\u0026gt; Void) { var result: AddNumbersSecondNumberResolutionResult = .unsupported() defer { completion(result) } if let number = intent.secondNumber?.intValue { result = AddNumbersSecondNumberResolutionResult.success(with: number) } } func resolveFirstNumber(for intent: AddNumbersIntent, with completion: @escaping (AddNumbersFirstNumberResolutionResult) -\u0026gt; Void) { var result: AddNumbersFirstNumberResolutionResult = .unsupported() defer { completion(result) } if let number = intent.secondNumber?.intValue { result = AddNumbersFirstNumberResolutionResult.success(with: number) } } } An explanation of what\u0026rsquo;s going on here is in order.\nSiriKit will automatically create some classes and protocols for you, including a -Handling protocol file, based on the contents of your intent definition file. My intent is called AddNumbers, so Xcode generated AddNumbersIntentHandling for me, and I\u0026rsquo;m implementing its methods. Also, our class is inheriting from NSObject because the -Handling protocol created for us requires it. You could implement the requirements yourself, but you can save yourself the trouble by simply inheriting from NSObject.\nThis protocol requires you implement a few methods. The handle method exists in all -Handling protocols. The other required methods depend on the parameters you define as part of your intent, and they are all about resolving the Parameters. Here, both methods are implemented in the same way and they both check that we do have some integer value in firstNumber and secondNumber. If we don\u0026rsquo;t, we pass in a value to the system. Xcode also generates -Result objects for us, and that\u0026rsquo;s what we use to let the system know about the status of our variables. In general, you can resolve to anything. In our case, we are just resolving to the numbers themselves because that\u0026rsquo;s what we want. You can resolve to different values depending on the needs of your action.\nThe handle function will actually perform our operation: In our case, it will add firstNumber and secondNumber together and return the result back to the system. In the intentdefinition file, we defined that a variable called addition will contain the output of our action - the sum of both numbers, so to pass this result back to the system, we create a new -Response object - also generated by Xcode -, specify it was a success, and pass it the output variable as part of that method call.\nGo back to IntentHandler.swift and replace the body of the handle(for:) method with the following:\nlet addNumbersIntentHandler = AddNumbersIntentHandler() return addNumbersIntentHandler Like we said earlier, you can use this method to return different handlers for different intents. We will do that a little bit later, towards the end of this article.\nRun your Extension now, and create a shortcut that uses your \u0026ldquo;Add Two Numbers\u0026rdquo; action. Give it two numbers, and you will see that it works\u0026hellip; Sort of. Shortcuts is trying to display some UI to the user, but it ends up doing nothing and displaying nothing at all. When you dismiss this UI, Shortcuts will continue executing your action and show you the final result in the native UI.\nThis weird UI is part of the Intents UI framework that was added to your project automatically when you added the Siri capability. Exploring this framework is out of the scope of this article, and we don\u0026rsquo;t even need it. The easiest way to remove it, is to go to the Info.plist file of the Intents UI target, expand NSExtension, expand NSExtensionAttributes, expand IntentsSupported, and finally delete the entry that has your custom intent type there. Once you do that, when you build and run your action again, Shortcuts will no longer try to open the Intents UI.\nAnd that\u0026rsquo;s great. You have now created a new action that can take input, produce and output, and that it can work inside a chain of other actions from other apps is it can receive data from anyone, and produce an output that can be received by anyone.\nUsing Enums to Make Richer Parametrizable Actions What we did so far allows us to create very interesting actions for our apps. But we can add more features to make them friendlier for our users.\nSuppose you want to add a new action to subtract two numbers. Your first thought may be to just duplicate the \u0026ldquo;AddNumbers\u0026rdquo; Intent, rename it to \u0026ldquo;SubtractNumbers\u0026rdquo;, and implement a new copy-paste version of AddNumbers to add the subtraction method.\nWe can avoid all that code duplication by implementing an enum. An enum you know and love from writing Swift. You can then let the user choose an enum as part of the action\u0026rsquo;s parameters. In this case, we will implement an enum called Operation which will have addition and subtraction.\nStart by once again going to your intentdefinition file, click the \u0026ldquo;+\u0026rdquo; button the same way you created your first intent, and select \u0026ldquo;New Enum\u0026rdquo;. Name it \u0026ldquo;Operation\u0026rdquo;.\nYou can now add simple enum values that represent an addition and subtraction. It\u0026rsquo;s not possible to remove the \u0026ldquo;unknown\u0026rdquo; case. Changing the \u0026ldquo;Display Name\u0026rdquo; will change the string shown to the user. The other options are more specific to Siri, so we will not be changing those at this time.\nAdding addition and subtraction options will make the configuration look like this:\nWe will replace \u0026ldquo;AddNumbers\u0026rdquo; with \u0026ldquo;OperateNumbers\u0026rdquo;, so rename the intent accordingly. Feel free to change the title and description while you are at it.\nNext, we need to add a new parameter that represents the operation we want to do. Add a new parameter and change it\u0026rsquo;s type to Operation, which is the operation we defined just now. Choose the default type to something other than unknown.\nAlso change the \u0026ldquo;Shortcuts app\u0026rdquo; section to take into account the new parameter:\nIf you try to build the project again, you will get a handful of errors. All of them are related to missing symbols. Remember how we mentioned that Xcode automatically generates a lot of protocols and classes based on your intentdefinition file? We have essentially deleted all the previous symbols the moment we chose to rename \u0026ldquo;AddNumbers\u0026rdquo; to \u0026ldquo;OperateNumbers\u0026rdquo;.\nTo solve this, you could rename all the \u0026ldquo;AddNumbers-\u0026rdquo; code to \u0026ldquo;OperateNumbers-\u0026rdquo;. Feel free to do that. I will create a new class and move the content over before deleting the original AddNumbersIntentHandler.swift file.\nI implemented OperateNumbersIntentHandler.swift as such:\nclass OperateNumbersIntentHandler: NSObject, OperateNumbersIntentHandling { func operate(with operation: Operation, firstNumber: Int, secondNumber: Int) -\u0026gt; Int { switch operation { case .addition: return firstNumber + secondNumber case .subtraction: return firstNumber - secondNumber default: fatalError(\u0026#34;Invalid operation\u0026#34;) } } func handle(intent: OperateNumbersIntent, completion: @escaping (OperateNumbersIntentResponse) -\u0026gt; Void) { let opResult = operate(with: intent.operation, firstNumber: intent.firstNumber!.intValue, secondNumber: intent.secondNumber!.intValue) let result = OperateNumbersIntentResponse.success(addition: NSNumber(value: opResult)) completion(result) } func resolveSecondNumber(for intent: OperateNumbersIntent, with completion: @escaping (OperateNumbersSecondNumberResolutionResult) -\u0026gt; Void) { var result: OperateNumbersSecondNumberResolutionResult = .unsupported() defer { completion(result) } if let number = intent.secondNumber?.intValue { result = OperateNumbersSecondNumberResolutionResult.success(with: number) } } func resolveFirstNumber(for intent: OperateNumbersIntent, with completion: @escaping (OperateNumbersFirstNumberResolutionResult) -\u0026gt; Void) { var result: OperateNumbersFirstNumberResolutionResult = .unsupported() defer { completion(result) } if let number = intent.firstNumber?.intValue { result = OperateNumbersFirstNumberResolutionResult.success(with: number) } } func resolveOperation(for intent: OperateNumbersIntent, with completion: @escaping (OperationResolutionResult) -\u0026gt; Void) { var result: OperationResolutionResult = .unsupported() defer { completion(result) } let operation = intent.operation if operation != .unknown { result = .success(with: operation) } } } Everything is essentially the same. The resolveOperation method will check to see that we have a valid operation, and if we don\u0026rsquo;t, we tell the system that it\u0026rsquo;s an unsupported parameter. We also added a new function that will do math based on the operation parameter.\nRun the action again, and this time you have a way to choose an operation. Tapping on the operation will prompt you between Addition and Subtraction.\nProject Download If you don\u0026rsquo;t feel like following the steps above, you can download the completed project here and explore it at your own pace.\nConclusion The Shortcuts app has received a very nice improvement with the introduction of Parameters on iOS 13. In this article we explored how you could implement them in your own apps, by creating a simple Action that allows users to pass in numbers to do some math operation on them. We saw how actions are exactly like functions - black boxes that take input and produce and output - and how developers can leverage them for their users.\n","tags":["swift","programming","apple","ios","ipados","watchOS","iOS13","wwdc2019","shortcuts","siri"]},{"id":"3a0f56cfb409b9e16c6669f24e458a22","title":"Happy New 2020!","link":"/posts/happy-new-years-2020/","content":"I just wanted to take a moment to wish you all a happy new year and to, to those who have been following me, for reading my weekly blog on iOS development since August.\nAs you may know, I originally started blogging in 2011 as a college freshman, mostly writing to document the new things I learned regarding iOS development. I had absolutely no consistency with how often I wrote. And in the timeframe the blog was alive (2011 - pre-August 2019), there were some pretty big gaps between articles - some spanning years.\nSo in August this year, I decided to start this blog from scratch, removing all the old articles except for rewriting a few (you can access my old website\u0026rsquo;s archive with this link), with a commitment to writing weekly. I have been able to keep up with that commitent, and that is thanks to you all who read my articles, share them, comment on them, and criticize them. I wouldn\u0026rsquo;t have the drive the write weekly if it wasn\u0026rsquo;t for you guys.\nSo, once again, a big thank you to you all, and have yourself a great 2020! Hopefully this will be a great year for us. I intend to keep writing this blog, and hopefully to start other similar projects to this one.\nThis year, I want to keep getting involved with the Swift and Apple Developer communities. I have some exciting plans, but I will share them with you in due time.\nI do not have an article this week as I am taking a short break. I\u0026rsquo;ll be back to the regular weekly articles starting on January 8.\nHappy New Year!\n","tags":null},{"id":"20704365c066676592c4788f8e42c17d","title":"Privacy Policy","link":"/privacy-policy/","content":"This website is pretty simple, and so is this privacy policy. Here\u0026rsquo;s what you should know:\nHosting: This site is hosted on GitHub Pages. GitHub may log your IP address or other metadata when you visit. Please refer to GitHub‚Äôs Privacy Policy for details.\nAnalytics: I use Google Analytics to understand how people find and use my content. I don‚Äôt care about tracking individuals, and I don‚Äôt attempt to personally identify anyone. I mostly look at page views, referral sources, and traffic trends.\nStatic Site: This site is built with Hugo, a static site generator. There‚Äôs no dynamic backend or database. To the best of my knowledge, no cookies are being set by me.\nCloudflare: Cloudflare is used for DNS and basic analytics. Like with Google, I use it to get a second opinion on site traffic ‚Äî not to track you.\nTL;DR: I don‚Äôt know who you are, and I don‚Äôt want to. But I‚Äôm very interested in what websites sent you here.\n","tags":null},{"id":"57599cebfb5cc36341dae8c46229f2cf","title":"AIiCloudSync","link":"/projects/aiicloudsync/","content":"GitHub Repository\nAIiCloudSync AIiCloudSync is a simple Package written in Swift to synchronize specific UserDefaults with the iCloud Key Value store (NSUbiquitousKeyValueStore).\nTo use this package, create a single instance of AIiCloudSync, and keep a reference to it. Once you create it, you don\u0026rsquo;t need to worry about it any longer. It will automatically sync changes between iCloud and your local UserDefaults through the lifetime of your application. You can optionally receive notifications when the iCloud Syncs change so you can react accordingly.\nUsage Using AIiCloudSync is as \u0026ldquo;set-and-forget\u0026rdquo; as possible. You create instances for all the User Defaults suite names you want to sync. You can optionally pass in nil if you want to synchronize with the standard User Defaults.\nAdd a property to your app delegate or scene delegate with the following code:\nlet myCustomDefaultsSync = AIiCloudSync(prefix: \u0026#34;sync\u0026#34;, suiteName: \u0026#34;mySuiteName\u0026#34;) // For defaults with a suite name let standardDefaultsSync = AIiCloudSync(prefix: \u0026#34;sync\u0026#34;) // For standard user defaults. AIiCloudSync will only sync the defaults that have the specified prefix.\nNotifications AIiCloudSync can notify you when it receives changes from the iCloud key value store. To receive notifications, you can register to receive AIiCloudSync.didUpdateToLatest notifications from the notification center. When you receive this notification, the dictionary may include a userInfo dictionary with additional information. The framework has a AIiCloudSync.UserInfoKey class with the following static properties to access the user info keys:\nsuiteName: This key will be included and will contain the suiteName of the user defaults that just changed. If you initialized a AIiCloudSync object with no suiteName, this key will not be included. The following snippet shows how you can register for these notifications:\nlet ns = NotificationCenter.default ns.addObserver( forName: AIiCloudSync.didUpdateToLatest, object: nil, queue: nil) { (notification) in // Do something with the notification // If you expect the notification to have a user info dictionary: if let userInfo = notification.userInfo { if let suiteName = userInfo[AIiCloudSync.UserInfoKeys.suiteName] as? String { print(\u0026#34;Defaults with suite \\(suiteName) did change\u0026#34;) } } } If you don\u0026rsquo;t understand how NSNotificationCenter works, you can read a primer on it here.\nOther Recommendations Avoid having User Default keys that use a dash symbol (-) in their name. Internally, AIiCloudSync uses this symbol for some operations in the sync progress.\nChangelog 1.0.0 Initial release. Credits and Thanks This project is a pure Swift implementation of MKiCloudSync, an Objective-C dependency for syncing User Defaults with the iCloud Ubiquity Store, created by Mugunth Kumar. I created this project because the original code hasn\u0026rsquo;t seen an update in over 5 years, and because my own needs demand I avoid Objective-C as much as possible.\nAdditionally, this version has one more additional feature which lets you specify the UserDefaults to sync with using a suite name. The existing implementation can only use the standard User Defaults. This also allows you to synchronize iCloud defaults with multiple different User Defaults with different suite names.\n","tags":["ios","ipados","open source","swift"]},{"id":"37d2a6d526a2d619655064e4dabe2322","title":"Modern Backgrounds Tasks in iOS 13","link":"/posts/modern-background-tasks-ios13/","content":"In the article from last week, we explored the basic background execution APIs introduced since iOS 7. We explored how we could request additional time for a task to complete after entering the background, how we could defer downloads with URLSession, and how we could use silent push notifications to trigger background tasks.\nThe story with background tasks does not end there. iOS 13 introduced more APIs to do better background tasks, and that allow you to do things that weren\u0026rsquo;t possible before. Apple gave us the new shiny BackgroundTasks framework on WWDC2019. This framework gives developers more flexibility and less constraints to execute code while their apps are in the background. Not only that, but the old Background App Refresh APIs have now been deprecated in favor of a new, modern way to perform them for your app. This changes unifies with the new Background Processing tasks which lets you do more work in the background, while a device is charging, and more.\nIn this article, we will explore the following APIs, all part of the new BackgroundTasks framework:\nThe new BackgroundTasks Framework. Background App Refresh Tasks. Processing tasks. For point 2, we will write a quick example app to show how to adopt BackgroundTasks in your app. If you don\u0026rsquo;t feel like writing such app, it will be included as a download near the end of the article. We won\u0026rsquo;t write an example for processing tasks because the idea is exactly the same, but we will mention some extra properties that task has that can help you create better background tasks.\nThis article is based on the Advances in Background Execution WWDC 2019 talk and in the documentation, but I have taken the liberty to add my own code examples and I have removed content that is not not relevant for the majority of developers (VoIP pushes, etc).\nIntroducing BackgroundTasks BackgroundTasks is a new framework for scheduling background work. Along with it, we get a new background mode for our apps. And to top if off, the framework is available on most of Apple\u0026rsquo;s platforms except for watchOS: iOS, iPadOS, tvOS, and on Catalyst apps on the Mac.\n**Note** The app is available for Catalyst apps, but neither the WWDC session or the documentation mention it for macOS apps (AppKit).\nThe new background mode is called Background Processing Tasks. And starting on iOS 13, the existing Background App Refresh Task has been refined and received some new improvements.\nThe New Background Mode This API is pretty neat, because it can give your app several minutes of runtime, although the constraint of doing so at system-friendly times is still there. This is what allows you to perform deferrable maintenance work, including machine learning tasks such as on-device Core ML training. It also allows you to turn off CPU Monitor for intensive work. This is very interesting, because we can use the full power of the device for as long as it is plugged in. Your app is eligible to run these tasks in the foreground or if your app has been recently used.\nImprovements to Background App Refresh Task If you used the old background app refresh APIs, be aware that there\u0026rsquo;s new API, but the same policies still apply. You get 30 seconds of runtime, and you can keep your app up-to-date throughout the day.\n**Note** The WWDC session does mention you get 30 seconds of runtime, but as I discussed in the previous article on Background Execution, don\u0026rsquo;t rely on this number. You can get the real time left from the app delegate.\nThe eligibility depends on how your user uses your app, so the system will intelligently decide when to execute these tasks. The system will learn the pattern of your users and adapt to it in order to perform them. If your app is used frequently, your tasks will be performed frequently. On the other hand, if your users don\u0026rsquo;t use your app enough, you get less execution time.\nThis new API replaces the old one, so the fetch APIs of UIApplication for background app refresh are deprecated and are not supported on the Mac.\n**Note** The documentation says that the old APIs are not supported \u0026ldquo;on the Mac\u0026rdquo;, but it\u0026rsquo;s established that these APIs do not work on the Mac to begin with, so I\u0026rsquo;m assuming it\u0026rsquo;s saying that the deprecated APIs are not available for Catalyst apps.\nUsing BackgroundTasks Overview of the BackgroundTasks Framework The main API for using this framework is the BGTaskScheduler . This API constantly monitors the system state such as battery level, background usage, and more, so it chooses the optimal time to run your tasks.\nTo use this API, you begin working when your app is on the foreground. You need to create Background task requests. The framework provides an abstract class, BGTask, you never use this task directly. Instead, the framework provides two concrete subclasses you can interact with: BGProcessingTask, for long running and maintenance tasks such backup and cleanup, and BGAppRefreshTask to keep your app up-to-date throughout the day.\nYou don\u0026rsquo;t create instances of these classes directly. Instead, you create BGAppRefreshTaskRequests and BGProcessingTaskRequests and submit them to BGTaskScheduler. When the scheduler wakes up your app to pass the tasks, you will get their BGAppRefreshTask and BGProcessingTask counterparts.\nYou can submit multiple tasks to the scheduler and you can submit both BGAppRefreshTask and BGProcessingTask at the same time. Interestingly enough, it\u0026rsquo;s also possible to submit tasks from an extension. This is useful if, for example, you have a keyboard extension that uses machine learning to learn your users\u0026rsquo; typing patterns.\nThe tasks will not start automatically. When BGTaskScheduler sees that the system meets all the conditions required for a specific task, it will wake up your app in the background, and it will handle it the task from the scheduler. If we get a BGAppRefreshTask, we can fetch content, process it, and update our UI. If we get a BGProcessingTask, we can do some cleanup, backups, or other similar tasks. When the task is finished, we need to mark it as completed, so we can allow the app to suspend.\nDepending on how tasks are configured, and on the system conditions, the system may wake your app and pass it more than one task at the time. The system allocates a finite amount of time to execute these tasks. And it\u0026rsquo;s important to note that the allotted time is per launch, not per task, so you should handle all the tasks concurrently at the same time.\nTasks scheduled by extensions will be handed to the main app. Extensions themselves never handle background tasks, so design your app\u0026rsquo;s data model in a way that the extension data is shared, and not contained within the exension itself.\nAdopting BackgroundTasks in Your Apps From here on out we will play with the new APIs using a sample project. I generally avoid writing full projects for my articles, but I thought it was necessary to do it this time, as it\u0026rsquo;s the only way to see BackgroundTasks in action. So go ahead and create a new Simple View App project on Xcode.\nInitial Setup Before you can use this new framework, you have a tiny-wee bit of setup work to do.\nFirst, you need to edit the Signing \u0026amp; Capabilities of your target and you need to add a new Capability for background tasks. Tap the \u0026ldquo;+\u0026rdquo; sign and search for \u0026ldquo;Background Modes\u0026rdquo;\nThis will add a new section in your app, and you need to tick the ones you are interested in using. For BGAppRefreshTask, enable \u0026ldquo;background fetch\u0026rdquo;, and for BGProcessingTask you need \u0026ldquo;background processing\u0026rdquo;. As you may have guessed, you don\u0026rsquo;t need to use both in an app, and you can pick and choose what you need.\nWe are not quite done yet. Now you need to edit your app\u0026rsquo;s Info.plist and add the Permitted background task scheduler identifiers (BGTaskSchedulerPermittedIdentifiers) key and add the identifiers of the tasks you want your app to perform:\nIt\u0026rsquo;s recommended you use reverse DNS Notation, as third party dependencies may add their own identifiers.\nWe now have all the necessary setup to start playing with this new framework.\nImplementing BackgroundTasks - BGAppRefreshTask The examples here uses the Pok√©API service. Pok√©API is a free web service that provides information on Pok√©mon. It can be used by both casual Pok√©mon fans or hardcore gamers.\nThe app will simply display a Pok√©mon name and its sprite. When we background the app, we will use BGAppRefreshTask to retrieve a new Pok√©mon with a random ID.\nI will only show you how to use BGAppRefreshTask, but rest assured that what applies to this task type, also applies to BGProcessingTask.\n**Note** As much as a weeb as I am, I promise I\u0026rsquo;m not a Pok√©mon fan. I chose this API because it\u0026rsquo;s easy to use and doesn\u0026rsquo;t require any setup.\n(I promise)\nI will show you my code here, so you can build along if you wish. If you don\u0026rsquo;t feel like doing that, I will also provide a download to the finish project near the end of this article.\nFirst, create a new blank project, and create a view-controller similar to this:\nNow we are going to implement a quick manager to get info on a specific Pok√©mon with its ID. We will also add a function to download images, for the Pok√©mon Sprites.\nPok√©mon.swift\nstruct Pokemon: Codable { struct Species: Codable { let name: String } struct Sprites: Codable { let backDefault: URL? let backShiny: URL? let frontDefault: URL? let frontShiny: URL? enum CodingKeys: String, CodingKey { case backDefault = \u0026#34;back_default\u0026#34; case backShiny = \u0026#34;back_shiny\u0026#34; case frontDefault = \u0026#34;front_default\u0026#34; case frontShiny = \u0026#34;front_shiny\u0026#34; } } let species: Species let sprites: Sprites } PokeManager.swift\nclass PokeManager { static let urlSession = URLSession(configuration: .default) static func pokemon(id: Int, completionHandler: @escaping (_ pokemon: Pokemon) -\u0026gt; Void) { let pokeUrl = buildPokemonURL(id: id) let task = urlSession.dataTask(with: pokeUrl) { (data, _, _) in let pokemon = try! JSONDecoder().decode(Pokemon.self, from: data!) DispatchQueue.main.async { completionHandler(pokemon) } } task.resume() } static func downloadImage(url: URL, completionHandler: @escaping (_ image: UIImage) -\u0026gt; Void) { let task = urlSession.dataTask(with: url) { data, _, _ in let image = UIImage(data: data!)! DispatchQueue.main.async { completionHandler(image) } } task.resume() } private static func buildPokemonURL(id: Int) -\u0026gt; URL { var urlComponents = URLComponents() urlComponents.scheme = \u0026#34;https\u0026#34; urlComponents.host = \u0026#34;pokeapi.co\u0026#34; urlComponents.path = \u0026#34;/api/v2/pokemon/\\(id)\u0026#34; return urlComponents.url! } } Now on the view controller for the view you created above, implement fetchPokemon(id: Int) , and call it on viewDidLoad.\noverride func viewDidLoad() { super.viewDidLoad() fetchPokemon(id: 1) } //... func fetchPokemon(id: Int) { PokeManager.pokemon(id: id) { (pokemon) in self.name.text = pokemon.species.name PokeManager.downloadImage(url: pokemon.sprites.backDefault!) { (image) in self.image.image = image } } } Build and run the project, and you will see a nice Bulbasaur:\nWe can now implement the scheduler. When the app is backgrounded, we will grab a random Pok√©mon ID (between 1 and 151 - because I\u0026rsquo;m old and I don\u0026rsquo;t remember many Pok√©mon after the first generation), download it, and display it.\nThat\u0026rsquo;s it for the view controller for now. We need to edit other parts of the app now.\nIn your AppDelegate, import BackgroundTasks.\nimport BackgroundTasks What we need to do now is to register our app to receive BGTasks when the system hands them to the app. You need to call this method once for each identifier specified in ‚ÄåBGTaskSchedulerPermittedIdentifiers in your Info.plist. You can do this in appliation(didFinishLaunchingWithOptions:).\nBGTaskScheduler.shared.register(forTaskWithIdentifier: \u0026#34;com.andyibanez.fetchPokemon\u0026#34;, using: nil) { (task) in // ... } The first parameter takes the task identifier. The second takes a DispatchQueue?, which you can use to synchronize your task with other threads. If you pass in nil, the system will create a concurrent queue for you.\nI will create a new method in the AppDelegate, and the handler from register will call it to start doing a background work:\nfunc handleAppRefreshTask(task: BGAppRefreshTask) { } BGTaskScheduler.shared.register( forTaskWithIdentifier: \u0026#34;com.andyibanez.fetchPokemon\u0026#34;, using: nil) { (task) in self.handleAppRefreshTask(task: task as! BGAppRefreshTask) } The system will give us limited time to execute the task. The first thing we\u0026rsquo;ll do is to cancel all the operations happening in PokeManager when we reach our expiration time:\nfunc handleAppRefreshTask(task: BGAppRefreshTask) { task.expirationHandler = { PokeManager.urlSession.invalidateAndCancel() } } Later, we will also mark the task as completed. This way we are playing nice by the system\u0026rsquo;s rules, and we will be able to get most background time we request.\nBut first, we need to actually schedule a background task. We will schedule the task when the app enters the background.\nIn your app delegate:\nfunc scheduleBackgroundPokemonFetch() { let pokemonFetchTask = BGAppRefreshTaskRequest(identifier: \u0026#34;com.andyibanez.fetchPokemon\u0026#34;) pokemonFetchTask.earliestBeginDate = Date(timeIntervalSinceNow: 60) do { try BGTaskScheduler.shared.submit(pokemonFetchTask) } catch { print(\u0026#34;Unable to submit task: \\(error.localizedDescription)\u0026#34;) } } If you schedule tasks when the app is being launched, you should call BGTaskScheduler.shared.submit on a background thread as it is a blocking API. This is not a concern when sending it to the background.\nAnd then, in your SceneDelegate.swift:\nfunc sceneDidEnterBackground(_ scene: UIScene) { (UIApplication.shared.delegate as! AppDelegate).scheduleBackgroundPokemonFetch() } **Important Note!** In the WWDC talk, the presenter uses applicationDidEnterBackground in the app delegate instead of the Scene Delegate to schedule the background task. applicationDidEnterBackground is the old API for the old lifecycle of apps prior to iOS 13. In iOS 13, I wasn\u0026rsquo;t able to get my app to call that delegate method at all, so I figured I needed to use the scene delegate instead.\nYou might also be wondering why we have the task handling code in the App Delegate and not scene delegate. The reason is the methods in SceneDelegate can get called multiple times throughout the lifecycle of the app. This can only happen in iPadOS as it has multi-window support. We want to register the handler for our tasks only one time during the lifetime of our app. You can probably write all your BackgroundTasks code in the SceneDelegate if you have an iPhone-only app, but I can\u0026rsquo;t say I recommend doing that.\nWe can specify the earliestBeginDate property of the task. This will let us download the data as soon as possible. In the example above, we are scheduling the task 5 seconds after it is backgrounded. This does not guarantee that the task will start at the specified time, but rather that it won\u0026rsquo;t start any sooner than that. If you use the default nil, there will be no start delay.\nYou should not set this property too far into the future. The app may not be called at all if the user never goes back to your app. You should set this limit to one week or less. This recommendation is given in the WWDC talk for this topic.\nWe are almost done. Now we need to go back to handleAppRefreshTask and implementing the Pok√©mon downloading code:\nfunc handleAppRefreshTask(task: BGAppRefreshTask) { task.expirationHandler = { task.setTaskCompleted(success: false) PokeManager.urlSession.invalidateAndCancel() } let randomPoke = (1...151).randomElement() ?? 1 PokeManager.pokemon(id: randomPoke) { (pokemon) in NotificationCenter.default.post(name: .newPokemonFetched, object: self, userInfo: [\u0026#34;pokemon\u0026#34;: pokemon]) task.setTaskCompleted(success: true) } scheduleBackgroundPokemonFetch() } When you schedule a task, it will only be executed once. If you want to keep executing it throughout the day, you simply need to call scheduleBackgroundPokemonFetch again inside handleAppRefreshTask.\nWe are using NotificationCenter to notify the view controller that a new Pok√©mon has been retrieved and that the UI should be updated accordingly, so create a new Notification.Name for that too:\nextension Notification.Name { static let newPokemonFetched = Notification.Name(\u0026#34;com.andyibanez.newPokemonFetched\u0026#34;) } Finally, in the view controller, register for this notification and update the UI when received:\nfunc registerForNotifications() { NotificationCenter.default.addObserver( forName: .newPokemonFetched, object: nil, queue: nil) { (notification) in print(\u0026#34;notification received\u0026#34;) if let uInfo = notification.userInfo, let pokemon = uInfo[\u0026#34;pokemon\u0026#34;] as? Pokemon { self.updateWithPokemon(pokemon) } } } func updateWithPokemon(_ pokemon: Pokemon) { name.text = pokemon.species.name PokeManager.downloadImage(url: pokemon.sprites.backDefault!) { (image) in self.image.image = image } } override func viewDidLoad() { super.viewDidLoad() registerForNotifications() fetchPokemon(id: 1) } And done! Now your app can refresh in the background and each time it does it will show a new Pok√©mon. Exciting!\nTesting Well, this is a bit of a problem, but if you try to run this now, you will come across two problems:\nThis does not work on the simulator at all. You need to run the app on a real device. You have no control over when the task will run. As we said before, earliestBeginDate will not guarantee the app receives an event at that time. You may leave your phone connected to your computer for hours without receiving an event. So what to do? Testing on the simulator is out of the question, but you can force events to happen via the debugger when running the app on a real device.\nBuild and run your app and then background it to schedule the task. Bring the app to the foreground again. Then in Xcode, hit the pause button in the debugger.\nYou can then copy and paste the following commands, replacing \u0026quot;TASK_IDENTIFIER\u0026quot; with your task identifier.\nTo simulate a receiving an event:\ne -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\u0026#34;TASK_IDENTIFIER\u0026#34;] After you press enter, you will see a new Pok√©mon on the screen. Keep doing it to see more Pok√©mon. Let the nostalgia in.\nAnd to force an early termination of a task:\ne -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateExpirationForTaskWithIdentifier:@\u0026#34;TASK_IDENTIFIER\u0026#34;] These are documented here. Needless to say you shouldn\u0026rsquo;t try to call those private methods within your app itself.\nSample Project. You can download the sample project for this app here.\nBGProcessingTask The usage of this task is exactly the same as the other one. But BGProcessingTaskRequests have two additional properties that make it good to use for maintenance and background tasks.\nrequiresNetworkConnectivity: If the task requires internet to work, you can set this property to true. requiresExternalPower: If the task requires the device to be connected to power to work, you can set this property to true. Conclusion BackgroundTasks is a new framework introduced in iOS 13 to offer developers more ways to execute background work. Background task offers two type of classes:\nBGAppRefreshTask: To refresh your app in the background periodically and always have up to date content. BGProcessingTask: To perform possibly longer operations related to mainenance, backup, and cleanup of the app. We can set tasks of this type to execute when our devices are connected to power and/or have internet connection available. The scheduler will decide the best time to wake up your app and hand them the tasks to execute. Be a good citizen and always let the system know when a task has finished running, either successfully or unsuccessfully.\nShort Break Notice\nDespite the fact that the article is ready, I will not be publishing anything on New Years (January 1, 2020). I\u0026rsquo;m taking a short break. For that reason, Jan 1st\u0026rsquo;s article is getting pushed to January 8. Thank you for your understanding!\n","tags":["swift","programming","apple","ios","macos","tvos","watchos","ipados","iOS13","backgroundtasks","wwdc2019"]},{"id":"1d5107c321b91c06246154a420f9fee5","title":"Background Execution on iOS","link":"/posts/background-execution-in-ios/","content":"In the early days of iOS development, developers had no way at all to perform background tasks beyond a very limited constraints of tasks, like music playback. Modern demands go beyond allowing people to play music in your app while they use a different app, and we as developers need to adapt to these changes. VoIP, lengthy networking, and even silent pushes to keep an app updated are very common these days, and fulfilling these demands used to be hard, if not outright impossible.\niOS 7 was the first one to introduce more slightly powerful background execution APIs. In this article, we will explore how to perform background tasks in our apps and how to give our apps additional time to complete a task that was initially started in the foreground, and was later moved to the background before it had time to complete.\nIn particular, we will explore the following use cases.\nGetting additional background execution time when an app is sent to the background. Starting background tasks with silent push notifications. Deferred downloads with Discretionary Background URL Session. This article is based on the Advances in Background Execution WWDC 2019 talk and in the documentation, but I have taken the liberty to add my own code examples and I have removed content that is not not relevant for the majority of developers (VoIP pushes, etc).\n**Note** The original version of this article was supposed to cover the old background tasks APIs introduced since iOS 7 and then the new APIs introduced in iOS 13. The article became much longer than I had originally expected, so I separated the article into two different ones: One article for old but still relevant APIs (this one), and another one for the iOS 13 exclusive APIs (the BackgroundTasks framework).\nFor that reason this article won\u0026rsquo;t cover the new shiny BackgroundTasks. You will have to wait until December 25 (Merry Christmas!) for that one. Sorry about that!\nThe Need for Background Execution What exactly is background execution? Background execution is simply letting the app run code while it\u0026rsquo;s not in the foreground - it\u0026rsquo;s not the app the user is currently using.\nThe app can require background execution if it requests it to the system. If you want to refresh content and have an up-to-date UI for your users when they relaunch your app after a few hours. Chat applications may want to do this, so next time the user launches an app, they can see all their chats updated instead of waiting for the app to do it when they visit the app. The app can also request this to complete some work that started while the app was in the background, like a big network download.\nThe app can also begin background execution when an event takes place in the system. For example, it can be triggered when the user receives a notification, or when the GPS detects the device is in a specific location. In other words, the data needs to respond to some event.\nConsiderations The background execution system still has some considerations that you should really keep in mind before you go forward with this.\nFirst is power. If your app uses too much battery performing background execution, it may be a bad experience for your user. You should let the system know when your tasks finish to become a good player in the Background Execution world. If you allocate 60 seconds for a task and finish it in 40, let the system know and it will become more generous with your requests over time.\nThe second is performance. Multiple apps may be running in the background at a time, and then there\u0026rsquo;s the little bonus that a foreground may also be executing. Be aware that your app is not the only app in your user\u0026rsquo;s devices, and they may have thousands of different apps performing background tasks.\nFinally, there\u0026rsquo;s privacy. You cannot view other background tasks, as it is expected in the Apple fashion.\nYou should adopt background execution keeping all these in factors in mind.\nBackground Execution Use Cases **Note** Like I said above, the original article was supposed to cover both the old and new APIs for background execution. Everything written here is stuff that can be done pre-iOS 13.\nWe can divide the use cases of background execution into different categories. If your app needs to do any of the following, you can adopt this new framework:\nGive additional time to execute a task before the app is suspended. If you start work in the foreground, you can complete it in the background. Triggering background tasks with silent push notifications. Downloading content at a later time with Background URL Session. We will go through each individually, offering code whenever possible.\nGive additional time to execute a task before being suspended. UIApplication has a simple method that can be used for this: beginBackgroundTask(expirationHandler:)\nUIApplication.beginBackgroundTask(expirationHandler:) You should call this method when leaving a task unfinished may cause a bad user experience in your app. You can use it to complete disk writes, finish user-initiated requests, network calls, and tasks similar to that. The expirationHandler is optional, but if you provide it the system will call it before the time expires to give you a chance to end a task gracefully before it had time to complete.\nYou should call this method right before you start your task, and better if you do before the app actually enters the background state.\nEach call to this API should have a matching call to UIApplication.endBackgroundTask(identifier:). Because apps cannot run indefinitely in the background, you can check how much time your app has by checking the backgroundTimeRemaining property of UIApplication.\nYou can call beginBackgroundTask any time, and as many times as you want. Each call will return a unique identifier you can use to identify a task, or \u0026quot;invalid\u0026quot; if the app doesn\u0026rsquo;t support background execution. Don\u0026rsquo;t forget to end your tasks by calling endBackgroundTask with the identifier returned by beginBackgroundTasks.\nYou can get your hands dirty with this. Create a new empty project and put this code inside viewDidAppear in the default view controller:\nlet taskId = UIApplication.shared.beginBackgroundTask { print(\u0026#34;We are about to kill your task\u0026#34;) } print(\u0026#34;The task ID: \\(taskId)\u0026#34;) let _ = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in print(\u0026#34;Executing (\\(UIApplication.shared.backgroundTimeRemaining) seconds remaining)\u0026#34;) } In my tests, while this was running in the foreground, it kept printing Executing (1.7976931348623157e+308 seconds remaining). As soon as I backgrounded it, I saw that the system allocated approximately 30 seconds for the background task:\nExecuting (29.899623215998872 seconds remaining) Executing (28.80678400799661 seconds remaining) Executing (27.900681052997243 seconds remaining) Executing (26.9005714599989 seconds remaining) Executing (25.804284562997054 seconds remaining) Executing (24.80326834999869 seconds remaining) Executing (23.802226524996513 seconds remaining) Executing (22.801737096997385 seconds remaining) Executing (21.900720710000314 seconds remaining) Executing (20.900698297002236 seconds remaining) Executing (19.900725225001224 seconds remaining) Executing (18.900687380999443 seconds remaining) Executing (17.90067362899572 seconds remaining) Executing (16.900717349999468 seconds remaining) Executing (15.853402848995756 seconds remaining) Executing (14.8417572249964 seconds remaining) Executing (13.82555943299667 seconds remaining) Executing (12.816451088998292 seconds remaining) Executing (11.900728770000569 seconds remaining) Executing (10.900756258997717 seconds remaining) Executing (9.816338092998194 seconds remaining) Executing (8.814374344001408 seconds remaining) Executing (7.805837875996076 seconds remaining) Executing (6.803114914997423 seconds remaining) Executing (5.816280047998589 seconds remaining) We are about to kill your task Executing (4.802873692999128 seconds remaining) Executing (3.8997083849972114 seconds remaining) Executing (2.899573540998972 seconds remaining) Executing (1.8968817720015068 seconds remaining) Executing (0.8995601319984416 seconds remaining) Executing (0.0 seconds remaining) In my tests, the expiration handler got called about 5 seconds before the time expired.\nIt\u0026rsquo;s possible the system adjusts this automatically depending on how good of a player you are and how you use background tasks.\nImportant Note!\nWhile my tests say you get around 30 seconds for execution task and the completion handler gets called about 5 seconds before the task expires, you should not rely on these numbers in your app. Don\u0026rsquo;t hard code anything. As a rule of thumb, just try to finish all your work as soon as possible when using beginBackgroundTask, because if the system doesn\u0026rsquo;t adjust to your use case, future iOS versions may change the amount of time you get for executing tasks.\nOf course we want to be good background execution citizens, so we should end the task at some point. For now, we will end the task when we only have 10 or less seconds left.\nlet _ = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in let bgTimeLeft = UIApplication.shared.backgroundTimeRemaining print(\u0026#34;Executing (\\(bgTimeLeft) seconds remaining)\u0026#34;) if bgTimeLeft \u0026lt;= 10 { UIApplication.shared.endBackgroundTask(taskId) } } If you background the app, the app will not print anything else after the available execution time is less than 10. In other words, your expiration handler will not get called when you end the task properly with a few seconds to spare.\nFor reference, here\u0026rsquo;s the whole code I wrote for viewDidAppear:\noverride func viewDidAppear(_ animated: Bool) { super.viewDidAppear(true) let taskId = UIApplication.shared.beginBackgroundTask { print(\u0026#34;We are about to kill your task\u0026#34;) } print(\u0026#34;The task ID: \\(taskId)\u0026#34;) let _ = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { _ in let bgTimeLeft = UIApplication.shared.backgroundTimeRemaining print(\u0026#34;Executing (\\(bgTimeLeft) seconds remaining)\u0026#34;) if bgTimeLeft \u0026lt;= 10 { UIApplication.shared.endBackgroundTask(taskId) } } } Giving additional time to extensions. You can also give extensions additional time before they get suspended by the system, with the following method:\nProcessInfo().performExpiringActivity(withReason:using:) The first parameter is a string you can use for debugging purposes. The second parameter is a handler where you put code you want to execute in the background. The block will give you a boolean telling you if the process is about to be suspended. If the boolean is true, you should take caution to end the task as soon as possible. I wasn\u0026rsquo;t able to find a way to tell how much time you have left to execute a background task with this API.\nThe system will define if it can execute your handler at all. If it can\u0026rsquo;t, it will call it passing it true, forcing you finish everything as soon as possible. If it can execute your task, it will call the handler with false.\nIf the system is executing the handler and needs to suspend it, it will call your handler a second time passing true, so keep in mind that this handler might be called more than once. A rule of thumb is to simply cancel anything your handler is doing when the parameter is true.\nTriggering Background Execution with Notifications Background Pushes are a mechanism to tell devices that new data is available without notifying the user. In other words, they don\u0026rsquo;t display any kind of UI or play a sound.\nTo send a silent push, add the content-available key to 1, and don\u0026rsquo;t include badge, sound, or alert. You must also set apns-priority to 5 and it is highly recommended, but necessary on to watchOS, to set apns-push-type to background,\nThe push will not trigger the download immediately. Instead, the system will intelligently decide the best time to download new content, including factors such as power and performance.\nDownload Content at a Later Time with Discretionary Background URL Session. This is a way to tell the system to defer downloads until a better time. We can provide information to the system for smarter scheduling.\nUsing it is as easy as any other URLSession, but starting on iOS 13, you can set the isDiscretionary property to true.\nlet config = URLSessionConfiguration.background(withIdentifier: \u0026#34;com.andyibanez.pastContent\u0026#34;) config.isDiscretionary = true let session = URLSession(configuration: config) The advantage of this API is that you have finer control over the session, as you can set intervals, the earliest begin date, and more.\nconfig.timeoutIntervalForResource = 24 * 60 * 60 config.timeoutIntervalForRequest = 60 var request = URLRequest(url: URL(string: \u0026#34;google.com\u0026#34;)!) request.addValue(\u0026#34;foo\u0026#34;, forHTTPHeaderField: \u0026#34;bar\u0026#34;) let task = session.downloadTask(with: request) task.earliestBeginDate = Date(timeIntervalSinceNow: 2 * 60 * 60) Conclusion Background execution is a very common task and you can adopt your app to do it. Prior to iOS 13, you could follow three use cases to implement it in your own code:\nGive extra time to a task to finish after it enters the background. Start background tasks upon receiving silent push notifications. Defer long downloads to a discretionary background URL session. The APIs are easy to use, and I encourage you to add them if it makes sense in your use case. In particular, the first point is very useful as you never know when a user may send your app to the background when your app is doing something important.\n","tags":["swift","programming","apple","ios","ipados"]},{"id":"0a57a33a91e67db8bf09f5191558857c","title":"Formatting Relative Dates With RelativeDateTimeFormatter","link":"/posts/formatting-relative-dates-relativedatetimeformatter/","content":"Formatting Relative Dates With RelativeDateTimeFormatter\nA few weeks ago we talked about formatting content with NSFormatter, an abstract class from which multiple formatting classes inherit from to allow you to format different kinds of data in a human-readable form. NSFormatter is not only a class you can inherit from yourself, but as iOS evolves, more formatters will be added to its family. This week, we will explore a new member of this family introduced in iOS 13: RelativeDateTimeFormatter.\nAt the time of this writing, there\u0026rsquo;s no documentation on this yet (this article is being written on Dec 2, 2018, so yeah\u0026hellip;), so I will be happy to explore how to use it with you.\nRelativeDateTimeFormatter VS. Similar Formatter Classes In the article linked above, we already used a formatter that lets you get the relative amount of time between different date times (DateComponentFormatter), so what\u0026rsquo;s the difference with this one?\nRelativeDateFormatter allows you to present your users with date time data in an even friendlier manner, being able to show strings such as \u0026ldquo;tomorrow\u0026rdquo; (instead of \u0026ldquo;1d\u0026rdquo;), \u0026ldquo;yesterday\u0026rdquo; (instead of -1d), and even \u0026ldquo;5 minutes ago\u0026rdquo; or \u0026ldquo;in 10 hours\u0026rdquo;.\nUsing RelativeDateTimeFormatter Basic Formatting Using this new formatter is very easy. It provides three methods which you can use to do the formatting itself:\nlocalizedString(fromTimeInterval:): This takes a TimeInterval and formats the difference between the current time in the user\u0026rsquo;s device and the passed interval[1]. localizedString(for:relativeTo:): You can use this method to get the time difference between two different dates. localizedString(from:): This methods takes a DateComponents object, so you can easily construct objects and check their time difference relative to the current time on the device.[2] Simple Usage: localizedString(fromTimeInterval:) In its simplest form, you can get formatted text out of this formatter with two lines of code. We will use localizedString(fromTimeInterval) to show you how to do this:\nlet relativeDtf = RelativeDateTimeFormatter() relativeDtf.localizedString(fromTimeInterval: 60.0) // \u0026#34;in 1 minute\u0026#34; This simple line will print in 1 minute because internally, the formatter will use the device\u0026rsquo;s time, and it will compare it with the time 60 seconds from now.\nYou can also calculate the time in the past by passing in negative values. If you pass in -60.0 to the function, it will print exactly what you expect:\nrelativeDtf.localizedString(fromTimeInterval: -60.0) // prints \u0026#34;1 minute ago\u0026#34; Simple enough, right?\nDifference between two dates. If you want to calculate the difference between two dates (that do not necessarily involve the device\u0026rsquo;s current time), you can use the localizedString(for:relativeTo:) function.\nI cannot find a case where you want to get two unrelated dates and get a relative formatting between them. For example, I can get the difference between my birthday this year (May 20, 2019) and Christmas (May 25, 2019), but the output does not make any sense, contextually:\nlet andysBday2019 = Date(timeIntervalSince1970: 1558310400.0) let christmas2019 = Date(timeIntervalSince1970: 1577232000.0) let relativeDtf = RelativeDateTimeFormatter() relativeDtf.localizedString(for: andysBday2019, relativeTo: christmas2019) // prints \u0026#34;7 months ago\u0026#34; (Was my birthday really 7 months ago?) You can probably find a use for it.\nInstead, you can use this to calculate the difference between today and another date using Date objects. We will calculate the time between now and Christmas.\nlet relativeDtf = RelativeDateTimeFormatter() relativeDtf.localizedString(for: christmas2019, relativeTo: now) // prints \u0026#34;in 3 weeks\u0026#34; Using this formatter you can get the relative time difference very easily.\nFormatter Configuration The example we saw so far were simple, and they will probably suit the vast majority of your needs. But you can configure the formatter to spell out the difference, to use abbreviations, and more.\nTo do this, simply change the formatter\u0026rsquo;s unitsStyle property to any of the following:\n.abbreviated: 3 min. ago .full: 3 minutes ago .short: 3 min. ago [3] ‚Äå.spellOut: three minutes ago If you want to quickly see what would a difference look like, you can use this code. It will print your dates in each unitStyle.\nlet relativeDtf = RelativeDateTimeFormatter() [ RelativeDateTimeFormatter.UnitsStyle.abbreviated, .full, .short, .spellOut ].forEach { let formatted = relativeDtf.localizedString(for: threeMinutesAgo, relativeTo: now) relativeDtf.unitsStyle = $0 print(formatted) } You can use other formatting options, such as .formattingContext, which lets you specify where in a sentence would the formatted text appear.\nYou can also specify a .dateTimeStyle. If you specify .named, you will get something like \u0026ldquo;tomorrow\u0026rdquo;, whereas if you specify .numeric, you will get \u0026ldquo;in 1 day\u0026rdquo;.\nrelativeDtf.dateTimeStyle = .named relativeDtf.unitsStyle = .abbreviated relativeDtf.localizedString(from: DateComponents(day: 1)) // \u0026#34;tomorrow\u0026#34; relativeDtf.dateTimeStyle = .numeric relativeDtf.unitsStyle = .abbreviated relativeDtf.localizedString(from: DateComponents(day: 1)) // \u0026#34;in 1 day\u0026#34; Conclusion Formatters are powerful, and as time progresses, we will see more and more. In this article we explored the new RelativeDateTimeFormatter in iOS 13 and how to use it, so you can start implementing friendly texts for your relative date-time strings.\nIf you find any inaccuracies (and that includes typos) or problems in this article please tweet at me (@AndyIbanezK) or send me an e-mail to andy[at]andyibanez[dot]com. Thank you for helping me improve the quality of my blog!\nIf there\u0026rsquo;s anything related to Swift, iOS, or another Apple Platform you\u0026rsquo;d like me to cover, feel free to contact me and I will try to cover it in an upcoming article.\nFoot Notes [1]: I actually don\u0026rsquo;t know if formats the date relative to the user\u0026rsquo;s device. The API is not documented, but that\u0026rsquo;s what I have observed.\n[2]: Just like the note above, it\u0026rsquo;s not documented if the formatting occurs relative to the device\u0026rsquo;s time, but my observations point to yes.\n[3]: I looked and looked and couldn\u0026rsquo;t find an input that produced something different. Hopefully the docs will be up soon.\n","tags":["swift","programming","apple","ios","macos","tvos","watchos","ipados","iOS13","nsformatter","relativedatetimeformatter","wwdc2019"]},{"id":"d2256296c613f6c12cc59478559733ca","title":"UserDefaults and Property Wrappers","link":"/posts/nsuserdefaults-property-wrappers/","content":" **Important Note** Soon after I published this article, Christian Tietze wrote a fair criticism of this idea here.\nOnce you understand how property wrappers work, you can use this article to apply it to user defaults. The main idea is that property wrappers allow you to store your values differently and even externally. That said, you may or may not want to implement this in a real app. I recommend you read this article first, and then go back to Christian\u0026rsquo;s to see more downsides of this idea other than the ones I mentioned below.\nLast week we talked about Property Wrappers, what they are, and how they work with Swift. In this article, we will build upon that to write a very nice property wrapper for user settings based on NSUserDefaults.\nBut Why? I don\u0026rsquo;t know about you, but a pattern I see a lot (and I\u0026rsquo;m guilty of doing this myself) is to just wrap all user defaults in a Singleton. This works, but singletons in general are not a pattern everyone is particularly a fan of. Singletons can grow, and it can be a pain to maintain if they have too many properties. How do you logically separate the properties? Does it even make sense to wrap a singleton around everything related to user defaults?\nFor this reason, people have devised different ways to deal with user defaults, and I\u0026rsquo;m going to show you a new one.\nThe Advantages I found more pros than cons when it comes to using wrapped properties for use defaults, including:\nIt\u0026rsquo;s more obvious to see what settings are relevant in different view controllers. In this architecture, we will write a property wrapper for User Defaults, and we will use it for all defaults that come to mind. This way, we can create properties that represent said setting, and then you will know what settings are relevant in different view controllers or other areas of your app. For example, suppose you have an app where you can configure a default locale, calendar type, timezone, if the app should be locked with FaceID when entering the background, and a currency type. Then you have a CalendarViewController where the user can see his configured locale, timezone, and calendar type. Whether the app should lock and currency types are irrelevant here. By treating them as properties, you can put them at the top of the class and the next developer who maintains the code will know what defaults are relevant for that screen: class CalendarViewController: UIViewController { @UserDefault(key: .calendarType) var calendarType: String @UserDefault(key: .timezone) var timezone: String @UserDefault(key: .locale) var locale: String //... } You don\u0026rsquo;t have to maintain very large singleton files for your settings. Instead you just have to write a property wrapper file and never concern yourself with it again. The Disadvantages There is one disadvantage that I was able to find with this method, so if you find a good way to deal with it, let me know, I\u0026rsquo;m more than happy to hear potential ideas for this.\nThere is no easy way to write testable code with this. You can pass in a UserDefaults object to each property, but this is may not be the best idea if you are these wrapped properties in many places.\nProperty Wrappers for User Defaults At the end of this tutorial, we will have two different property wrappers for settings, but you will essentially write them once and do small modifications to them when necessary.\nThe UserDefault Property Wrapper This property wrapper will be used to deal with standard data types supported by UserDefaults. In other words, it will be compatible with Strings, Ints, Bools, Data, and others that work with UserDefaults by default.\nStart by writing this skeleton:\n@propertyWrapper struct UserDefault\u0026lt;T\u0026gt; { } We want it to be generic because user defaults can store many different data types. By making it generic, it can support any data type that user defaults supports.\nThen, we are going to add a few properties, and an enum:\n@propertyWrapper struct UserDefault\u0026lt;T\u0026gt; { enum Key: String { case lockOnExit = \u0026#34;lock_on_exit\u0026#34; case showImages = \u0026#34;show_images\u0026#34; } let userDefaults: UserDefaults let key: Key let defaultValue: T } The Key enum will take keys that will be used to retrieve the data from UserDefaults internally. You can choose to not use this and just pass in the string keys, but I prefer to have an enum because I get autocomplete and it\u0026rsquo;s harder to make mistakes when dealing with defaults.\nAs for the properties, we will inject a UserDefaults object and we will provide one by default when the user does not specify one. The key property holds the key of the default we want to retrieve. Finally, we define a default value to use when the key we provided does not exist in the underlying user defaults.\nNext, implement a simple initializer for the property wrapper. We will force the user to provide a key, but the default value and underlying UserDefaults object are optional:\ninit(userDefaults: UserDefaults = UserDefaults.standard, key: Key, defaultValue: T) { self.userDefaults = userDefaults self.key = key self.defaultValue = defaultValue } Finally, implement the wrappedValue calculated property. This will do the magic of retrieving and saving data to UserDefaults:\nvar wrappedValue: T { get { return userDefaults.object(forKey: key.rawValue) as? T ?? defaultValue } set { userDefaults.set(newValue, forKey: key.rawValue) } } We now have a fully functional property wrapper for standard UserDefault values. For reference, the full implementation is below:\n@propertyWrapper struct UserDefault\u0026lt;T\u0026gt; { enum Key: String { case lockOnExit = \u0026#34;lockOnExit\u0026#34; case showImages = \u0026#34;show_images\u0026#34; } let userDefaults: UserDefaults let key: Key let defaultValue: T init(userDefaults: UserDefaults = UserDefaults.standard, key: Key, defaultValue: T) { self.userDefaults = userDefaults self.key = key self.defaultValue = defaultValue } var wrappedValue: T { get { return userDefaults.object(forKey: key.rawValue) as? T ?? defaultValue } set { userDefaults.set(newValue, forKey: key.rawValue) } } } Using it is very easy:\nclass ImagesViewController: UIViewController { @UserDefault(key: .lockOnExit, defaultValue: true) var maxAttempts @UserDefault(key: .showImages, defaultValue: false) var showImages } Now that you have this class, your user defaults are more obvious and it\u0026rsquo;s easier to know what context they should be used in.\nThe ComplexUserDefault Property Wrapper It\u0026rsquo;s common to store more complex data in UserDefaults, such as complete JSON structures, or just complete objects. To handle these cases, I created another property wrapper called ComplexUserDefault which serializes objects into Data using Codable and persists them that way. There are many ways you could do this, but I found this one was better and more self contained than the alternatives (like using protocols and extensions).\nThis property wrapper looks very similar to the previous one, but with a few changes. First, you cannot specify a default value because I found it doesn\u0026rsquo;t make sense in this case. So this property wrapper can return and store nil values. Then, the wrappedProperty can return nil and it takes care of the serialization and deserialization of values. Finally, the generic value is constrained to objects that conform to Codable.\nThe complete implementation looks like this:\n@propertyWrapper struct ComplexUserDefault\u0026lt;T: Codable\u0026gt; { enum Key: String { case userInfo = \u0026#34;user_info\u0026#34; } let userDefaults: UserDefaults let key: Key init(userDefaults: UserDefaults = UserDefaults.standard, key: Key) { self.userDefaults = userDefaults self.key = key } var wrappedValue: T? { get { guard let data = userDefaults.data(forKey: key.rawValue) else { return nil } let object = try? JSONDecoder().decode(T.self, from: data) return object } set { guard let object = newValue else { return } let data = try? JSONEncoder().encode(object) userDefaults.set(data, forKey: key.rawValue) } } } And to show how it works, let\u0026rsquo;s create a UserInfo object which will be stored in the user_info key:\nstruct UserInfo: Codable { let username: String let email: String let firstName: String let lastName: String } Using it as a property is the same as any other property wrapper:\nclass UserProfile { @ComplexUserDefault(key: .userInfo) var userInfo: UserInfo? } And finally, assigning the property is nothing different:\nlet profile = UserProfile() profile.userInfo = UserInfo(username: \u0026#34;aibanez\u0026#34;, email: \u0026#34;andy@andyibanez.com\u0026#34;, firstName: \u0026#34;Andy\u0026#34;, lastName: \u0026#34;Ibanez\u0026#34;) You now have two property wrappers to deal with your settings in a clean and independent way. You don\u0026rsquo;t have to fight with singletons for your defaults ever again.\nConclusion Property Wrappers are very powerful, and they can help you kill common patterns in favor of something nicer and more contextually aware. Using them for user defaults has a lot of benefits and it helps you write cleaner code, not to mention it can help new programmers in a project get up to speed with how defaults are stored.\n","tags":["swift","property wrappers","programming","apple","ios","macos","tvos","watchos","ipados","wwdc2019"]},{"id":"35a837f61c1d006d6631830ada74e579","title":"Understanding Property Wrappers in Swift","link":"/posts/understanding-property-wrappers-swift/","content":"Swift 5.1 introduced a sleuth of wonderful features, and amongst them, there\u0026rsquo;s one that is essential for SwiftUI: Property Wrappers. Property wrappers are a powerful feature in Swift that allow you to wrap behavior along with properties. This allows us to do some interesting things. If you have seen SwiftUI, you\u0026rsquo;ve seen the @State \u0026ldquo;keyword\u0026rdquo;, and you know that it allows you to modify structs. This is possible thanks to the behavior \u0026ldquo;wrapped\u0026rdquo; within properties marked with it.\nBut @State isn\u0026rsquo;t really a keyword. It\u0026rsquo;s just functionality exposed to us through Property Wrappers, and just like SwiftUI provides @State, @EnvironmentObject, and more, you can create your own property wrappers for your own use, and they can let you, amongst other things, simplify the code you write and get rid of a lot of boilerplate code. Also, the use of property wrappers is not limited to SwiftUI, and you can find uses for them in any context.\nIn fewer words, we can define property wrappers as a layer between how a property is stored and the code that defines a property. 1\nProperty wrappers are useful in any context and you shouldn\u0026rsquo;t constraint yourself in using them only with SwiftUI. In this article we will explore some ideas that can be implemented with property wrappers that can be done without using SwiftUI at all.\nA Gotcha Before we get started, it\u0026rsquo;s worth mentioning that you can only apply one property wrapper to a given property at any given time. You cannot, for example, do something like @State @EnvironmentObject var foo = Foo().\nPlaying with Property Wrappers Implementing Your Own Property Wrappers To implement your own property wrapper, you need to do a few things:\nDeclare a struct that will wrap the property. Mark the struct as a @propertyWrapper before the struct keyword. Implement the var wrappedValue computed variable. You can use get to get the value of the property, and set to set it. With this, you can see that you can let a property wrapper store its value anywhere. To exemplify this, we will write a simple property wrapper that works with Strings and it changes them to uppercase letters.\n@propertyWrapper struct Capitalized { private(set) var text: String = \u0026#34;\u0026#34; var wrappedValue: String { get { return text } set { text = newValue.uppercased() } } } This is a very simple wrapper with a straight forward task, but the complexity can grow depending on what you want to do.\nOur struct Capitalized is our new property wrapper. It will store the string internally in the text property, but this is not a requirement (you could store it in a database, cache, or anywhere else). The wrappedValue property will handle the storage and retrieval for the contents of the property. In this case, when we return the property, we will return the standard property, and when we store it, we will make it an uppercase string. Nothing prevents you from doing it the other way around - storing the string as-is, and returning it as uppercased() -, so feel free to explore and to implement it differently as necessary depending on the context.\nNotice that our text variable needs a default value in this case. If you don\u0026rsquo;t set it, you will have problems compiling the code above.\nUsing Custom Property Wrappers Now that we defined our property wrapper, we can finally apply it to members of a struct or class. To show how to do this, we will create a struct called Name that will store the first and last name of someone, and they will be stored in capital letters only:\nstruct Name { @Capitalized var firstName: String @Capitalized var lastName: String } And now, when you create an object of this type and set its properties, they will be uppercased when you need them:\nvar myName = Name() myName.firstName = \u0026#34;andy\u0026#34; myName.lastName = \u0026#34;ibanez\u0026#34; print(myName.firstName) // prints \u0026#34;ANDY\u0026#34; print(myName.lastName) // prints \u0026#34;IBANEZ\u0026#34; Advanced Usage What we saw above was a very simple wrapper that changes the capitalization of strings. But we can do a few more interesting things with them that open the door to more interesting ideas.\nYou can, for example, pass in parameters to the wrapper property itself. This allows you to configure how the property should behave on the fly.\nAs an example, we will write a new property wrapped, ConfigurableCapitalization, that allows us to specify how a String should be capitalized. We can specify if we want it to be uppercased, lowercased, or capitalized.\n@propertyWrapper struct ConfigurableCapitalization { enum Settings { case uppercased case capitalized case lowercased } private(set) var text: String = \u0026#34;\u0026#34; public let setting: Settings var wrappedValue: String { get { return text } set { switch setting { case .capitalized: text = newValue.capitalized case .lowercased: text = newValue.lowercased() case .uppercased: text = newValue.uppercased() } } } } struct FullName { @ConfigurableCapitalization(setting: .capitalized) var firstName: String @ConfigurableCapitalization(setting: .uppercased) var lastName: String } var myFullName = FullName() myFullName.firstName = \u0026#34;andy\u0026#34; myFullName.lastName = \u0026#34;ibanez\u0026#34; print(myFullName.firstName) // prints \u0026#34;Andy\u0026#34; print(myFullName.lastName) // prints \u0026#34;IBANEZ\u0026#34; First, we create our ConfigurableCapitalization property wrapper, which contains an enum that lets us specify the capitalization of a String. In the setter of the wrappedValue, we instruct the code to store the property in any of the specified capitalization types.\nThen we created a FullName object that will store a firstName as a capitalized string (it will capitalize the first letter of each word), and the last name as an uppercased string.\nFinally, we assign some values to these property and print their values to the see the results.\nProjecting Values from Property Wrappers Property wrappers can expose even more functionality through the use of Projected Values. The projected value is implemented as a property in the property wrapper called projectedValue, and it can be of any type you want. You can use this for many things. In our example, we will simply use it to tell us what Setting it used to capitalize the string.\n@propertyWrapper struct ConfigurableCapitalization { var projectedValue: Settings = .capitalized enum Settings { case uppercased case capitalized case lowercased } private(set) var text: String = \u0026#34;\u0026#34; public let setting: Settings var wrappedValue: String { get { return text } set { switch setting { case .capitalized: text = newValue.capitalized case .lowercased: text = newValue.lowercased() case .uppercased: text = newValue.uppercased() } projectedValue = setting } } } print(myFullName.$firstName) // prints \u0026#34;capitalized\u0026#34; If you are storing your values in a database, you can expose the connector object to do something with it, like flush values, or more.\nThe Downsides Property wrappers are an amazing feature, but they have one downside: They provide too much \u0026ldquo;black magic\u0026rdquo; for someone who is not familiar with them. If you handed a new programmer our FullName struct and instructed them to use it, they may be surprised at what\u0026rsquo;s going on behind the scenes. This can only be solved with proper documentation.\nConclusion Property wrappers are a very interesting Swift feature. While their usage is prominent in SwiftUI, it doesn\u0026rsquo;t have to be. It can be hard to wrap (heh) your head around them at first, but once you take the time to understand them, you can see they offer ways to simplify, reduce boilerplate, or simply wrap a lot of power in a small container.\n","tags":["swift","programming","apple","property wrappers","wwdc2019"]},{"id":"e5dcd0abfb908e5bb992bd18742335ee","title":"Intercepting Network Traffic with mitmproxy","link":"/posts/intercepting-network-mitmproxy/","content":"If you have been programming mobile apps for a while, you must have used a web based API - JSON based or otherwise - and you have had to deal with bugs related to your requests and responses to a web service. You have likely asked yourself why some parsing code is not working as expected, or why a request seems to have an invalid format. Intercepting your own network calls with a proxy can help you find the answer to these questions.\nYou have probably heard about Charles Proxy, a wonderful tool that lets you inspect the network calls of your app to other web services. It also lets you inspect the traffic of other apps. It\u0026rsquo;s an amazing and very easy to use tool that lets you intercept traffic and reverse engineer network calls, both to see how some app works, or to help you debug your own code.\nBut Charles is not the only solution to this problem. It\u0026rsquo;s the most popular one due to its ease of use, but you may not be interested in buying a license. So in this article, we will explore another tool that lets you intercept network calls. mitmproxy is a free and open source command line utility that lets you intercept network traffic that both leaves and enters your device. It has some advanced features like scripting, and in the long run, I find it is the more powerful tool.\nInstallation If you use Homebrew, simply open a Terminal window and type:\nbrew install mitmproxy Followed by the Enter key.\nQuick Introduction mitmproxy is a proxy tool. Its features are spread across three different command line utilities:\nmitmproxy: Interactive man-in-the-middle proxy for HTTP and HTTPS with a console interface. mitmdump: Command line version of mitmproxy. Think tcpdump for HTTP. mitmweb: Web-based interface for mitmproxy. This tool can do a lot. It can intercept network calls for traffic impression, it can replay previous requests, interception SSL certificates are generated on the fly, and more. There\u0026rsquo;s a page on all the features here.\nA Quick Explanation of the Tools Before we start using it, let\u0026rsquo;s talk a few minutes about the three command line tools that make up mitmproxy. This will help you understand when you can use which and the different features they have.\nmitmproxy This tool allows interactive examination and modification of HTTP(S) traffic. All the flows are kept in memory, so this tool was built for taking and manipulating small samples. If you need to do more intense work, use mitmdump instead.\nmitmdump This is a command-line compation to mitmproxy. It behaves very similar to tcpdump, and as such you can view, record, and programatically transform (scripting!) HTTP traffic.\nmitmweb If you don\u0026rsquo;t fancy a command line interface, you can use mitmweb, which provides a web-based interface to mitmproxy which allows you to examine and modify HTTP traffic. It has the same limitations as the mitmproxy tool, so use this if you want to work with small samples of requests as all the flows are stored in memory.\nSetup for iOS Simulators and Physical Devices If you only care about intercepting raw HTTP traffic (not HTTPS), you are set. However in this modern age, the vast, vast majority of APIs and websites are using HTTPS. In fact I have not found a single raw HTTP API in at least 5 years. So if you want to intercept traffic of SSL-apps, you need to do one more step.\nWe now need to install the Certificate in both the simulator and physical device. If we don\u0026rsquo;t, we won\u0026rsquo;t be able to see traffic to HTTPS websites.\n**Important Note!** mitmproxy cannot do anything for network calls that make use of SSL pinning. If you want to reverse engineer an app that is not yours and is using SSL pinning, mitmproxy will not help you. You will still need to jailbreak your phone to find ways to undo the pinning.\niOS Simulator Dealing with the iOS Simulator is a little bit more complicated than preparing physical devices, because simulators have no way to configure their own proxy settings. They use the macOS native proxy settings instead. Essentially, we have to configure our entire computer to use the proxy. If you are scared and are a Charles user, this is exactly how Charles works by default. This implies that all the network traffic in our Mac will appear in mitmproxy. The good news is that we have ways to easily filter out what we don\u0026rsquo;t need.\nOn your Mac, open System Preferences, then go to Network \u0026gt; Advanced \u0026gt; Proxies.\nOn this screen, enable both the Web Proxy (HTTP) and Secure Web Proxy (HTTPS) options. You will need to write mitmproxy\u0026rsquo;s IP address in both. By default, mitmproxy runs on address 0.0.0.0 and port 8080. Once you hit OK and then Apply to save the chances, all the traffic should start going through mitmproxy.\nNow, visit mitm.it. This page allows you to download the certificates and it only works if you set the proxy properly. If you see anything other than the screenshot below, check the proxy settings. You may need to change the IP Address and/or port depending on your settings and other tools you have on your Mac:\nClick the Apple icon and it will download a *.pem file. The page has additional instructions you need to follow to finish the setup:\nDouble-click the PEM file The \u0026ldquo;Keychain Access\u0026rdquo; applications opens Find the new certificate \u0026ldquo;mitmproxy\u0026rdquo; in the list Double-click the \u0026ldquo;mitmproxy\u0026rdquo; entry A dialog window openes up Change \u0026ldquo;Secure Socket Layer (SSL)\u0026rdquo; to \u0026ldquo;Always Trust\u0026rdquo; Close the dialog window (and enter your password if prompted) Done! Now, the proxy is automatically receiving all the requests on your computer. You can view them with any of the tools mentioned above. To make things easier for now, we will use the web client. On a Terminal window, simply write mitmweb followed by Enter. After a few seconds, your default web browser will launch with the mitmweb page, and you will start seeing all the requests and responses from all the applications on your Mac. We will see how the web client works at the end of this article.\nPhysical iOS Devices If you want to intercept calls in physical iOS devices, you need to configure the devices so they use mitmproxy as a proxy server. To do this, first you need to figure out the address of your Mac running mitmproxy on your network. An easy way to do this is to go back to the Network preferences on your Mac:\nNow, follow these steps to finish the configuration of the proxy on your device:\nOpen the Settings.app on your device. Tap Wi-Fi. Tap the \u0026ldquo;i\u0026rdquo; icon in the network name you want to modify. Scroll to the bottom and tap the Configure Proxy cell. Choose Manual. In IP address, write the address of your Mac on your network. On port, write 8080. Leave the \u0026ldquo;Authentication\u0026rdquo; switch off. Launch safari, and navigate to mitm.it. You will see the same page you saw when configuring the simulator. Click the Apple logo to download the certificate. Go back to Settings, and then General \u0026gt; Profile. Image Tap the \u0026ldquo;mitm proxy\u0026rdquo; profile, and tap Install. The system will ask for your passcode. Go back to General, and this time tap About. Scroll down to the Certificate Trust Settings option, and tap it. Enable the switch for mitmproxy. With that done, you can finally start intercepting calls from your actual device.\nSetup Issues. You may come across a few setup issues, depending on the software you have running on your Mac.\nFirst, in my experience, if you have two active network connections on your Mac (I have both Wi-Fi and Ethernet enabled), you may have some problems. You only need to configure mitmproxy in one of them to start intercepting HTTP requests and responses on your local Mac. Ensure you write the right IP address and Port when configuring the proxy, and if that doesn\u0026rsquo;t solve it, try to configure a different IP address and port for mitmproxy (check the docs). If you are running other proxy software or have other software that may be bind to the same address and port as MITM Proxy, you will have issues.\nFor my phone, I was having problems accessing mitm.it. I was connecting to the Mac network that didn\u0026rsquo;t have the proxy configured, so ensure that whatever network you are connecting to has the proxy enabled for mitmproxy. I spent longer fighting this than I care to admit.\nExploring the Requests With all that setup done, you can finally start using mitmproxy to intercept some requests. As I said earlier, I will be using the web client, because it covers the vast majority of my needs.\nOpen a Terminal window and type mitmweb.\nNow you need an app to (maybe your own!) to start seeing the requests of. For this article, I will be intercepting my own Next Anime Episode app.\nWhen you open the web client, you will see the flood of requests for all your computer. Luckily you can use the search filter to filter it down and find what you need. There\u0026rsquo;s many options here, and when you click on the textfield, it will give you a list of options you can use to search. You can write more advanced search queries if you know regex. For now, I know my app just queries graphql.anilist.co, so by writing ~u anilist, I will filter by all the URLs that just have this URL.\nIn this screenshot you can see that now I\u0026rsquo;m only seeing the requests that have anilist as part of the URL.\nYou can check both the Request and Response tabs to view how a request was done and what returned to your device. Also, if you click the little pencil icon, you can modify both the request the device sent and the response it is expeting to suspect. With this feature you can modify calls on the fly to reverse-engineer APIs or to see how APIs you use would expect if you modified certain parameters.\nOther Tips Charles took care of the configuration for you. When you launched it, it automatically setup the System Preferences to use the proxy. mitmproxy cannot currently do that, but in your Mac, if you want to avoid setting up the proxy everytime you need to, I recommend you create two Locations: One called \u0026ldquo;Proxy\u0026rdquo;, and the other called \u0026ldquo;No Proxy\u0026rdquo;. In the Proxy location you can set up the proxy, and you can simply change locations when you need to use it.\nUnfortunately you cannot do this on iOS, but there was no workaround for Charles, either.\nConclusion We didn\u0026rsquo;t explore the full power of mitmproxy in this article, but what you learned should help you add a new tool to your arsenal to debug networking in your apps. mitmproxy is a very powerful tool, and if you are interested in learning all its features, I encourage you to read the docs. That said what you learned in this article is more than enough for most scenarios, and the power to do more is out there.\n","tags":["reverse engineering","apple","ios","ipados","macos","tvos","watchos","proxy","networking"]},{"id":"fe01ef3934dba7d7a416277d67d83a67","title":"New Search APIs in iOS 13","link":"/posts/ios13-new-search-apis/","content":"iOS has always provided interesting search APIs, but they have always been limited and doing the most interesting tasks required you to either write your own implementation or use private APIs.\niOS 13 has provided some very nice improvements to the UI search APIs. In this article we will talk about two of them.\nUISearchBar finally exposes its text field I have been using UISearchController and UISearchBar for a very long time, and I have always found it bizarre that Apple didn\u0026rsquo;t expose its underlying text field property. As of iOS 13, the search bar finally exposes it, in the form of a UISearchTextField object.\nWith this object, you can finally customize the appearance of the search bar. You no longer need to hack away at the view hierarchy with hopes of finding the text field and customizing it there.\nsearchBar.searchTextField.backgroundColor = .blue searchBar.searchTextField.textColor = .white There\u0026rsquo;s still some limitations, like you cannot change the bar style, but this is a very good change, and something developers have been hacking at for years. Been able to change the colors is a great improvements.\nUISearchTextFieldDelegate Along with the text field, there\u0026rsquo;s a new delegate. To tell you the truth, I have no idea what can be done with it. The Documentation only has one method that is not documented.\nSearch Tokens Search Tokens are my absolutely favorite new feature for search in iOS 13. Some native Apple apps like mail have had it for years. While the API has existed for years, it has recently been opened up to developers.\nSearch tokens look like this:\nYou create a search token with the UISearchToken class, and then you add them to the (also recently opened up) searchTextField properly:\nlet purchasesToken = UISearchToken(icon: UIImage(systemName: \u0026#34;tag\u0026#34;), text: \u0026#34;Purchases\u0026#34;) let countryToken = UISearchToken(icon: UIImage(systemName: \u0026#34;flag\u0026#34;), text: \u0026#34;Country\u0026#34;) searchBar.searchTextField.insertToken(purchasesToken, at: 0) searchBar.searchTextField.insertToken(countryToken, at: 0) The searchTextField lets you do more than just adding the tokens. You can change the color of the tokens (thought you cannot change them individually):\nsearchBar.searchTextField.tokenBackgroundColor = .blue You can allow or prevent the user from copying and deleting tokens:\nsearchBar.searchTextField.allowsCopyingTokens = true searchBar.searchTextField.allowsDeletingTokens = true And then there\u0026rsquo;s functions to get the range of one or multiple tokens, their positions, and more, so you can build powerful search features in your app.\nIf you need to get the tokens themselves, the text field has a tokens property which you can access.\nsearchBar.searchTextField.tokens.forEach { // Do something with each search token. } Now here\u0026rsquo;s the bizarre thing: The tokens do not expose their text or image properties. Instead, you need to assign the representedObject property. This object is of type Any?, so you can assign it anything you need. Here we are assigning simple search terms:\npurchasesToken.representedObject = \u0026#34;Purchases\u0026#34; countryToken.representedObject = \u0026#34;Bolivia\u0026#34; And now we can iterate over them:\nsearchBar.searchTextField.tokens.forEach { // Do something with each search token. print($0.representedObject) } Conclusion The new search APIs are really neat in iOS 13. Other than a long-overdue functionality we have been begging for years, we also got a new beautiful tokens API, which allows to build powerful search features for our users in our apps.\n","tags":["swift","programming","apple","ios","ipados","uikit","search","uisearchbar","uisearchtoken","uisearchtextfield","wwdc2019"]},{"id":"4cc3ec5750f700fc168e8883f8cb3a66","title":"TranslateBO","link":"/bolivia/translatebo/","content":"This article is translated to both English and Spanish.\n[ENGLISH]\nHello everyone. A few hours ago, I made a call to all those who speak different languages to translate tweets to different languages. The number of requests and support has been very overwhelming, and I am very positively surprised with it.\nOriginally, we were going to do everything in a Telegram group, but the amount of requests I received to join has been overwhelming! So, this is how we are going to work:\nTelegram Groups We are keeping two Telegram groups. One discussion group, were we discuss how our activities are done, which is located here. The group were we do translation requests is located here.\nIn the second Telegram group, we will send the tweets we want to translate. People interested in it will send the translation, alongside the language. The idea is that you can easily have the tweets in various languages to share them quicker. We are trying to keep organized everything in Google Drive documents, which will become available to the public shortly. I encourage you to read the first messages in the group to understand better how it works, and ask questions in Beta if you have any.\nMass Translation Project We invite you to join the Telegram groups to discuss the activities and request translation for specific tweets. But, we figured we could make it easier for those who have no interest in joining the groups.\nSo do this: When you find an important tweet from a Bolivian source, retweet it with the #TranslateBO and #TraductoresBO hashtags. This way, those of us who are interested in translating will be able to find the tweets very quickly. If you are doing a translation, please try to source the original Spanish source if you have enough space in your tweet.\nTranslation Tactics Every translated tweet should find a way to link back to the source. Twitter is limited to 250 characters, so we understand you may not always have enough space to link back to the source. In that case, please try to link to the source starting a thread.\nOnce again, due to the 250 character limitation, it may be hard to due a full translation of all the tweets. Some languages just have longer words than normal (looking at you, German). Feel free to take some liberties in the translation, as long as the essence and main idea of the Tweet are still there. You will just have to make some Tweets shorter eventually, but it\u0026rsquo;s important the original meaning is still there.\nSharing You can help a lot by just sharing the tweets that have already been translated. Copy and paste the tweet in all your favorite social networks, and share away!\nThis is a Peaceful Project for Democracy We are translating tweets to other languages to show the world the truth about Bolivia. We want to be free.\n[SPANISH]\nHola a todos. Hace unas horas, hice un llamado para la gente que sabe hablar diferentes idiomas para traducir Tweets en otros idiomas. La cantidad de soporte y peticiones para unirse a este proyecto que hemos recibido es, simplemente, muy alto e incre√≠ble\nAl principio, √≠bamos a hacer todo por Telegram pero por la cantidad de solicitudes que hemos recibido, estamos mejorando como van a trabajar las cosas.\nGrupos de Telegram Tenemos dos grupos en Telegram. Uno para discutir el proyecto y otras ideas, que lo pueden ver aqu√≠, y otro donde realizamos solicitudes de traducci√≥n, que est√° aqu√≠.\nEn el segundo grupo, enviaremos Tweets para traducir. Los interesados en traducir algo lo enviar√°n traducido indicando el idioma en el que est√°. La idea es que podamos tener los tweets en varios idiomas y que sean accesibles para compartirlos lo m√°s r√°pido posible. Estamos tratando de organizar m√°s informaci√≥n en un documento de Google Drive, que ser√° puesto el p√∫blico cuando est√© listo. Te recomiendo leer los primeros mensajes de los grupos de Telegram para entender mejor como funciona todo.\nProyecto Masivo de Traducci√≥n Te invitamos a unirte a los grupos de Telegram para discutir las actividades y solicitar traducciones para tweets. Pero, sabemos que no todos quieren bajarse Telegram o que no lo quieren usar por cualquier otro motivo, por lo que queremos que sea f√°cil para esas personas, y que tambi√©n tengan la oportunidad de participar.\nEntones hagan esto: Cuando encuentren un tweet importante de fuente Bolivina, h√°ganle retweet con los hashtags #TranslateBO y #TraductoresBO. De esta manera, los que estamos interesados en traducir podemos encontrar el contenido f√°cilmente. Si est√°s tratando de hacer una traducci√≥n, por favor trata de citar la fuente original, si tienes suficiente espacio en tu tweet.\nT√©cnicas de Traducci√≥n Todos los tweets deben tener un link a su fuente original. Twitter est√° limitado a 250 catacteres, por lo que es posible que no siempre puedas adjuntar la fuente en tu traducci√≥n. En ese caso, ser√≠a buena que pongas la fuente en un hilo.\nUna vez m√°s, por el l√≠mite de caracteres de Twitter, puede ser dificil realizar traducciones enteras de Tweets. Algunos idiomas tienen palabras m√°s largas de lo normal (te estoy mirando a ti, Alem√°n). Tomen libertades en las traducciones, siempre y cuando se mantenga la esencia e idea principal del tweet. Muy probablemente tengas que acortar el largo de tu Tweet, pero es importante mantener el significado original.\nCompartiendo Puedes ayudar un mont√≥n si tan solo compartes los tweets que ya han sido traducidos. Copia y p√°galos a tus redes sociales favoritas!\nEste es un Proyecto Pac√≠fico por la Democracia Estamos traduciendo Tweets en Espa√±ol a otros idiomas para mostrarle al mundo sobre lo que realmente est√° pasando en Bolivia. Queremos ser libres.\n","tags":null},{"id":"2749306f0a522424e238b6d74ac79fae","title":"When CryptoKit is not Enough","link":"/posts/cryptokit-not-enough/","content":"This article is a continuation to my Common Cryptographic Operations with CryptoKit article. If you want to learn how to use CryptoKit, read that one instead, and come to this one when you need a feature not offered by it.\nAs I have been playing with the amazing CryptoKit framework in the past few weeks, I have discovered a few more things that CryptoKit currently doesn\u0026rsquo;t do. This is not generally a bad thing, and I think these limitations are related to what seem to be the goal of the framework:\nDealing with cryptography is hard, and Snej makes a good point in a comment in my previous CryptoKit article: It gives you easy and relatively safe operations without needing to dive deeply into the cryptographic primitives underneath it. This prevents us from writing dangerous apps that could destroy its security with an oversight or wrong settings. Interoperability is not much of a concern (also a good point by Snej) because Apple has a whole ecosystem where all the platforms inside it can interpret and work with content generated by CryptoKit. CryptoKit is open source anyway, so it\u0026rsquo;s not unreasonable to expect other platform providers to port it or adopt its format in the future. Making working with cryptography easier and providing developer with tools to implement it safely seems to be a great general goal for the framework, and for this reason it\u0026rsquo;s missing some features that may be surprising to some. Some may find it surprising, for example, that CryptoKit doesn\u0026rsquo;t support AES-CBC out of the box. Reading Twitter, I found a discussion where Frederic Jacobs says the following regarding AES in CBC mode:\n\u0026ldquo;That call is AES in CBC mode. It is not supported in CryptoKit. AES-CBC does not provide authentication and is hard to use correctly.\nMoving to an authenticated mode of operation such as GCM is recommended.\u0026rdquo; - Frederic Jacobs, in a Tweet\nAES-CBC being hard to use correctly sounds like a very reasonable reason to leave it out of CryptoKit, but AES in CBC mode - along with other cryptographic tools - are very popular elsewhere. So what can we do in this situation? Dropping down to the Security and CommonCrypto frameworks.\nIn this article, we will explore some operations that CryptoKit can\u0026rsquo;t currently do, and what we can do when we need them.\nA Word on Missing Operations. CryptoKit can do the vast majority of operations from specific hashes to applying specific cyphers. CryptoKit basically has all the bases for primitives covered, and most of its limitations seem to be related to missing ciphers and hashes rather than missing features. There is just one missing feature that I consider is a little bit important in some contexts, but it\u0026rsquo;s not hard to implement with the lower level frameworks.\nMissing Algorithms. Missing Hashing Algorithms. CryptoKit by default provides strong hashes (SHA256, SHA385, and SHA512) , and an Insecure container for insecure but insanely popular hashes (SHA1, MD5).\nOn Apple\u0026rsquo;s platforms, you can use a wide array of other hashes too, but unless it is for compatibility reasons, you are never going to end up using them.\nDropping down to CommonCrypto will allow you to calculate MD2, MD4, and SHA224 hashes for any piece of data. It being a lower-level framework, its usage is more verbose than CryptoKit can provide.\nIn the following example, we will calculate a MD2 hash with CommonCrypto. You can use the other hashing algorithms by replacing CC_MD2 with CC_SHA224, CC_MD4, and you can even use the hashes provided by CryptoKit this way with CC_SHA256, CC_SHA512, and more.\nlet data = string.data(using: .utf8)! var digest = [UInt8](repeating: 0, count:Int(CC_SHA1_DIGEST_LENGTH)) data.withUnsafeBytes { _ = CC_MD2($0.baseAddress, CC_LONG(data.count), \u0026amp;digest) } // Digest now has the hash. Leaving the verbosity of the code aside, there\u0026rsquo;s a few other differences compared to how CryptoKit works. First, the usage of references just doesn\u0026rsquo;t exist in CryptoKit\u0026rsquo;s version. Because of this, CryptoKit can just return it to you, whereas the CommonCrypto requires us to define a \u0026ldquo;holder\u0026rdquo; variable where the hash will exist after CC_MD2 returns. Third, the CommonCrypto version will write the hash in a [UInt8] array, and CryptoKit returns a Digest object of the type of the hashing used. For example if you use SHA512.hash(data:), CryptoKit returns a SHA512Digest object. CryptoKit wrap a lot of things for you so you never have to worry about such details.\nThe area where CommonCrypto and CryptoKit are the same is when you need a string representation of the hash. In both CryptoKit you need to manually convert the data (in CryptoKit\u0026rsquo;s case, you have to get the Data out first with withUnsafeBytes, as shown in my previous CryptoKit article linked above) into a string:\nfunc dataToHexString(_ data: Data) -\u0026gt; String { let hexBytes = digest.map { String(format: \u0026#34;%02hhx\u0026#34;, $0) } return hexBytes.joined() } I believe retrieving a textual representation of a hash is a very common operation to do, so I\u0026rsquo;m a bit surprised it\u0026rsquo;s not supported by CryptoKit out of the box. Luckily, getting the data out is very easy. You could write an extension to do this for you in either case.\nWorking with other Encryption Algorithms AES-CBC is just one of the algorithms that CryptoKit doesn\u0026rsquo;t support. There\u0026rsquo;s a few other cyphers and modes that, if you want to use, you will have to once again drop down to CommonCrypto.\nCommonCrypto offers the CCCrypt function to encrypt and decrypt anything. It\u0026rsquo;s just one function, but it has so many parameters it can be intimidating to see it for the first time. Among the bunch of information it takes, there\u0026rsquo;s the algorithm and the mode.\nCommonCrypto can use the following cyphers:\nAES (in both 256 and 128 bits) DES RC2 RC4 3DES CAST Blowfish For the operation modes, I was only able to find references to CBC (which is the default for CommonCrypto) and ECB. Interestingly, I wasn\u0026rsquo;t able to find the GCM mode in CommonCrypto. According to the first comment in this StackOverflow question, Apple will no longer develop CommonCrypto, which makes me think AES-GCM was exclusively implemented in CryptoKit for the first time. I cannot confirm or deny that Apple will no longer develop CommonCrypto.\nGiving an example for this is redundant because this is one area that has been covered by other people. One such example is here, where it implements AES256 in CBC mode.\nMissing Public-Key Cryptography The Security framework can generate RSA keys. Many applications still use RSA, so if you ever need it, you can drop down to Security to implement it.\nThis StackOverflow Answer has a complete example to generate a RSA key-pair using Swift.\nOther than RSA, you can also generate ECDSA and EC key-pairs with the same framework.\nCryptographically Secure Data and Key Derivation Generating Cryptographically Secure Random Bytes When I started working on the framework for an upcoming crypto app, I noticed that there\u0026rsquo;s no way to generate a bunch of cryptographically secure random bytes with CryptoKit.\nIf you need to do this, you can drop down to the Security framework again. If you need to generate random salts or other kind of cryptographically secure data, you can use a function that looks like this:\n/// Returns cryptographically secure random data. /// /// - Parameter length: Length of the data in bytes. /// - Returns: Generated data of the specified length. func randomData(length: Int) -\u0026gt; Data { var data = Data(count: length) _ = data.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, length, $0.baseAddress!) } return data } This function will generate a random blob of data of the specified size for you. CryptoKit can handle a lot of data that is supposed to be random for you - It can automatically generate nonces when you are using the symmetric cyphers like ChaChaPoly or AES-GCM, but you still need to generate your own salts for some operations like when doing key agreement, and SecRandomCopyBytes is a good way of doing it.\nKey Derivation I wasn\u0026rsquo;t able to find a way to do key derivation with CryptoKit. If you write an app and expect users to provide their own password, you shouldn\u0026rsquo;t use their password for the cryptographic operations directly. Instead, you should derive a cryptographically secure key using the user\u0026rsquo;s password and use that key to encrypt and decrypt instead.\nCommonCrypto offers the CCKeyDerivationPBKDF function which you can use to derive a key based on a password.\nTo derive a password using PBKDF2, you can use a function like this:\nfunc pbkdf2(hash: CCPBKDFAlgorithm, password: String, salt: Data, keyByteCount: Int, rounds: Int) -\u0026gt; Data? { guard let passwordData = password.data(using: .utf8) else { return nil } var derivedKeyData = Data(repeating: 0, count: keyByteCount) let derivedCount = derivedKeyData.count let derivationStatus: OSStatus = derivedKeyData.withUnsafeMutableBytes { derivedKeyBytes in let derivedKeyRawBytes = derivedKeyBytes.bindMemory(to: UInt8.self).baseAddress return salt.withUnsafeBytes { saltBytes in let rawBytes = saltBytes.bindMemory(to: UInt8.self).baseAddress return CCKeyDerivationPBKDF( CCPBKDFAlgorithm(kCCPBKDF2), password, passwordData.count, rawBytes, salt.count, hash, UInt32(rounds), derivedKeyRawBytes, derivedCount) } } return derivationStatus == kCCSuccess ? derivedKeyData : nil } Unfortunately there isn\u0026rsquo;t much documentation on this so I wasn\u0026rsquo;t able to find different combinations for parameters. In particular I wasn\u0026rsquo;t able to find a different CCPBKDFAlgorithm.\nLast Option - Third Party Libraries If you come to the point in which you need to use a cipher, hash, or public key algorithms that is not covered by any framework on an Apple OS, you will need to use a third-party library.\nOpenSSL is a toolkit for TSL and SSL protocolos, but it is also a general-purpose cryptographic library. It offers a bunch of features. The huge downside of this library is that, it\u0026rsquo;s core being written in C, it is very complicated to use with Swift. That said, if you ever need any of the following features, you can use OpenSSL. I\u0026rsquo;m listing only the algorithms that aren\u0026rsquo;t already covered by CryptoKit, CommonCrypto, and Security:\nCyphers\nCamellia Poly1305 SEED IDEA RC5 GOST 2814-89 SM4 Hash Functions\nSHA-3 RIPEMD-160 MDC-2 GOST R 34.11-94 BLAK2 Whirlpool SM3 Public Key Cryptography\nEd25519 X448 GOST R 34.10-2001 Finally, if you need to implement signature verification and validation in your iOS app, then OpenSSL is the way to go. Apple themselves don\u0026rsquo;t mention their own libraries for parsing and recommend using a statically-linked library such as OpenSSL instead1.\nConclusion CryptoKit is going to be enough for many modern crypto apps, but there will be cases in which CryptoKit won\u0026rsquo;t have everything you need. It\u0026rsquo;s not unreasonable to expect that CryptoKit will add support for more cryptographic algorithms in the future, but until then, we have some reasonable alternatives to the things that CryptoKit cannot currently do.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","cryptokit","wwdc2019"]},{"id":"36a5084d523a1a3875c9473cbe1fac47","title":"Introduction to Patterns and Pattern Matching in Swift.","link":"/posts/pattern-matching/","content":"Swift is a beautiful language, but it hides some powerful features from developers who come from more \u0026ldquo;old-style\u0026rdquo; programming languages such as C++ and Java. One such feature is Pattern Matching, and it allows you to write some cleaner code when dealing with some operations.\nFor example, consider casting. Casting is a feature in the vast majority of statically-typed languages. Casting is considered to be an ugly operation by some, because when you need to cast, it\u0026rsquo;s usually because the language has a flaw that prevents it from telling you about the right data type underneath. This is specially true when you add in Object-Oriented Programming and classes are marked to return a super type instead of a specific subtype. With pattern matching, you can more cleanly check for datatypes without having to worry about crashes or weird behavior.\nIn this article, we will learn what \u0026ldquo;Patterns\u0026rdquo; are in this context, we will explore the specific casting pattern, and we will explore a few other common patterns that are used in Swift. We will also talk about pattern matching along the way so you can learn about this feature along the way, if you haven\u0026rsquo;t already.\nIntroduction to Patterns and Pattern Matching Pattern matching is the checking and locating of specific sequences of data in some specific pattern mixed with random data. Not to be confused with pattern recognition, which allows us to observe a bunch of raw data and find some kind pattern into it. In pattern matching, you already know what the pattern looks like, and you want to know when it\u0026rsquo;s found, and what kind of data to retrieve from it, if applicable.\nThe pattern represents the structure of a single value or a composite value. You can essentially use this pattern to get information about data, and/or the data itself. Patterns can be very varied, from data type checking to enum checking, and more.\nIn Swift, pattern matching is usually done with the switch statement, but you can use this powerful feature with other features as well, like for loops and even catch.\nTypes of Patterns Switch has the following patterns:\nWildcard Pattern Identifier Pattern Value-Binding Pattern Tuple Pattern Enumeration Case Pattern Optional Pattern Type-Casting Pattern Expression Pattern We will explore all of them and learn how to apply them in Pattern Matching.\nThe Wildcard Pattern The Wildcard Patterns ignores any value and replaces it with nothing, represented as an underscore. You can use this pattern when you don\u0026rsquo;t care about the values provided in a pattern.\nIn the following example, you can do something three times with a for loop. Swift doesn\u0026rsquo;t have the traditional for(;;) loop, so if you need to do something repeatedly without necessarily caring about a value, you can do this:\nfor _ in 1...3 { print(\u0026#34;I\u0026#39;m doing something!\u0026#34;) } You commonly use the for loop to fast-iterate over the values of a collection. This works, because 1...3 creates a Range which on every iteration returns a number within it. We are matching any random in the range and using an underscore to represent it, since we don\u0026rsquo;t care about its value.\nIdentifier Pattern This is the most common pattern of all, and you use it all the time. This pattern matches any value and binds it to a variable or constant name. It\u0026rsquo;s a full mouth way of saying \u0026ldquo;variable assignment\u0026rdquo;.\nlet doll = \u0026#34;Classical Alice\u0026#34; This will assign the value \u0026ldquo;Classical Alice\u0026rdquo; to the variable \u0026ldquo;doll\u0026rdquo;.\nYou have used this pattern before, but did you know you can discard the contents of the assignment? This is useful when you call a function with side effects and you don\u0026rsquo;t need to store its value at all. I do this all the time with Sec functions that return a OSStatus, but there\u0026rsquo;s situations when it may never return any errors at all:\nlet _ = functionWithSideEffects() Value-Binding Pattern. In this pattern is where things start to become more interesting. This pattern allows you to match a tuple and grab its values independently.\nlet coordinate = (5, -3) switch coordinate { case let (x, y): print(\u0026#34;Coordintate: \\(x), \\(y)\u0026#34;) } Also, now is a good time to mention that you can use the where keyword to do more complex pattern matching. In the following example, we will not bind the y value (we are replacing it with an underscore), and we will only match the x value when it is higher than 10:\nlet coordinate = (5, -3) switch coordinate { case let (x, _) where x \u0026gt; 10: print(\u0026#34;This coordinate is way to the right of the x axis. \\(x)\u0026#34;) } It\u0026rsquo;s also worth noting that the case match in the order they appear in. Consider the following:\nlet coordinate = (12, -3) switch coordinate { case let (x, y): print(\u0026#34;Coordintate: \\(x), \\(y)\u0026#34;) case let (x, _) where x \u0026gt; 10: print(\u0026#34;This coordinate is way to the right of the x axis. \\(x)\u0026#34;) } Despite the value we want has a value bigger than 10, the second case will never be executed. This is because the first case matches perfectly. You can, however match multiple patterns with the fallthrough keyword.\nlet coordinate = (12, -3) switch coordinate { case let (x, y): print(\u0026#34;Coordintate: \\(x), \\(y)\u0026#34;) fallthrough case let (x, _) where x \u0026gt; 10: print(\u0026#34;This coordinate is way to the right of the x axis. \\(x)\u0026#34;) } You can write very interesting and easy to understand code with this.\nTuple Pattern A tuple is a comma-separated list of zero or more patterns. You may have used patterns before:\nfunc makeCoordinate(x: Int, y: Int) -\u0026gt; (Int, Int) { return (x, y) } Tuples are very powerful and they extend the power of pattern matching even more.\nConsider an array of Coordinates. You can bind a value in each iteration to get the values.\nlet coordinates = [(1, 1), (2, 2), (5, 5), (7, 5), (9, 2), (3, 5)] for (x, y) in coordinates { // Only iterate over the values that have a 5 in the `y` position. } But even more interesting, once again, you can use the where keyboard to further constraint the matching. In the following example we will only get the coordinates that have a value of y \u0026gt; 5.\nlet coordinates = [(1, 1), (2, 2), (5, 5), (7, 5), (9, 2), (3, 5)] for (x, y) in coordinates where y \u0026gt; 5 { // Only iterate over the values that have a 5 in the `y` position. } Enumeration Case Pattern This is a very nice pattern, and a very powerful one. This is the kind of pattern you can use with Error. This kind of patterns lets not only match pure cases, but also cases with parameters.\nenum DataError: Error { case writingError(localizedDescription: String, file: Data) case readingError(localizedDescription: String, fileURL: URL) case unknownError } let error = DataError.writingError(localizedDescription: \u0026#34;Error writing file\u0026#34;, file: Data()) switch error { case .writingError(let description, let data): print(\u0026#34;Could write data \\(data) because \\(description)\u0026#34;) case .readingError(let description, let url): print(\u0026#34;Couldn\u0026#39;t read file at \\(url) because \\(description)\u0026#34;) case .unknownError: print(\u0026#34;Unknown error\u0026#34;) } We defined a DataError and we can match all the different cases. And yes, in case of the case parameters (such as localizedDescription), you can use the wildcard pattern if you don\u0026rsquo;t care about retrieving their values at all.\nOptional Pattern In Swift, Optionals are just syntactic sugar for the Optional Pattern. An optional is simply an enum, and you can match this even.\nTake a look at the following code:\nlet anOptional: Int? = 50 if case .some(let value) = anOptional { // The optional has a value print(value) } In Swift, we can use this shorthand form:\nif case let value? = anOptional { print(value) } But the real power of this pattern comes from other uses. You can use it to iterate over an array of options and ignore the values that are nil, for example.\nlet names: [String?] = [\u0026#34;Alice\u0026#34;, nil, \u0026#34;Eileen\u0026#34;, \u0026#34;Margarethe\u0026#34;, \u0026#34;Alura\u0026#34;, nil, nil, \u0026#34;Momoko\u0026#34;] for case let name? in names { /// Print all the names } Type Casting Pattern This pattern allows to avoid casting if you want more safety and it allows you to check for object types if you ever need to. There\u0026rsquo;s to forms to this pattern:\nYou can check if an object is of a certain type with the is keyword. You can match and cast to see if an object is of a type and cast to it immediately to use it. The former is only available in switch statements. The latter gives you more flexibility and chances are you have used it before, in the form of if let foo = myObject as? Class {}.\nUsing the is keyword is really easy, and you can use it if you only case about the type of an object, and not about its properties or other kind of data.\nIn the following example, we will check if a vehicle is of a given type and let the user know what matches:\npublic class Vehicle {} public class Car: Vehicle { let wheels: Int let size: Int init(wheels: Int, size: Int) { self.wheels = wheels self.size = size } } public class Airplane: Vehicle { let wings: Int let capacity: Int init(wings: Int, capacity: Int) { self.wings = wings self.capacity = capacity } } func makeVehicle() -\u0026gt; Vehicle { return Airplane(wings: 2, capacity: 200) } let aVehicle = makeVehicle() switch aVehicle { case is Car: print(\u0026#34;The vehicle is a car\u0026#34;) case is Airplane: print(\u0026#34;The vehicle is an airplane\u0026#34;) default: print(\u0026#34;unknown vehicle\u0026#34;) } Now if you need to know the type of an object and do need to access its properties, you need to use the \u0026ldquo;casting\u0026rdquo; form of this pattern. Once again, you have probably used a variation of this, but I like this other form because it doesn\u0026rsquo;t rely on optionals and it writes very neat code for the most part (I\u0026rsquo;m not a fan of having to specify a default case):\nlet vehicle = makeVehicle() switch vehicle { case let vehicle as Car: print(\u0026#34;This car has \\(vehicle.wheels) and it\u0026#39;s size is \\(vehicle.size)\u0026#34;) case let vehicle as Airplane: print(\u0026#34;This airplane has \\(vehicle.wings) wings and a capacity for \\(vehicle.capacity) people\u0026#34;) default: print(\u0026#34;Unknown vehicle\u0026#34;) } Do note that this pattern matches both the class you specify and any subclasses of it, so make sure you order your cases accordingly.\nThe Expression Pattern This pattern represents the value of an expression. This pattern can only appear inside switch statements.\nThis pattern users the ~=. This operator by default compares values of the same type using ==. It can also match elements in ranges, checking to see if the value is within the range. You can implement this function for your own types.\nlet coord = (1, 1) switch coord { case (-5...5, -5...5): print(\u0026#34;Both coordinates are within the same range. x is \\(coord.0) and y is \\(coord.1)\u0026#34;) default: print(\u0026#34;no matches\u0026#34;) } Conclusion Pattern matching is a really powerful and interesting feature. It can help you write cleaner code and there\u0026rsquo;s many ways to do it. You can use pattern matching in many different places to improve the quality of your code.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","patternmatching"]},{"id":"95bcb6e0dfc1655630165c93c1efb516","title":"Understanding and Implementing NSNotificationCenter on Apple's Platforms","link":"/posts/nsnotificationcenter/","content":"Sometimes when you are writing an app, you need to be notified of events occurring somewhere else in the system - either in your own app, or in the operating system - and react to them accordingly. For example, you may be an app like Snapchat and you want to know when a screenshot has been taken. This is a system notification that you can \u0026ldquo;listen\u0026rdquo; to in order to react. If you have an app like a photo gallery, you may need to know when the user adds a new photo so you can update all relevant UI and make other necessary updates.\nNSNotificationCenter allows you to listen to events and to react to them. In this article we will explore how to make use of this API in our apps, we will listen to system-provided notifications, and we will also implement our own.\nIntroduction Not to be confused with the Notification Center feature on Apple\u0026rsquo;s devices, NSNotificationCenter allows apps to listen to events and to react to them. Apple describes it as \u0026ldquo;A notification dispatch mechanism that enables the broadcast of information to registered observers.\u0026quot;1\nEssentially, objects that are interested in learning about a certain event can \u0026ldquo;listen\u0026rdquo; for it. More than one object can listen for the same event (which is why events are \u0026ldquo;broadcasted\u0026rdquo;). Objects who are listening for these events are called Observers.\nWhile you can create your own NSNotificationCenter instances, I have never seen this been done in the while. More often that not, you want to use the singleton defaultCenter.\nObserving And Posting Custom Events Custom Events You are implementing your own photo gallery app and you want to know when a new app is added so you can update all the relevant parts of the UI. Imagine the Photos.app, where you have the main \u0026ldquo;Photos\u0026rdquo; tab and the \u0026ldquo;Albums\u0026rdquo; tab which has a \u0026ldquo;Recents\u0026rdquo; album. How can you update these two when a new image is added?\nThe solution is to use NSNotificationCenter, register your own NSNotification to the system, and observe this notification from both the \u0026ldquo;Albums\u0026rdquo; tab and \u0026ldquo;Recents\u0026rdquo; album.\nRegistering Your Custom Notifications To register your own notifications, you need to write an extension for the NSNotification.Name class and add all your related notifications to it.\nextension NSNotification.Name { /// User added a new photo to gallery. class GalleryApp { static let newPhotoAdded = NSNotification.Name(rawValue: \u0026#34;com.andyibanez.galleryApp.newPhotoAdded\u0026#34;) /// User deleted a photo from gallery. static let photoDeleted = NSNotification.Name(rawValue: \u0026#34;com.andyibanez.galleryApp.photoDeleted\u0026#34;) } } What we are doing here is extend NSNotificationName, we are adding a class of static objects, and these objects are our own notifications.\n**Important Note!** You technically don\u0026rsquo;t need to extend NSNotification.Name, and even less add your own class to it. I just find this way to be better if your app implements many custom notifications. The downside to wrapping your own notifications in a class is you lose some of Swift\u0026rsquo;s inference features when working with notifications.\n**Important Note!** If you have seen other documentation, tutorials, or articles on NSNotification.Name(rawValue: \u0026quot;\u0026quot;), you may have seen they don\u0026rsquo;t use reverse DNS notation for the raw value. I believe it is necessary, because other dependencies on your app may create their own notifications as well, and that will create a conflict when you least expect it.\nSuppose you add a dependency that takes photos in your gallery app. It may add new notification with the raw value \u0026ldquo;photoAdded\u0026rdquo; for its own internal use after taking a photo. If our own newPhotoAdded notification used that same identifier, there would be a conflict and components in your app may receive the incorrect notification.\nIt\u0026rsquo;s not always possible if dependencies add their own notifications, and the system provides its own sets of notifications as well, so I strongly recommend you namespace notifications with reverse DNS notation. After all, you will never need to refer to this rawValue directly.\nPosting Custom Notifications Now that you have your own notifications, you can start posting them, and anyone interested in them can listen to them.\nNSNotification center has three overloaded methods to post notifications:\nNotificationCenter.default.post(notification:): Use this method if you just need to post a notification with no context whatsoever. NotificationCenter.default.post(name:object:): Use this method if you need to post a notification and care about who is posting it. The object person is the sender, the object posting the notification. NotificationCenter.default.post(name:object:userInfo:): This method is the most complete one. You specify the notification name, the object (which is again the sender), and an userInfo dictionary. You can use this dictionary to provide additional data to the observers. In our example, we can provide the picture that was just added to the app. Since we want to pass the photo that was just added, we will use the last one.\nclass PhotoManager { func addNewPhoto(_ photo: UIImage) { // 1. Our notification name let newPhotoAdded = Notification.Name.GalleryApp.newPhotoAdded // 2. Extra info to pass to the interested parties. let userInfo: [String: Any] = [ \u0026#34;image\u0026#34;: photo ] // 3. Post the notification NotificationCenter.default.post(name: newPhotoAdded, object: self, userInfo: userInfo) } } Our PhotoManager class is responsible for posting notifications. He will notify all interested parties when a new photo has been added to the app.\nReceiving Notifications The final step is to listen for notifications we are interested in. We will see how our example Gallery app may implement it in its \u0026ldquo;PhotosViewController. The very same logic applies to the \u0026ldquo;Recents\u0026rdquo; album.\nclass PhotosViewController: UIViewController { var photos = [UIImage]() override func viewDidLoad() { super.viewDidLoad() registerForNotifications() } func registerForNotifications() { let ns = NotificationCenter.default let newPhotoAddedNotif = Notification.Name.GalleryApp.newPhotoAdded ns.addObserver(forName: newPhotoAddedNotif, object: nil, queue: nil) { (notification) in // A new photo was added! // Retrieve the photo from the notification and update our UI guard let uInfo = notification.userInfo, let image = uInfo[\u0026#34;image\u0026#34;] as? UIImage else { return } self.photos += [image] } } } And that\u0026rsquo;s it! Now when our object receives the .newPhotoAdded notification. It will add the photo to its own photos array. The same thing will happen in the hypothetical \u0026ldquo;Recents\u0026rdquo; album.\nSystem Notifications The system (iOS, watchOS, iPadOS, macOS, TVOS) can post its own notifications when an event takes place.\nYou don\u0026rsquo;t need to do anything special to listen to them. Just add yourself as an observe like you did before and you will start to receive these notifications.\nThere\u0026rsquo;s many documentation pages that list some notification names, like the Accessibility Notification Names, and the Notification.Name provides a very long list of system notifications. It wouldn\u0026rsquo;t be fun to post them all here, so I will just mention the ones I find most interesting:\nNSCalendarDayChanged: Posted when the system calendar day changes. NSTimeZoneDidChange: Posted when the system\u0026rsquo;s time zone changes. NSSystemClockDidChange: Posted when the system\u0026rsquo;s clock changes. userDidTakeScreenshotNotification: Posted when the user takes a screenshot of the device. brightnessDidChangeNotification: Posted when the device brightness level changes. SKStorefrontCountryCodeDidChange: Changed when country used for purchases changes. You can use these and others in the linked documentation to do more interesting stuff with your code. Play around with the notifications and see what you can do.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","nsnotificationcenter"]},{"id":"fbdb57b317fdd5d573414d06dfd4aa9c","title":"Filtering Arrays with Predicates","link":"/posts/filtering-arrays-nspredicate/","content":"Whether you have been programming for a while or are new at it, chances are you have had the need to search for results in an array. And while Apple\u0026rsquo;s SDKs for iOS, macOS, iPadOS, and watchOS all use Foundation and have a set of handy tools to make that task easier, there is one particular API that is very powerful but doesn\u0026rsquo;t get much use unless you pair with other frameworks such as Core Data: NSPredicate.\nNSPredicate is a definition of logical conditions you can use to search and filter information in certain APIs. It lets you define conditions to search for something while using an object\u0026rsquo;s properties. Internally, the API uses key-value coding to work, so your Swift objects must be compatible with Objective-C.\nIntroduction to NSPredicate NSPredicate allows you to perform searches and filtering writing conditions like the following:\nA person\u0026rsquo;s salary is equal to 5000, less than 3000, more than 4000, and so on. A person\u0026rsquo;s last name is a certain last name. A person\u0026rsquo;s last name is LIKE (similar) to another last name. A text begins with a certain string. Date in a range. And to make it even more interesting, you can even perform aggregate operations such as the sum of a certain property in an array, the average, and so on.\nThere\u0026rsquo;s some subclasses of this class you can use, but you can also use it as-is. NSComparisonPredicate can be used to compare the results of two expressions, and NSCompoundPredicate can be used to join two predicates together to create logical \u0026ldquo;and\u0026rdquo;, \u0026ldquo;or\u0026rdquo;, and \u0026ldquo;not\u0026rdquo; searches and filtering.\nIn this article we will explore NSPredicate and NSCompoundPredicate and how you can use them to search in NSArrays. You can later apply these concepts for other frameworks such as Core Data.\nDownsides and Quirks. Before we get to work, though, I need to mention that NSPredicates rely heavily in Objective-C\u0026rsquo;s features, so when we work on it with Swift, we lose some features such as type safety and we need to do a bit of casting. That said, this extra work is nothing considering all that you get back from them.\nUsing NSPredicate Our objects must work with Objective-C, specially it\u0026rsquo;s Key-Value Coding features. We will write NSPredicate examples using these two classes:\n@objcMembers class Job: NSObject { let company: String let salary: Float let title: String init(company: String, salary: Float, title: String) { self.company = company self.salary = salary self.title = title } } @objcMembers class Person: NSObject { let firstName: String let lastName: String let job: Job var fullName: String { get { return \u0026#34;\\(firstName) \\(lastName)\u0026#34; } } init(firstName: String, lastName: String, job: Job) { self.firstName = firstName self.lastName = lastName self.job = job } } In order to make them available to Objective-C, we need to mark them as objcMembers, and to get the KVC features, we need them to inherit from NSObject.\nThen we will use an array that stores Person objects, where each person has a Job.\nlet people = [ Person(firstName: \u0026#34;Andy\u0026#34;, lastName: \u0026#34;Ibanez\u0026#34;, job: Job(company: \u0026#34;Fairese\u0026#34;, salary: 5000, title: \u0026#34;CEO\u0026#34;)), Person(firstName: \u0026#34;Sakura\u0026#34;, lastName: \u0026#34;Kinomoto\u0026#34;, job: Job(company: \u0026#34;Tomoeda Gakkou\u0026#34;, salary: 4000, title: \u0026#34;Card Captor\u0026#34;)), Person(firstName: \u0026#34;Daidouji\u0026#34;, lastName: \u0026#34;Tomoyo\u0026#34;, job: Job(company: \u0026#34;Daidouji Group\u0026#34;, salary: 4000, title: \u0026#34;Filmmaker\u0026#34;)), Person(firstName: \u0026#34;Nae\u0026#34;, lastName: \u0026#34;Kinomoto\u0026#34;, job: Job(company: \u0026#34;Animal Group\u0026#34;, salary: 3000, title: \u0026#34;Animal Captor\u0026#34;)), Person(firstName: \u0026#34;Tae\u0026#34;, lastName: \u0026#34;Kinoshita\u0026#34;, job: Job(company: \u0026#34;Zombie, Co.\u0026#34;, salary: 2500, title: \u0026#34;Dancer\u0026#34;)) ] Unfortunately, we can\u0026rsquo;t use NSPredicate and its subclasses with a Swift array, so we need to convert it to an NSArray.\nlet nsPeople = people as NSArray With all this setup done, we can write some examples.\nThe NSPredicate Class NSPredicate is very to use. When you create it with the init(format:arguments:) initializer, you pass in a string very similar to a SQL query.\nShowing all the possible formats is beyond the scope of this article, but Apple provides a nice Predicate Format String Syntax guide. We will explore the basic scenarios, as well as some neat things you can do with them.\nExact String Match. You can write predicates that simply match a string completely. You can adapt the query to make it match different case, and more.\nThe below code fetches all the people who have the last name Kinomoto:\nlet lastNameKinomotoPredicate = NSPredicate(format: \u0026#34;lastName = %@\u0026#34;, \u0026#34;Kinomoto\u0026#34;) let lastNameKinomoto = nsPeople.filtered(using: lastNameKinomotoPredicate) print(\u0026#34;People whose last name is Kinomoto:\u0026#34;) (lastNameKinomoto as! [Person]).forEach { print($0.fullName) // Prints: // Sakura Kinomoto // Nae Kinomoto } Part of the downsides is we need to cast the filtered array in order to use the objects within it (or you could use Key-Value Coding yourself, but it\u0026rsquo;s not as neat).\nMatching The Beginning of a String You can match any part of a string without having to match the entirety of it. To match the beginning of the string, you use the BEGINSWITH keyword.\nThe bellow example will fetch all the people\u0026rsquo;s whose last name begins with Kino.\nlet lastNameBeginsKinoPredicate = NSPredicate(format: \u0026#34;lastName BEGINSWITH[c] %@\u0026#34;, \u0026#34;Kino\u0026#34;) let lastNameBeginsKino = nsPeople.filtered(using: lastNameBeginsKinoPredicate) print(\u0026#34;People whose last name contains \\\u0026#34;Kino\\\u0026#34;:\u0026#34;) (lastNameBeginsKino as! [Person]).forEach { print($0.fullName) // Prints: // Sakura Kinomoto // Nae Kinomoto // Tae Kinoshita } Matching Properties Within Composed Objects. All our Persons have a Job. We can find all the people who meet a certain job criteria by querying the Job object. We can do this using a key path (which is not the neat key path\u0026rsquo;s we know from Swift, but they work)!\nIn the example bellow, we will query for all the people who work at companies who have the word Group in their name:\nlet companyContainsGroupPredicate = NSPredicate(format: \u0026#34;job.company CONTAINS[c] %@\u0026#34;, \u0026#34;Group\u0026#34;) let companyContainsGroup = nsPeople.filtered(using: companyContainsGroupPredicate) print(\u0026#34;People who work for a group:\u0026#34;) (companyContainsGroup as! [Person]).forEach { print($0.fullName + \u0026#34; \u0026#34; + \u0026#34;(\\($0.job.company))\u0026#34; ) // Prints: // Daidouji Tomoyo (Daidouji Group) // Nae Kinomoto (Animal Group) } This one of my favorite things about NSPredicate, and you can use it to build some advanced searches.\nUsing NSCompoundPredicate You can create and join predicates together using the NSCompoundPredicate class. This class inherits from NSPredicate, so you can use it everywhere a normal predicate is expected.\nYou can use a compound predicate to join various predicates together with \u0026ldquo;and\u0026rdquo;, \u0026ldquo;or\u0026rdquo;, and even \u0026ldquo;not\u0026rdquo;. You can also use other compound predicates in another compound predicate, so you can create very interesting and complex filters.\nIn the example below we will create a predicate that fetches all the people who earn less than 3000 and those who earn above 4000 with a or predicate.\nlet salaryBelow3000 = NSPredicate(format: \u0026#34;job.salary \u0026lt; %d\u0026#34;, 3000) let salaryAbove4000 = NSPredicate(format: \u0026#34;job.salary \u0026gt; %d\u0026#34;, 4000) let salaryBelow3000AndAbove4000Predicate = NSCompoundPredicate(orPredicateWithSubpredicates: [salaryBelow3000, salaryAbove4000]) let salaryBelow3000AndAbove4000 = nsPeople.filtered(using: salaryBelow3000AndAbove4000Predicate) print(\u0026#34;People who earn less than 3000 and above 4000:\u0026#34;) (salaryBelow3000AndAbove4000 as! [Person]).forEach { print($0.fullName + \u0026#34; \u0026#34; + \u0026#34;(\\($0.job.salary))\u0026#34;) // Prints: // Andy Ibanez (5000.0) // Tae Kinoshita (2500.0) } Why Use NSPredicate? This is a very good question, and you may be wondering since we already have a lot of powerful filtering options in Swift using the filter function. We can do everything we did with predicates using this function and save us the problem of making our code compatible with Objective-C and all that casting. So why?\nThe answer is that, not only is this great for using with Core Data (where you specify the criteria with NSPredicates) but also because it\u0026rsquo;s much easier to allow your users to create filters for their data. Imagine you create a Contacts app that doesn\u0026rsquo;t store its data in a database, but in plain text files that can be deserializes into arrays. You can allow your users to create filters for their contacts with any criteria they want. Of course, only use them if you have such a need. If you need to do filtering that your users are never going to see, there\u0026rsquo;s no need to use NSPredicates with arrays.\nConclusion NSPredicate offer a very powerful way to search and filter array and other content, such as queries in core data. They can be as simple or complex as you need them, and their format language is similar to SQL and therefore very intuitive to use. It\u0026rsquo;s a bit of a bummer we need to play with a lot of Objective-C code to make them to work, but if you need them, the effort is worth it.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","nspredicate","arrays","nsarray"]},{"id":"8e34e8acd38d5c5f7b153ad234c8ab55","title":"Common Cryptographic Operations With CryptoKit","link":"/posts/common-cryptographic-operations-with-cryptokit/","content":"Apple has always taken security very seriously, so it\u0026rsquo;s expected that they would provide developers with the same tools they have to help developers implement the same security measures in their apps. This year, Apple introduced CryptoKit.\nApple providing new cryptography tools is nothing new. They have provided the Security framework for a very long time, and a few years later they introduced CommonCrypto. The problem with these frameworks is that they can be very low level, being written in C, and it can be intimidating for new developers to adopt them in their project. CryptoKit abstracts a lot of the details and it provides easier interfaces for common operations such as hashing, encrypting, and even signing.\nIn this article we will explore how to do common cryptographic operations with CryptoKit, and the downsides it currently has.\nIntroduction to CryptoKit CryptoKit is a cryptography framework for Apple\u0026rsquo;s platforms written in Swift. It provides easy and convenient interfaces for cryptographic operations in a safe and high-level manner. You no longer have to worry about managing pointers or other low-level concepts that just don\u0026rsquo;t exist in Swift. You also don\u0026rsquo;t have to do manual memory management.\nCryptoKit allows you to:\nCompute and compare hashes. Work with Public-Key cryptography to create and evaluate digital signatures and do key exchange. Work with symmetric cryptography to do message authentication and encryption. Common Cryptographic Operations with CryptoKit Hashing To perform hashing, CryptoKit provides the HashFunction protocol, along with three implementations of it. At the time of this writing, said implementations are the following structs:\nSHA256 SHA384 SHA512 They are all used similarly. They all have a static method that takes a DataProtocol of what you want to hash.\nFor example, to perform a SHA256:\nlet data = string.data(using: .utf8)! let hash = SHA256.hash(data: data) This will return the hash as a SHA256.Digest object, which is actually a collection\nIf you want to get the string representation of this hash, you do this:\nlet stringHash = hash.map { String(format: \u0026#34;%02hhx\u0026#34;, $0) }.joined() Important Note!\nYou may have seen (and maybe even been tempted by) people grabbing the hash using the description property of the digest.\nprint(hash.description) This is because the property prints something like this:\nSHA256 digest: ae7ffb85a76d5810c70c2459415e02b26a556e6d02ef76449690c1459232ffa9 This is not safe, because Apple can change how the description property returns the information about the hash in a future release. In general, you should never rely on this property to get any long-lasting data. You should only use it when debugging.\nAs a recent example of this, Apple recently changed what the description property of Data objects returns. Developers were using it as a quick way to get the textual representation of a push notification token, and Apple changed it to return the size of the data instead. This caused a lot of broken push notifications in a lot of apps.\nFor the sake of comparison, this is how I calculated a SHA512 hash prior to iOS 13 in Swift:\nfunc iOS10Sha512(data: Data) -\u0026gt; Data { let digest = NSMutableData(length: Int(CC_SHA512_DIGEST_LENGTH))! let value = data as NSData let uint8Pointer = UnsafeMutablePointer\u0026lt;UInt8\u0026gt;.allocate(capacity: digest.length) CC_SHA512(value.bytes, CC_LONG(data.count), uint8Pointer) return value as Data } All the aforementioned hashes are used the same way. If you need to use deprecated hash algorithms but are still popular today (such as MD5), Apple provides them in an Insecure enum.\nTo calculate the MD5 hash of a piece of data with CryptoKit:\nlet md5 = Insecure.MD5.hash(data: data) You can also find the SHA1 algorithm within Insecure.\nSymmetric Encryption With CryptoKit, when you encrypt a piece of data not only will get you confidentiality of your message, but also authenticity.\nCryptoKit provides two symmetric cyphers: AES-GCM and ChaChaPoly.\nTheir usage is once again very straightforward and you don\u0026rsquo;t have to concern yourself with the low-level implementation details.\nThe return type of the seal method is a AES.GCM.SealedBox object which contains information about the box. A few important properties:\nA ciphertext, which is the encrypted data with the same size as the input data. A tag, which ensures the content cannot be tampered with in a way you would not notice. A nonce, which is a random number to add entropy to the encrypted data. If you need to share the data with somebody else, you can use the combined property which combines all the previous properties into one. Then they can decrypt this data using the same key.\nlet combinedData = sealedBox.combined! // Previous sealed box let sealedBoxToOpen = try! AES.GCM.SealedBox(combined: combinedData) let decryptedData = try! AES.GCM.open(sealedBoxToOpen, using: passwordKey) let decryptedString = String(data: decryptedData, encoding: .utf8)! print(decryptedString) // \u0026#34;The Legend of Zelda\u0026#34; Signing and Verifying Signed Content CryptoKit can help you sign and verify the signature of data.\nCryptoKit comes with four different elliptic curve types:\nCurve25519 P521 P384 P256 We will see how to use P521, and you will be able to use the others with these examples.\nGenerating Key Pairs Public-Key cryptography works with private and public keys, so we will start generating those.\nlet privateKey = P521.Signing.PrivateKey() let publicKey = privateKey.publicKey let publicKeyData = publicKey.rawRepresentation //You can share this one with others The P521.Signing.PrivateKey object wraps both the private key and public key, and they both have a Data representation that you can use to share (though you shouldn\u0026rsquo;t share the private key with anyone, but you can use the data representation if you want to store it in a different way). You can convert these representations to Base64 encoded strings to make them easier to share, like posting them on your websites or sharing them in social media.\nSigning Dealing with signing is much, much easier than doing it with the earlier APIs (and I tell you this from personal experience!)\nCreating Signatures Signing is a very simple affair, and so is verifying signatures.\nlet signature = try! privateKey.signature(for: data) There\u0026rsquo;s two variations of the signature method: One for data, and one for digests, which is what you would normally want to do. If you have a digest generated with CryptoKit\u0026rsquo;s SHA256, SHA384, SHA512, or even an insecure algorithm, you can sign it directly with the overloaded method.\nlet hash = SHA256.hash(data: data) let digestSignature = try! privateKey.signature(for: hash) Verifying Signatures Just like is the case with signing, there\u0026rsquo;s two overloaded methods for signature verification: One for a DataProtocol, and another one for a digest.\nif publicKey.isValidSignature(signature, for: data) { print(\u0026#34;Valid signature\u0026#34;) } **Important Note!** Not all cyphers have signing methods for both digests and data. Curve25519 only exposes signing methods for DataProtocols.\nKey Agreement Key agreement is a method used for multiple parties to securely choose a shared encryption key that can be used for signing and encrypting the data they want to share between each other.\nStart by choosing a random salt.\nfunc randomData(length: Int) -\u0026gt; Data { var data = Data(count: length) _ = data.withUnsafeMutableBytes { SecRandomCopyBytes(kSecRandomDefault, length, $0.baseAddress!) } return data } let salt = randomData(length: 32) // 256bits If you don\u0026rsquo;t want to drop down to CommonCrypto to generate a random salt, you can create a new SymmetricKey of 256bits, and than grab its raw bytes to use it as a salt.\nlet symKeySalt = SymmetricKey(size: .bits256) let salt = symKeySalt.withUnsafeBytes { Data($0) } After a salt has been generated, all the interested parties need to share their public keys with each other.\nlet alicePrivateKey = P521.KeyAgreement.PrivateKey() let alicePublicKey = alicePrivateKey.publicKey let eileenPrivateKey = P521.KeyAgreement.PrivateKey() let eileenPublicKey = eileenPrivateKey.publicKey /// Alice sends her public key to Eileen /// Eileen sends her public key to Alice Now, all the parties have the relevant public keys.\nThen, all the parties need to do is derive a secret using their own private key and the public key of the people they want to talk with. Once they have that shared secret, they can get the symmetric key.\nAll parties should derive the same symmetric key, and later they can start sharing data encrypted using this key.\n// Alice derives the shared secret and key. let aliceSharedSecret = try! alicePrivateKey.sharedSecretFromKeyAgreement(with: eileenPublicKey) let aliceSymmetricKey = aliceSharedSecret.hkdfDerivedSymmetricKey(using: SHA256.self, salt: salt, sharedInfo: Data(), outputByteCount: 32) // Eileen derives the shared secret and key. let eileenSharedSecret = try! eileenPrivateKey.sharedSecretFromKeyAgreement(with: alicePublicKey) let eileenSymmetricKey = eileenSharedSecret.hkdfDerivedSymmetricKey(using: SHA256.self, salt: salt, sharedInfo: Data(), outputByteCount: 32) if aliceSymmetricKey == eileenSymmetricKey { print(\u0026#34;The keys are equal and now they can share data\u0026#34;) } And said encryption can be done with the two algorithms we saw before: Either AES-GCM or ChaCha20. To show this we will simulate a simple chat between Alice and Eileen:\n// Alice sends a message to Eileen let message = \u0026#34;Hi Eileen!\u0026#34;.data(using: .utf8)! let encryptedByAlice = try ChaChaPoly.seal(message, using: aliceSymmetricKey) // Eileen reads Alice\u0026#39;s message. let decryptedMessage = try! ChaChaPoly.open(encryptedByAlice, using: eileenSymmetricKey) let decryptedMessageString = String(data: decryptedMessage, encoding: .utf8)! print(decryptedMessageString) // Hi Eileen! You can send a different salt each time a new message is generated as to keep it unique, and I encourage you to do so. If you are starting with CryptoKit, feel free to use a hard coded salt, but don\u0026rsquo;t use it in a real application.\nThe Downsides Currently, CryptoKit doesn\u0026rsquo;t have much support for some popular encryption algorithms. While I wouldn\u0026rsquo;t expect Apple to implement TwoFish or Serpent anytime soon, I was surprised when I saw we couldn\u0026rsquo;t derive RSA keys. CryptoKit is really nice though, so I\u0026rsquo;m sure the encryption suites it supports will just grow in the future.\nConclusion CryptoKit is a new and modern Cryptography framework for Apple\u0026rsquo;s platforms. It is very high level, which makes it very easy to use. It supports a good set of cryptography algorithms you\u0026rsquo;d expect to find in any other library. It supports the most basic operations like hashing, encryption, and even key derivation and sharing. It\u0026rsquo;s a very powerful and simple framework despite it\u0026rsquo;s lack of other popular algorithms. I personally have high hopes for its future, and it was one of my favorite surprises of this year\u0026rsquo;s WWDC.\n**Important Note!** In this article, I took a lot of liberties with the force-unwrapping and try!. With CryptoKit you should always deal with these operations in a safe manner.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","cryptokit","wwdc2019"]},{"id":"35981be510a468ea466465b0c948e0d3","title":"Playing Custom Haptics on iOS","link":"/posts/playing-custom-haptics-on-ios/","content":"Vibration and physical feedback has become an important feature of Apple\u0026rsquo;s operating systems. Starting with the Apple Watch, Apple replaced the traditional vibration feedback with haptic feedback hardware, which allowed them to have more control over how vibrations and physical feedback work.\nFirst being introduced in the Apple Watch, Haptic Feedback has been a core part of the Apple ecosystem experience since. Just think about it, wouldn\u0026rsquo;t it be weird if you force-touched the screen to do something, and there was no physical response from the device? Think of the old Peek-and-Pop. If you updated to iOS 13 and got context menus, you may feel they feel great to do in iOS (because they have a haptic engine), but on iPad they feel lacking because the device doesn\u0026rsquo;t vibrate when triggering them.\nHaptic feedback is present even in the most unexpected places of Apple\u0026rsquo;s lineup. Their touch-pads respond with haptics. The iPhone 7 and 8, which have no physical home button, create exactly the same feeling by providing a haptic instead of physical touch presses. We may not notice it, but if you are deep into Apple\u0026rsquo;s ecosystem, haptics are all over the place.\nIn this article, we will explore how we can integrate haptic feedback into our iOS 13 apps.\nPlaying with Haptic Feedback on iOS 13. Apple has a few APIs that give developers a lot of control over the haptics they want to create on iOS 13.\nThe CHHapticEngine handles requests to play haptic patterns.\nTo use it, you need to import CoreHaptics.\nCoreHaptics Setup Before you actually try to play some feedbacks, though you need to ensure that the device supports them. As we discussed earlier, not all devices support them, and a notable example of that are all iPads released until now.\nTo check if your device supports haptics, the CHHapticEngine object has a static method called capabilitiesForHardware() that returns the supported feedback capabilities.\nguard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { // Haptics not supported. return } Once you know your device supports haptics, you can create one like this:\nvar engine: CHHapticEngine? // ... do { engine = try CHHapticEngine() try engine?.start() } catch { print(\u0026#34;Problem with haptics: \\(error)\u0026#34;) } It\u0026rsquo;s not clear to me at this when the engine can throw an error as there\u0026rsquo;s a tremendous lack of documentation at this time, even after iOS 13 has been released. My assumption is when you try using it in a device that doesn\u0026rsquo;t have a haptic engine, or when the hardware inside the device is malfunctioning.\nThe feedback engine is the connection to the haptic server inside a device. You can create multiple connections to this server (via multiple instances of CHHapticEngine), so don\u0026rsquo;t worry about treating it as a singleton. Each connection is independent of the others.\nThe call to start() is asynchronous, so be wary of that. There is an asynchronous variation that takes a completion clock if you need it:\nengine?.start(completionHandler: { (error) in // .. Handle error if relevant // .. Do something after it starts }) There\u0026rsquo;s some additional properties you can set. If the Haptic Engine gets stopped for any reason, you an get a callback. When there\u0026rsquo;s an error with the haptic server, you can also get notified when it has been reset.\nBelow are the two relevant properties:\nengine?.stoppedHandler = { reason in print(\u0026#34;Haptic engine stopped due to reason: \\(reason)\u0026#34;) } engine?.resetHandler = { // The engine has been reset, so you can try connecting to it again. do { try engine?.start() } catch { // handle error. } } Playing Haptic Events After you have done all that setup, you can start creating some haptics events. You create an event, request a player from the server, and send your haptic requests to that player.\nTo create a haptic event, you begin creating the parameters that will be used to configure it.\nlet intensity = CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.5) // The feel of haptic event, from dull to sharp let sharpness = CHHapticEventParameter(parameterID: .hapticIntensity, value: 0.5) // How strong the haptic is // Some advanced parameters let attackTime = CHHapticEventParameter(parameterID: .attackTime, value: 0.5) // When to increase the intensity of the haptic. let decayTime = CHHapticEventParameter(parameterID: .decayTime, value: 0.5) // When the intensity of the haptic goes down. let releaseTime = CHHapticEventParameter(parameterID: .releaseTime, value: 0.5) // If you want the haptic to \u0026#34;fade\u0026#34;, when let sustainTime = CHHapticEventParameter(parameterID: .sustained, value: true) // If you want to sustain the haptic for its entire duration. let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 0) do { let pattern = try CHHapticPattern(events: [event], parameters: []) let player = try engine?.makePlayer(with: pattern) try player?.start(atTime: 0) } catch { print(\u0026#34;Failed perform haptic: \\(error.localizedDescription).\u0026#34;) } The eventType can be hapticTransient or hapticContinous. The former is to play simple \u0026ldquo;tics\u0026rdquo;. Think of the haptic you get when flipping a UISwitch, or exploring the options in a UIPicker. The latter is to give more lasting feedback, such as a longer vibration when an error occurs in a textfield. This is interesting to use in games because you can create haptics that resemble the situation in the game. If you get hit, you get a light vibration, but as you keep getting and your life bar depletes, you can make it more and more intense.\nThese are just some of the basic configurations you can do for your feedbacks. Alongside vibrations, you can play sound as part of an event so you can create feedback similar to that of the context menus in Springboard. You can even read and write haptics into a file so users can create their own. In the Settings app on iPhone, you can create custom vibration patterns for calls, and they all use haptic feedbacks.\nAudio haptics come with their own set of parameters as well, including the frequency (brightness), audio volume, audio pan, and pitch. If you have a designer who wants to experiment with these, it could be fun to play with them.\nConclusion Using Haptics on Apple\u0026rsquo;s devices is now easier than ever and we have a lot of flexibility to implement them. When designing apps, consider the interactions where you could use haptics to improve the experience of your users, but be careful not to overdo them because if used wrongly, they can cause physical discomfort. Try to see where devices that support use it so you can learn the best place to implement it.\n","tags":["swift","programming","apple","ios","macos","watchos","corehaptics","ios13","wwdc2019"]},{"id":"f8d2278760fded6454d21fd93f476b5a","title":"Formatting Content with NSFormatter","link":"/posts/nsformatter/","content":"Very often, we need to deal with data in a \u0026ldquo;raw\u0026rdquo; format that, if displayed directly to the user, it makes little sense to them. This kind of data includes a date timestamp, the number of bytes in a big file, or numbers with no rounding a bunch of decimals. There is a lot of data like this, and we need to be able to format it and show it to the user.\nIn all my years as a programmer, I have seen a lot of \u0026ldquo;hacky ways\u0026rdquo; to retrieve and parse content such as dates and file sizes. Sometimes, they were good, but more often than not they were extremely verbose code and unnecessary. NSFormatter has a lot of advantages, including providing localized representations where relevant.\nIntroducing NSFormatter NSFormatter is considered an abstract class. You should never use it directly, but you can subclass it or use the specializations already provided by Foundation. This class helps create textual representation of values, and it can else help you validate and interpret such values.\nIn this article, we will explore a few existing NSFormatters and when you may want to use them.\nExisting Formatters There\u0026rsquo;s a bunch of formatters that are already provided by Foundation. These include:\nByteCountFormatter: To represent digital filesizes of data. DateFormatter: For formatting dates. DateComponentsFormatter: For formatting individual components, like \u0026ldquo;2 days\u0026rdquo;. DateIntervalFormatter: For formatting time ranges. EnergyFormatter: You can use this to format energy values, from joules and kilojoules, to calories and kilocalories. LengthFormatter: Provides localized descriptions for distance and height units. MassFormatter: Provides formatting for mass and weight values. NumberFormatter: For formatting numbers and their textual values. PersonNameComponentsFormatter: Provides localized descriptions for the components in a person\u0026rsquo;s name. ISO8601DateFormatter: Introduced in iOS10, this handy formatter allows you to quickly work with dates returned in ISO8601 format. Handy for those web services that don\u0026rsquo;t return timestamps. These are just some of the formatters that Cocoa already provides for you, but there\u0026rsquo;s more. In this article we will not explore all of them. We will see the ones that you are very likely to need at some point.\nByteCountFormatter This formatter allows you to represent file sizes in bytes in strings with their respective units. In other words, it allows you to display 1_000_000_000 bytes as 1GB.\nThe basic usage looks like this:\nlet byteFormatter = ByteCountFormatter() byteFormatter.countStyle = .decimal byteFormatter.includesUnit = true byteFormatter.allowedUnits = [.useGB] let text = byteFormatter.string(fromByteCount: 1_000_000_000) A bit of discussion is in order.\nFirst, as you may know, one gigabyte is not equivalent to 1,000,000,000 bytes. It\u0026rsquo;s actually 1,073,741,824 bytes. As a convenience, we tend to just round to the nearest number when we talk about computer data file sizes, and even storage media manufactures of media do the same.\nIf you need the formatter to be precise and not consider 1,000,000,000 bytes as 1 gigabyte, you can change the countStyle property to use .binary instead of .decimal.\nbyteFormatter.countStyle = .binary //... let text = byteFormatter.string(fromByteCount: 1_000_000_000) // This will now print 0.93GB Now the formatter is using the right byte count with no estimations to do all its formatting. If you format the value 1_073_741_824 with the new configuration, you will get 1GB, which is expected.\nbyteFormatter.countStyle = .binary //... let text = byteFormatter.string(fromByteCount: 1_073_741_824) // 1GB Going back to the previous example, the one where the formatter prints 0.93GB, you can configure this. It may not make sense to show a value like this for content that is less than one gigabyte, so how can we fix it? Using the allowedUnits property, you can specify all the units the formatter should use for formatting. Because we only have .useGB on it right now, it will only use gigabytes, no matter how big or small the value is.\nYou can specify as many units as you want here, and the formatter will know what unit to format the data with.\nbyteFormatter.countStyle = .binary byteFormatter.includesUnit = true byteFormatter.allowedUnits = [.useGB, .useMB] let text = byteFormatter.string(fromByteCount: 1_000_000_000) // 953.7MB We are now telling the formatter to use GB and MB, and it will automatically format it depending on the size. Because 1_000_000_000 bytes make up less of a gigabyte when using the .binary count style, the formatter knows to format it as megabytes instead of gigabytes.\nThis formatter is really powerful and very easy to use. Feel free to play around with its properties. You can prevent it from showing the unit by setting includesUnits to false. You can choose to show the bytes value along with the formatted value with the includesActualByteCount property. In general, there\u0026rsquo;s a lot you can do, but covering everything will create a very long article!\nDateFormatter You will very often want to format dates to be displayed to the user. DateFormatter gives us the power to format any date and output it in absolutely any format we want.\nThe basic usage looks like this:\nlet dateFormatter = DateFormatter() dateFormatter.dateFormat = \u0026#34;EEEE, MMM d, yyyy\u0026#34; dateFormatter.timeZone = TimeZone(identifier: \u0026#34;America/La_Paz\u0026#34;)! let formattedDate = dateFormatter.string(from: now) // Saturday, Sep 21, 2019 The dateFormat property takes a string in the format you want. Memorizing this format is insane, so luckily there\u0026rsquo;s resources out there that list each placeholder and how to use them, such as nsdateformatter.com.\nYou can specify the timeZone the dates will be formatted for.\nOnce again, this is a very powerful and easy to use formatter, but it has a lot of options, even more than ByteCountFormatter. Explore the other properties so that you can build the formatter that you need. You will probably end up using the locale property often.\nDateComponentFormatter This formatter formats quantities of time. You can use it to display how much time has passed since a given date. You can use it to format the amount of time between two Date objects.\nBasic usage looks like this:\nlet dateComponentsFormatter = DateComponentsFormatter() dateComponentsFormatter.allowedUnits = [.hour, .minute] dateComponentsFormatter.unitsStyle = .brief dateComponentsFormatter.string(from: oldDate, to: now) // 3hr 29min This is yet again another flexible and powerful formatter. You can configure the allowed units, the style, and much more. Many modern social networks show you the relative time of new content until a certain amount of time has passed, and this formatter allows you to do the same.\nA Word On Performance Creating Formatters is a very expensive operation, and you may want to use them in situations when you will undoubtedly create many of them. If you are writing a calendar application, you may want to use DateFormatter to neatly display the time of events in a UITableView. The problem with this is that your first attempt at implementing this will likely create a new formatter every time a new cell is queued.\nIf possible, create a singleton or store your existing formatters somewhere.\nIn an app I have worked on, I had various different date formatters for various different contexts, so I had to create many of them. I also had to display them in table views. To get as much performance as possible, I created a singleton called DateFormatters that stores a [String: DateFormatter] dictionary, and it exposes the formatters through a subscript. The subscript takes the format you want to format a date in, and it returns a formatter for it. If a format for that format already exists, it returns it, otherwise, it creates a new one. It looked like this:\nclass DateFormatters { var formatters = [String: DateFormatter]() static let shared = DateFormatters() private init() {} public subscript(dateFormat: String) -\u0026gt; DateFormatter { if let formatter = formatters[dateFormat] { return formatter } let newFormatter = DateFormatter() newFormatter.timeZone = TimeZone(identifier: \u0026#34;America/La_Paz\u0026#34;)! newFormatter.dateFormat = dateFormat formatters[dateFormat] = newFormatter return newFormatter } } The app was for my country only, so I could use the same TimeZone for all formatters, and whenever I needed a new formatter, I used it like this:\nlet dateAndHour = DateFormatters.shared[\u0026#34;EEEE, MMM d, yyyy HH:mm:ss\u0026#34;] let dateAndHourString = dateAndHour.string(from: now) // Saturday, Sep 21, 2019 17:11:09 let justDate = DateFormatters.shared[\u0026#34;EEEE, MMM d, yyyy\u0026#34;] let justDateString = justDate.string(from: now) // Saturday, Sep 21, 2019 let justHour = DateFormatters.shared[\u0026#34;HH:mm:ss\u0026#34;] let justHourString = justHour.string(from: now) // 17:11:09 let justHourComponent = DateFormatters.shared[\u0026#34;HH\u0026#34;] let justHourComponentString = justHourComponent.string(from: now) // 17 If at some point I needed a formatter with a format it had already used, it would retrieve it from the dictionary rather than creating a new one.\nConclusion NSFormatter provides many powerful subclasses for formatting data into human-readable form. There\u0026rsquo;s many of them provided by the framework, and you can create your own subclasses if you need to.\nThey have performance implications though, so you should use them carefully, specially if used in table views or other reusable components.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos","nsformatter"]},{"id":"53a4194ba50b5e9a37b1a7c8d8815bab","title":"Understanding the Essentials for Adopting Multiwindow Support on iPadOS","link":"/posts/ipad-multiwindow-support/","content":"On WWDC2019, Apple decided to fork iOS into two different operating systems: iOS for iPhones, and iPadOS for iPads. This is to recognize the iPad as its own independent entity that has its own set of features compared to iOS. Amongst those features, iPadOS adds Multiwindow support, which allows our apps to run in more than one Window at the same time.\nWhat exactly is Multi-window support, and how does it work? iOS 9 introduced the Slide Over and Split Screen features for iPad, which allowed us to run two different apps side by side at the same time. Multi-window support on iPadOS allows you to do this with two windows of your own app, and more.\nThe original Slide Over and Split Screen allowed you to open two different apps at the same time.\nOn iPadOS, you can now have two windows open for the same app at the same time.\nYou can even have open multiple instances of the same app (though only have two visible at the same time) if you are working with multiple documents. The Notes.app is a perfect example of this.\nWhen you open the App Switcher and slide the current open app up, you will see all the Windows open for that app and can open any of them easily\nThere is also the equivalent of Mission Control for currently open apps.\nYou can put an app floating on top of another one, and stack different windows for the same app or different apps.\nThe Notes.app is open and I have Tweetbot on top of it. This is useful if you are not heavily working with two documents but need to switch often between different apps.\nIf you slide up the Tweetbot Window, you will see all the Windows you have open for both the current app, and other apps. In this screenshot, the Notes.app is running full-screen, and I have Windows for Tweetbot and a few others, along with two Windows for the Notes.app.\nMulti-window support is great and many of your users will expect it to work with your app when iPadOS 13.1 launches at the end of the month. Unfortunately, the majority of this functionality does not come free. If you added Slide Over support for iOS 9 and above, you have a few cases covered, but to actually support multiple windows at once, you have a bit of work to do.\nImplementing Multiwindow on iPadOS. The set of APIs you use to implement Multiwindow support is the UIScene APIs. These includes:\nUIScene UISceneDelegate UIWindowScene UIWindowSceneDelegate UISceneSession With these APIs we can implement Multiwindow Support in our apps with as little effort as possible.\nUnderstanding Scenes \u0026ldquo;Scenes\u0026rdquo; is just a fancy name for windows. Whenever you see the word scene, think of a window.\nWhere to add scenes in your app It doesn\u0026rsquo;t always make sense to support multiple windows. If you decide to add them, you have to consider what users think of them. It\u0026rsquo;s important that users can do everything in just one window, and if your app NEEDS multiple windows, your app can be confusing to use.\nDocument-based apps are very good candidates to add Multiwindow support. Apps like Notes, Pages, and Numbers support Multiwindow and let you open multiple documents at once.\nApps like Safari support multiple windows of the same \u0026ldquo;type\u0026rdquo; (A web browser). It makes sense to have multiple Safari windows open, but they are all going to have the same thing in them: A website.\nIn the case of Mail, you can open multiple e-mails, but you can also open different compose windows as you need them.\nMessages allow you to open different threads in different windows.\nCatalyst Support Multiwindow apps are fully supported on the Mac.\nWhat interactions that should support multiple windows? On iPadOS, you can drag and drop multiple elements to create new windows. In the Notes.app, you can drag and drop notes in the notes list to create a new window. Safari lets you drag and drop tabs to create windows for them. In master-detail views, which is what the Notes.app is, users are going to expect this behavior, so you should definitely look into implementing it.\nOn Safari, if you press and hold on a link, you get the option to open in a new Window. The API offers a lot of functionality to open new windows through different kinds of interactions.\nApp Lifecycle Changes If you have been programming for iOS for a while, there is a very drastic change to how the lifecycle of the application works. Many things that have been there since the very first public SDK have either been changed or removed. This is a very big change, but if you adapt to it you shouldn\u0026rsquo;t have problems supporting multiwindow support in your apps. Older apps may have problems adapting to it, though.\nIf you create a new iOS 13 project, one of the first things you will notice is that the app delegate has lost weight, it has lost some methods, and it has gained a new ones. This is what the App Delegate looks like in Xcode 11 GM 1:\n@UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { // Override point for customization after application launch. return true } // MARK: UISceneSession Lifecycle func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -\u0026gt; UISceneConfiguration { // Called when a new scene session is being created. // Use this method to select a configuration to create the new scene with. return UISceneConfiguration(name: \u0026#34;Default Configuration\u0026#34;, sessionRole: connectingSceneSession.role) } func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set\u0026lt;UISceneSession\u0026gt;) { // Called when the user discards a scene session. // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions. // Use this method to release any resources that were specific to the discarded scenes, as they will not return. } } Adopting the UIScene Lifecycle UIWindowScene and UISceneSession are the main APIs used for Multiwindow support.\nConceptually, your app is still going to have one UIScreen, but on top of that UIScreen you may have one or more UIWindowScenes, and each UIWindowScene may have multiple UIWindows. UIWindows can still hold one or more UIView.\nA Scene contains your user interface, and the system will crate it on-demand for you. The system will also destroy it as needed.\nA UISceneSession represents a persistent UI state of what your users were doing last. They have a defined system role. Every time a new window is created in the system, your app is notified through its delegate that a new Window has been created. UIScenes connect and disconnect from these sessions over the lifetime of your app.\nA significant change is that the app delegate used to handle a lot of events for us. The delegate is still going to process events and lifecycle related to events (background tasks and the like), but a lot of the work hs been delegated to the UIScene APIs. A UIWindowScene will manage your apps UI state. The UIWindowSceneDelegate will be notified of events related to UI and lifecycle. The UISceneSession persists your UI state.\nWhere you used to ask questions regarding the UIStatusBar to the app delegate, the question now needs to be asked to the scene instead. The app delegate, which also used to be responsible for opening URLs, no longer does this. Instead the UISceneDelegate now handles all the open URL operations instead. Going to the background, foreground, and those app lifecycle events are now handed to the scene as well. Do you want to know if the app has finished launching? You no longer handle that in the app delegate, instead you do it in the scene delegate\u0026rsquo;s scene(_:willConnectTo:options:) method. I really recommend you check the documentation to learn how the app delegate has been spread across the UIScene API.\nBecause of the lifecycle changes, a lot of UIApplication methods have been deprecated. These include:\nstatusBarStyle statusBarHidden statusBarOrientation open(_:options:completionHandler) keyWindow Remember to ask the window scene for these properties from now on:\nUIWindowScene.statusBarManager UIWindowScene.interfaceOrientation UIWindowScene.open(_:options:completionHandler:) And for windows, track them manually. State restoration is now a NSUserActivity which is requested from the UISceneDelegate. You can access it any time through the UISceneSession.stateRestorationActivity property.\nCreating Scenes with Code The system can create scenes for you when the user interacts with your app via storyboard. In Expos√© for example, you can tap the \u0026ldquo;+\u0026rdquo; button to create a new window in apps that support it.\nBut it\u0026rsquo;s also possible to create new scenes with code. UIApplication has some methods to make this possible. As we said, the system will create UIScenes so you never have to worry about creating a UIScene yourself. Instead let the system know you want a new scene with these calls:\nrequestSceneSessionActivation(:userActivity:options:errorHandler:): Use this method to create new scenes. Pass it the NSUserActivity it will need to create new windows. updateSceneSessionRefresh(_:): Update existing scenes. requestSceneSessionDestruction(_:options:errorHandler:): To close scenes. You can use these methods to create new methods based on user interaction. Whether you have a button that is explicitly called \u0026ldquo;open document in new window\u0026rdquo; or want to respond to drag events, you can use these methods to create new scenes.\nLearn More I focused the majority of this article in the Introducing Multiple Windows on iPad WWDC19 session video. I tried to summarize the most important parts of the video.\nConclusion Multiple Windows on iPad are a game change for the platform. The UIScene APIs give a lot of flexibility without offering an over-complex API.\nUsers are going to expect apps to support. See how Apple implements multiwindow support to get ideas about how you can implement them yourself.\nYou should be careful of the application lifecycle changes before you implement it, as the lifecycle we have known for the past 10 years has finally been changed.\n","tags":["swift","programming","apple","ios","ipados","wwdc2019"]},{"id":"f72ed5e6d1e4bcb16c66d47daedf10b6","title":"Understanding the Result Type in Swift","link":"/posts/swift-result-type/","content":"Error handling when expecting a result out of an operation is a very common thing to do. For this reason, various high-level programming languages have introduced a Result type into their libraries, on top of their existing error-handling features. This feature was implemented in Swift 5.\nA Result wraps a success or a failure. It is essentially an enum with two possible cases: .success and .failure. The .success case wraps the correct result of an operation, whereas a .failure wraps an Error. Its implementation uses generics, so you always know what you are going to get back.\nIn this article, we will explore why you would want to use the Result when we can already handle errors with do-try-catch and specifying functions that throw an error with throws.\nUsing Result To understand Result better, we will explore all the ways you could want to write a function to read the contents of a URL into a String. On each step, we will see the shortcomings of the traditional do-try-catch APIs and the advantages of Result. This is a good example to build, because it\u0026rsquo;s a task that is likely to throw an error, and there\u0026rsquo;s different reasons that may trigger it.\nThe Traditional Error Handling Approach. We will start by creating our own error object to handle all file reading operation errors:\nenum StringFileError: Error { case invalidURL } Now, the first attempt to write a file-reading function that can throw errors could look like this:\nfunc readFileFromURL(url: URL?) throws -\u0026gt; String { guard let url = url else { throw StringFileError.invalidURL } return try String(contentsOf: url) } Because the function is marked as throws, we have to handle the error ourselves.\ndo { let fileContents = try readFileFromURL(url: URL(string: \u0026#34;/path/to/file\u0026#34;)) } catch let error as StringFileError { // Handle StringFileErrors } catch { // Handle any other errors thrown by the SDK. } When trying to read a file from a URL, we can receive StringFileErrors or we can receive Errors, depending on what the problem is.\nThat code gets the job done, but we can improve it with the new Result type.\nImplementing Result Over Traditional do-try-catch To start using result, we can change the signature of the function and its implementation to return a new Result\u0026lt;String, Error\u0026gt; instead. It\u0026rsquo;s still far from what we want to achieve, but we will get there in a second.\nfunc readFileFromURL(url: URL?) -\u0026gt; Result\u0026lt;String, Error\u0026gt; { return Result\u0026lt;String, Error\u0026gt; { guard let url = url else { throw StringFileError.invalidURL } return try String(contentsOf: url) } } To use it, we need to change a few things and even add an extra line of code:\ndo { let fileContentsResult = readFileFromURL(url: URL(string: \u0026#34;/path/to/file\u0026#34;)) let fileContents = try fileContentsResult.get() } catch let error as StringFileError { // Handle StringFileErrors } catch { // Handle any other errors thrown by the SDK. } This is not really a good example of when you\u0026rsquo;d want to use result. The most important feature of Result to me is that you can start using type-safe errors. One of the biggest weaknesses in Swift right now is that errors are not type-safe. Despite how strong-typed Swift is, there is no way to tell if a function can throw specific errors (like StringFileError) - everything just throws and whatever it throws can be an Error of any type, whether it is the high-level Error itself or specific implementations.\nIf you knew that all your file paths are always going to point to a valid file, for example, you can specify the error in result to be of StringFileError, and we gain some additional safety.\nWe can also rewrite the implementation of function, while still using result. Sometimes, initint a result type with the closure can be a bit tricky, so we can instead make our function return .success or .failure.\nfunc readFileFromURL(url: URL?) -\u0026gt; Result\u0026lt;String, StringFileError\u0026gt; { guard let url = url else { return .failure(.invalidURL) } return .success(try! String(contentsOf: url)) } To handle the error, we now have just one case to consider, so we can get rid of the last catch clause.\ndo { let fileContentsResult = readFileFromURL(url: URL(string: \u0026#34;/path/to/file\u0026#34;)) let fileContents = try fileContentsResult.get() } catch { // Now all the possible errors are StringFileErrors, so we can simplify the catch clauses into one } And you can make it even prettier:\nlet fileContentsResult = readFileFromURL(url: URL(string: \u0026#34;/path/to/file\u0026#34;)) switch fileContentsResult { case .success(let contents): print(contents) case .failure(let stringFileError): // Handle error } Conclusion One of Swift\u0026rsquo;s weaknesses is that it can\u0026rsquo;t deal with errors in a type safe manner despite how strongly-typed it is. The Result type helps us write code where errors are typed, and this can help us write cleaner code.\n","tags":["swift","programming","apple","ios","macos","tvos","watchos","ipados","result","error","wwdc2019"]},{"id":"118dbe555c94ff19364e025cd3dd2134","title":"Building URLs With NSURLComponents","link":"/posts/building-urls-with-nsurlcomponents/","content":"If you have been programming for Apple platforms for a while, chances are you have seen (or maybe even wrote yourself) a line of code that looks like this:\nlet url = URL(string: \u0026#34;https://www.google.com/search?hl=en\u0026amp;q=pullip\u0026#34;)! Whether you wrote it yourself or someone else did it, one thing is clear: This is not a safe way to build URLs. Can you know, for sure, that your URL is actually valid? Intuitively, all of us can see a URL and see if it\u0026rsquo;s valid, but there is a whole lot of governing in the URL format that at some point we may find funny URLs that look valid and aren\u0026rsquo;t, or the other way around; they look invalid, but aren\u0026rsquo;t.\nIn this article we will explore a very handy class for both URL composition and decomposition: NSURLComponents.\nIntroduction to NSURLComponents Calling web APIs is a very common task that the vast majority of developers are going to do at some point. To do that, the iOS/iPadOS, macOS, TVOS, and watchOS SDKs have a nice set of tools that make networking easier. The process of creating a URL seems obvious with the simple init(string:) constructor of NSURL, but a URL has many more components, and it may be easier to write a bit more code to ensure you actually have a valid URL.\nNSURLComponents is a class that allows us to both build URLs and decompose them into their essential parts. Using it, we can safely build valid URLs by just passing in the parts (components) we need. Other than making it easier to build URLs, it also handles some encoding details for us, so we don\u0026rsquo;t have to care about escaping characters ourselves, especially in query strings.\nBuilding URLs Let\u0026rsquo;s go back to the old URL we used as an example at the beginning of this article.\nlet url = URL(string: \u0026#34;https://www.google.com/search?hl=en\u0026amp;q=pullip\u0026#34;)! We will try to build this URL using NSURLComponents. It is a little bit more code, but the peace of mind is worth it, and it also helps us understand how URLs work a bit better, without having to refer to the entirety of RFC-1738.\nFirst, we will build the URL up to the /search components, and we will be excluding the query (everything after the ?).\nvar components = URLComponents() components.scheme = \u0026#34;https\u0026#34; components.host = \u0026#34;www.google.com\u0026#34; components.path = \u0026#34;/search\u0026#34; if let url = components.url { print(\u0026#34;URL: \\(url)\u0026#34;) } Like we would expect, this will print URL: https://www.google.com/search. This an example of a very simple URL, but be aware that URLs may have some additional components (and we do not need to set all the properties in order for them to be valid). For example, not all URLs have a path, and we can safely ignore the host and schema too. Try deleting these properties and see what URL you get back.\nThere\u0026rsquo;s a few additional components in URLs that we will not cover in this article, but it\u0026rsquo;s worth mentioning them:\nfragment: If a URL contains a # symbol, the fragment is everything after it. user and password: Some URLs require some basic authentication to access them. We can use these properties for such credentials (i.e. https://andy:masterpassword@www.google.com). port: If we need to specify the port of a resource, this is the right property. query: We will actually explore this one, but not as a string component. The query of a URL is everything after a ? sign. URLs with Queries The query part of a URL (everything after a ?) is composed of zero or more key-value pairs.\nTo build the query component of a URL, we could use NSURLComponents\u0026rsquo; query property, which is a string. This is a quick and dirty way of doing it, but we lose some safety and if we use this, we might as well not use NSURLComponents at all.\ncomponents.query = \u0026#34;hl=en\u0026amp;q=pullip\u0026#34; What we should use instead is use another class whose only purpose is to create these key-value pairs. That class is URLQueryItem, and it\u0026rsquo;s very easy to use. It has one simple constructor which takes the name of the parameter (the \u0026ldquo;key\u0026rdquo;), and the value of it.\nlet hl = URLQueryItem(name: \u0026#34;hl\u0026#34;, value: \u0026#34;en\u0026#34;) let q = URLQueryItem(name: \u0026#34;q\u0026#34;, value: \u0026#34;pullip doll\u0026#34;) components.queryItems = [hl, q] We all love Swift, so let\u0026rsquo;s take a moment to make this Swiftier:\ncomponents.queryItems = [\u0026#34;hl\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;q\u0026#34;: \u0026#34;pullip\u0026#34;] .map { URLQueryItem(name: $0, value: $1) } With this, we can now build our query strings with the certainty that they are going to be valid when building URLs.\nDecomposing URLs Into Their Components NSURLComponents can be used for both composing and decomposing URLs. This is very useful, specially if we use the URL mechanism Apple has in place for app communication.\nOne such example of this is iOS with its URL app launching mechanism. Our apps can register schemes to launch other apps, and also other apps can launch ours if they register our scheme.\nWhen an app launches ours, this application delegate method is called:\napplication(_:url:options:) And we can use this to perform certain tasks in our app.\nWe could decide that an app calling this URL is going to print the passed text into the console:\nmyapp://print?text='Hello+Alice'\nYou could try to grab the underlying string of the passed NSURL, splitting the string with a token and parsing the components ourselves. But this takes a lot of work, is error prone, and there\u0026rsquo;s no need to do it since NSURLComponents can do it for us.\nIn the following code, we will decompose the above URL with NSURLComponents, grab the text query parameter, and prints its value.\nfunc application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -\u0026gt; Bool { let components = URLComponents(url: url, resolvingAgainstBaseURL: true) components?.queryItems?.forEach { // In case our app grows and we start passing in bigger queries with the URLs, we will check we grab the ones we need and work with each parameter as required. if $0.name == \u0026#34;text\u0026#34; { print($0.value ?? \u0026#34;\u0026#34;) } } return true } Conclusion While NSURLComponents does require more code to write, using it has a lot of benefit. Automatic encoding, security, and peace of mind are some of the benefits it brings to us when building URLs. Being able to decompose existing URLs into their components is also a useful thing, especially on systems where app communication through URLs is prevalent.\n","tags":["swift","programming","apple","ios","macos","tvos","watchos","ipados","urls","networking","nsurl"]},{"id":"bf6ab785646dfeae4c4f5f6039859d12","title":"Caching Content With NSCache","link":"/posts/caching-content-with-nscache/","content":"When we are working with apps on iOS, iPadOS, macOS, watchOS, or TVOS, it\u0026rsquo;s possible that at some point we will have to store and retrieve a lot of temporary data throughout the lifecycle of our software. Depending on our needs, we may need to cache data on disk and manually manage it ourselves, or we may only need it to cache it in memory. In the case of the latter, Apple offers NSCache, a mutable collection that lets us cache files in memory using key-value pairs.\nNSCache is really nice for a few reasons:\nIt stores data in memory only. If our app gets killed, this memory is freed up and it\u0026rsquo;s not persisted to disk. The key-value pair mechanism lets us very easily set and get cached content. Very similar to what we would do with a Dictionary. Unlike a dictionary, the keys are not copied, so it\u0026rsquo;s slightly more memory efficient. We can set automatic eviction conditions to help NSCache delete objects automatically. We can also manually evict objects if we need to. It is multi-threading friendly. We can read and write the cache without having to manage threading ourselves. And there is just one reason it is not perfect:\nIt\u0026rsquo;s an Objective-C API, so you will end up doing some casting, even when working with basic objects such as strings. Use NSCache to store temporary objects that are expensive to create, but can be re-created if necessary. Suppose we have an app that downloads a lot of images to display to the user dynamically and they are very big - downloading them takes a long time and they consume a lot of data. It would be bad to re-download them these images every time the user needed them, so we can cache them instead. If at some point the system starts demanding memory, the system can just remove these images and we can re-download them if necessary.\nNSCache is available in all of Apple\u0026rsquo;s Platforms: watchOS, iOS, iPadOS, macOS, and TVOS.\nNSCache Basics Creating a NSCache Object The constructor of the NSCache object takes two generic objects: The key type, and the cached object type. We can optionally give it a name to identify it later.\nlet cache = NSCache\u0026lt;NSString, UIImage\u0026gt;() cache.name = \u0026#34;Remote Image Cache\u0026#34; This API has its roots in the Objective-C days, and as such the generic parameters are constrained to conform to AnyObject, meaning that we cannot use structs and must uses classes instead. For that reason we must use NSString instead of String. Both our keys and objects can be of any type as long as they are classes. In this example we chose strings for the keys, and images for the objects.\nStoring Objects Storing an object is as easy as calling the cache\u0026rsquo;s setObject method.\nlet webImage = UIImage(named: \u0026#34;pullip_doll.png\u0026#34;)! cache.setObject(webImage, forKey: \u0026#34;top banner\u0026#34;) There is also an overloaded setObject(object:forKey:cost:) method, which we will talk about in a bit.\n(I\u0026rsquo;d love it if the API offered a subscript for this kind of task, but sadly that\u0026rsquo;s not the case.)\nRetrieving Objects Retrieving objects is just as easy. There\u0026rsquo;s just one method called object(forKey:). This method returns an optional ObjectType (in our case, an optional UIImage), so we can easily check if the object exists. Whether the object no longer exists or it has been evicted, it will return nil.\nif let webImage = cache.object(forKey: \u0026#34;top banner\u0026#34;) { // Do something with webImage print(\u0026#34;The object is still cached\u0026#34;) } else { print(\u0026#34;Web image went away\u0026#34;) } (Just like before there\u0026rsquo;s no native subscript for this.)\nRemoving Objects Deleting objects does not possess any kind of complexity, and there\u0026rsquo;s methods to evict either a single object or the entire cache.\nTo remove a single object, just call the cache\u0026rsquo;s removeObject(forKey:) method.\ncache.removeObject(forKey: \u0026#34;top banner\u0026#34;) And to remove all the objects, simply call removeAllObjects() on the cache.\ncache.removeAllObjects() Automatic Eviction Conditions Having manual control over the cache is important and it\u0026rsquo;s going to be enough for many cases, but NSCache allows us to set conditions to automatically clean after itself. We can constrain it to hold a limited amount of objects, and we can specify a maximum \u0026ldquo;cost\u0026rdquo;.\nEven when we don\u0026rsquo;t set any eviction conditions, NSCache will start deleting objects if the system is really hungry for memory, so we cannot count on our objects always being there, even we don\u0026rsquo;t set any eviction conditions ourselves.\nLimiting the Amount of Objects in the Cache To limit the amount of objects our cache should hold, set the countLimit property to anything higher than 0. 0 means no limit, so the cache will keep storing objects indefinitely (unless the system really needs some memory, that is).\ncache.countLimit = 10 What a good size is depends strictly on our application. If we are dealing with big images, we can set a low number here, but in the case of something smaller, such as strings, it can probably be way higher.\nIt\u0026rsquo;s worth noting that this is not a strict limit. The eviction of objects is governed by the implementation of the cache. If the cache goes over the limit, it may remove objects instantly, at a later moment, or possibly even never. It will all depend on the needs of the system at a given time.\nSetting a Maximum Cost Definition of Cache Object Cost The \u0026ldquo;cost\u0026rdquo; of an object in the cache is a bit abstract, and it depends on the context in which a cache is operating.\nLet\u0026rsquo;s go back to the example of storing images in the cache. We can define the \u0026ldquo;cost\u0026rdquo; of an image as its size in bytes. A bigger image will have a bigger cost. We could find a different definition, such as its size in dimensions (it\u0026rsquo;s weight and height).\nIf you wanted to store strings, you could define the \u0026ldquo;cost\u0026rdquo; based on the number of characters in each string. So the string \u0026quot;Pullip Classical Alice\u0026quot; (22 characters) has a bigger cost than \u0026quot;Pullip Alura\u0026quot; (12 characters).\nLimiting the Maximum Total Cost of the Cache To set the maximum cost, set the totalCostLimit property of the cache. This number is an Int, and once again, what exactly it represents depends on the context of each cache.\n// For our image cache, we will set a maximum cost of 50,000,000 bytes, or 50 megabytes. cache.totalCostLimit = 50_000_000 Now, when we want to add objects along with their cost, we can use the setObject(object:forKey:cost:) method we mentioned above.\n// Convert the image to Data. if let topBannerData = webImage.pngData() { // The cost of our image is its size in bytes. cache.setObject(webImage, forKey: \u0026#34;top banner\u0026#34;, cost: topBannerData.count) } Just like setting the maximum total objects, though, this is not a strict limit, and the cache will decide what to do with the objects once the limit is surpassed. If it needs to start evicting objects, it will start deleting some until the total cost of the cache is under the totalCostLimit. Keep in mind that the order in which the objects will be removed is random. We cannot, for example, expect the cache to start removing the biggest cost objects first (in our example, the biggest images), and there\u0026rsquo;s no way to enforce a specific order.\nThe NSDiscardableContent Protocol The NSDiscardableContent protocol can be implemented when an object has subcomponents that can be discarded when not being used.\nSuppose we have a class Person that looks like this:\nclass Person { let firstName: String let lastName: String var avatar: UIImage? = nil init(firstName: String, lastName: String, avatar: UIImage?) { self.firstName = firstName self.lastName = lastName self.avatar = avatar } } We want to cache this, but the firstName and lastName properties are probably too small to care about them persisting for a long time. On the other hand, the avatar can be big, so we want to remove only the avatar property when the system needs it. In this case, Person is a content-object, and the avatar property is the subcomponent that can be discarded.\nNSCache allows us to do this by implementing the NSDiscardableContent in our objects.\nNSDiscardableContent works with a simple variable counter system. When the memory is being read or is currently needed, its counter will have a value of 1. If it\u0026rsquo;s not needed at all and is not being used, the counter will be 0. When a new ``NSDiscardableContentis created, it's counter value starts with1. We will see how we can make use of this to help NSCachemanage ourPerson` class.\nWhen we conform to NSDiscardableContent, there\u0026rsquo;s four methods we must adopt:\n// True if the content is still available and have been successfully accessed. func beginContentAccess() -\u0026gt; Bool { } // Called when the content is no longer being accessed. func endContentAccess() { } // If our counter is 0, we can discard the image. func discardContentIfPossible() { } // True if the content has been discarded. func isContentDiscarded() -\u0026gt; Bool { } We can implement Person conforming to the protocol the following way:\nclass Person: NSDiscardableContent { let firstName: String let lastName: String var avatar: UIImage? = nil // Our counter variable var accessCounter = true init(firstName: String, lastName: String, avatar: UIImage?) { self.firstName = firstName self.lastName = lastName self.avatar = avatar } // MARK: - NSDiscardableContent func beginContentAccess() -\u0026gt; Bool { if avatar != nil { accessCounter = true } else { accessCounter = false } return accessCounter } func endContentAccess() { accessCounter = false } func discardContentIfPossible() { avatar = nil } func isContentDiscarded() -\u0026gt; Bool { return avatar == nil } } Now we can create a cache of Persons. But there is one more thing we need to do.\nBy default, NSCache will evict all the objects it contains. In our case, it will discard Persons as necessary, and not just their avatar. To change this, set the cache\u0026rsquo;s evictsObjectsWithDiscardedContent property to false.\ncache.evictsObjectsWithDiscardedContent = false This property, whose default value is true, controls whether entire objects from the cache will be removed or just their discardable content. Setting it to false will ensure it just discards the avatars and not whole Persons.\nWe can new create a new cache object of Persons and add objects to it.\nlet cache = NSCache\u0026lt;NSString, Person\u0026gt;() cache.name = \u0026#34;Person Cache\u0026#34; cache.evictsObjectsWithDiscardedContent = false let andy = Person(firstName: \u0026#34;Andy\u0026#34;, lastName: \u0026#34;Ibanez\u0026#34;, avatar: UIImage(named: \u0026#34;silight.png\u0026#34;)) cache.setObject(andy, forKey: \u0026#34;me\u0026#34;) Now, when the cache starts deleting Persons, it will only delete their avatars.\nThe NSCacheDelegate Protocol To finish off this post, we can talk about the NSCacheDelegate protocol, which allows to see what a specific cache is doing. Currently, the delegate only has one method, cache(_:willEvictObject), which allows us to know when an object is being removed.\nfunc cache(_ cache: NSCache\u0026lt;AnyObject, AnyObject\u0026gt;, willEvictObject obj: Any) { if let person = obj as? Person { print(\u0026#34;Cache \\(cache.name) will evict person \\(person.firstName) \\(person.lastName)\u0026#34;) } } When an object is about to be deleted, we will be notified, which allows us to take some action. For now, we will just print who the person is that is being evicted.\n(As is the case with the other API examples above, this comes from Objective-C, so we have to do some casting.)\nConclusion NSCache is a good API to cache content that you only need in memory. You can both control the contents manually, or you can set conditions to allow the cache to manage itself. Being an Objective-C object at its core, it has some quirks to work with, but it\u0026rsquo;s still very easy to use.\n","tags":["swift","programming","apple","ios","macos","tvos","watchos","ipados"]},{"id":"f158c4b2a12feff3d5c8f0e72591cffc","title":"Old Content","link":"/old-content/","content":"It looks like you followed a link to a very old article or tutorial. When I worked on my new website, I went through all my posts and just migrated the ones that are still relevant. Some old posts were not irrelevant per se, but the way they were written don\u0026rsquo;t really apply anymore.\nIf you still want to read the original post of the link that got you here, you can download an archived version of my website and look for it there. This archive is a fully usable local copy of my old website, and you will definitely find the article you were looking for.\nSorry for the inconvenience.\nDownload old andyibanez.com Archive\nIn the future more of the older posts may be rewritten from scratch. But I do not know which ones yet.\n","tags":null},{"id":"f2a627a783eea562f880209945dd3fd2","title":"Exploring the NSOperation APIs for Apple's Platforms","link":"/posts/exploring-the-nsoperation-apis/","content":"The original title for this article was posted on my old website in 2012 and it was titled \u0026ldquo;Multithreading on iOS And Mac OS X Using NSOperations\u0026rdquo;. The original examples were written in Objective-C. This article has been rewritten from scratch not only to give the examples in Swift, but also to improve the quality of the old article. It has been shortened, and both language and tone have been revised.\nWriting concurrent code is important and something that is done for almost all non-trivial apps. If you want your app to handle expensive tasks without causing a bad experience for users (freezing the main thread), you will eventually have to deal with concurrency. And the good news is, if your concurrent task is complex enough, you can simplify how it\u0026rsquo;s done with the help of an API that has been there for a very long time, but is ignored by many developers of Apple platforms: NSOperations.\nConcurrency on iOS and macOS is nothing new. The technologies have also been moved to TVOS and watchOS. In fact, there\u0026rsquo;s four concurrency methods that you can do in all these platforms:\npthreads NSThread Grand Central Dispatch (GCD) NSOperation Sorted from lower level to higher level, the vast majority of Apple developers will never touch pthreads (POSIX threads) or NSThreads, (though they can drop down to those levels if they need to for extremely sensitive performance applications), and most of them use the GCD in their day-to-day jobs. The GCD works fine for the vast majority of concurrent apps, and many developers will not need the extra functionalities offered by NSOperations.\nBut, while the GCD provides a great concurrency API for developers, sometimes your tasks may not scale well with it. The power of the NSOperation APIs is that they provide a high level interface for concurrency, and it allows you to set dependent tasks of each other very easily. Suppose you want to write an app that downloads photos from a Flickr feed, and after downloading them you want to apply a black and white filter on them. You can achieve this while creating a Download operation and a Filtering operation that depends on the Download operation.\nIn this article we will explore the NSOperations API and we will write some very basic code to show how they work, how to create dependent operations, and more.\nNSOperation Classes The NSOperations API has a few classes that make it easy to interact with it.\nThe NSOperation class represents a task that you want to do concurrently. The code you want to perform concurrently is encapsulated within a NSOperation subclass. NSOperation itself is considered an abstract class, and as such you never use it directly (technically there isn\u0026rsquo;t the concept of an abstract class in either Swift or Objective-C, but the documentation uses that word when describing the API), but it provides a few subclasses that you can use instead.\nThe two subclasses Apple provides are:\nNSInvocationOperation: When using this class, you use the familiar target-action pattern to define what object should call what method as a concurrency task. You can use this subclass when you have an object with a method that you want to use in both concurrent threads and in your main thread. It also gives you a lot of flexibility thanks to the underlying dynamic Objective-C dispatching. It\u0026rsquo;s very important to note that you can\u0026rsquo;t use this one in Swift. The underlying class needed by this subclass to work (NSInvocation) is not available to be used in Swift. You can find more info about this here, so in this article we will not cover this subclass. NSBlockOperation: You can use this operation to execute various closures at once. An NSBlockOperation is considered to have finished running when all its blocks have completed their execution. You can also write your own NSOperation subclasses, but doing so is very complicated, unusual, and often unnecessary. The documentation has some helpful subclassing notes, but chances are you will never have to do this. In this article, we will not explore how to do that as it is an extremely nich√© case.\nAll NSOperation subclasses support the same handy features:\nYou can use dependencies to tell an operation to only execute once another operation has finished running. You can monitor their state through the use of Key-Value Observing. You can cancel operations at any time, whether they are running or have yet to run. You can implement your custom cancellation events if you need to. When you have an NSOperation subclass ready, you will normally want to hand it over to an NSOperationQueue. You can actually choose to start each operation directly by calling their start() method, but doing so does not guarantee that the operation will run in a different thread. It could choose to run in your main thread. Using the queue is the only way to ensure your tasks are actually concurrent. All operations have a method called isConcurrent which you can use to check if they are running in a background thread or in your main thread.\nYou can query the status of your operations by some properties. All operations have the following:\nisConcurrent. You can use this one to see if the operation is running in a different thread than where it was called or not. isExecuting isFinished isCancelled Exploring the API With all that theory out of the way, it\u0026rsquo;s time to get our feet wet. We will be running these examples in a simple Command Line project in Xcode.\nNSBlockOperation Using NSBlockOperation is very easy. In the example below, we will create two different NSBlockOperation. One will count from 1 to 10, and the other one will count from 11 to 20. You will see that there\u0026rsquo;s no consistent order in how the numbers are printed, despite the fact that we queue the from1to10operation before from11to20.\nclass NumberCounter: NSObject { func startCounting() { /// We will need a queue for this. let operationQueue = OperationQueue() /// You can give your queue an optional name, if you need to identify it later. operationQueue.name = \u0026#34;Counting queue\u0026#34; /// This will just count from 1 to 10... let from1To10 = BlockOperation { for i in (1 ... 10) { print(i) } } /// ... and this from 11 to 20 let from11To20 = BlockOperation { for i in (11 ... 20) { print(i) } } /// Add the operations to the queue operationQueue.addOperation(from1To10) operationQueue.addOperation(from11To20) /// To ensure the program doesn\u0026#39;t exit early while the operations are running. operationQueue.waitUntilAllOperationsAreFinished() } } let counter = NumberCounter() counter.startCounting() Run this sample of code a couple of times. You will see that each time, the order of the numbers is different.\nTo fix this, we will make from1to10 be a dependency of from11To20. When we do this, the numbers will be printed in the order you expect, no matter how many times you run the program. Add this code before you add the operations to the queue:\n/// from11To20 should depend on from1To10, so the numbers are added in the right order. from11To20.addDependency(from1To10) And just like that, the numbers will be printed in the right order, since from11To20 will not run unless from1To10 has completed its execution.\nA Tiny Trick As I was writing this, I noticed that you can directly add a block to a NSOperationQueue without having to wrap it in a NSBlockOperation. It looks like this:\noperationQueue.addOperation { for i in (21 ... 31) { print(i) } } This makes simpler concurrency easier to do in some cases. Just keep in mind that since you are passing a block directly, you do not have the same benefits as NSBlockOperation. For example, you will not be able to cancel this operation early, and you cannot query it\u0026rsquo;s state with its properties.\nConclusion The NSOperation API is really good to do complex concurrently easily. You have a lot of control over your operations and managing dependencies is very easy.\n","tags":["swift","programming","apple","ios","ipados","macos","tvos","watchos"]},{"id":"33a4370f81c398f8b0a450590ac3386b","title":"rclone: From Basics to Encryption","link":"/posts/rclone-basics-encryption/","content":"The original version of this article was titled \u0026ldquo;rclone and Encryption Tutorial\u0026rdquo; and was posted in the old version of my website. The original article was written in February 2017 for a much older version of rclone. This revised article covers rclone 1.48, and it has been rewritten from scratch to improve its quality. The examples used in the original article have been kept.\nrclone is a command line tool, similar to rsync, with the difference that it can sync, move, copy, and in general do other file operations on cloud storage services, such as Dropbox and Google Drive. You can use rclone to create backups of your servers or personal computers or to simply store your files in the cloud, optionally adding encryption.\nrclone supports many different services, from customer services like Dropbox, Google Drive, and One Drive, to bucket-based storage services such as Wasabi and Backblaze 2, and even more traditional protocols such as FTP and Webdav. It even supports the local filesystem, so you can use rclone fully locally as well. For a list of all supported services and protocols, see this page.\nGetting Started Installation The installation process for rclone is straightforward. There\u0026rsquo;s little point in me explaining how to install it, because the installation instructions page has instructions for all major OSes.\nIf you are on a Mac, I suggest you install it with Homebrew. If you have Homebrew installed, just type this command in your terminal followed by the Enter key:\nbrew install rclone If you are on Windows instead, you can install it with Chocolatey. Simply open a Console window and type the following, followed by the Enter key:\nchoco install rclone Once you have it installed, we\u0026rsquo;ll explore some basic terminology to get you started with rclone.\nBasic Terminology The most important concept of rclone is the remote. A remote is simply a cloud service you have configured in the tool. For example, if you configure your Dropbox account, it becomes a remote. You can have more than one remote for each cloud service type, so if you have two Dropbox accounts, you can configure a remote for each. You can then interact with your remotes with the command line. If you added your Dropbox and Google Accounts, you can share files between them (note that in that case the files will be downloaded to your computer before being sent to the destination remote), and you can also send files from your local filesystem to a remote, and vice-versa.\nWith rclone, you execute commands. Things like copy, move, sync are all rclone commands. There\u0026rsquo;s many more, and this article will not even cover half of them. It\u0026rsquo;s good to know which ones exist though, so you can start adapting rclone to your use cases. Run the following command:\nrclone And the output will give you a list of commands rclone can do. It looks like this (this list has been truncated):\ncopy Copy files from source to dest, skipping already copied copyto Copy files from source to dest, skipping already copied copyurl Copy url content to dest. cryptcheck Cryptcheck checks the integrity of a crypted remote. cryptdecode Cryptdecode returns unencrypted file names. dbhashsum Produces a Dropbox hash file for all the objects in the path. dedupe Interactively find duplicate files and delete/rename them. delete Remove the contents of path. rclone commands typically have at least two parameters: a source and a destination, where each is a remote. For commands that take two remote parameters, the source goes before the destination.\nMake sure you understand the four concepts above before moving.\nrclone Basics Rclone Configuration You are about to configure your first remote. Open a command line window (or a Console window) and type the following:\nrclone config The config command allows you to add, delete, and modify existing remotes. All your remotes are stored in a config file. If you run the rclone config file command, you will see where your config file is stored. In my system, it prints /Users/andyibanez/.config/rclone/rclone.conf. Generally, you can recreate the contents of this file in another system or in a clean setup, but once we start dealing with encryption things can be a little bit messy in terms of management of your config file, so I recommend you keep a backup of it at all times.\nOne additional thing you can with rclone config is to encrypt your config file itself (not to be confused with encrypted remotes, which we will explore later). Encrypting your config file is useful if you are you going to be using rclone in a computer you don\u0026rsquo;t control, unless you trust the host enough that they aren\u0026rsquo;t going to be looking at your rclone data.\nWhen running rclone, you can also pass it an alternative config file with the --config file. When this flag is missing, it will use the config stored in the path of rclone config file. We won\u0026rsquo;t explore this idea further, but if you want to organize your remotes into different files or have any other use for separate config files, know that the option to have them is there.\nYour first remote Once you run rclone config, you will see an output similar to this:\nName Type ==== ==== GoogleDrive\tgoogle drive e) Edit existing remote n) New remote d) Delete remote s) Set configuration password q) Quit config e/n/d/s/q\u0026gt; Since you do not have any remotes yet, you will not see the first four lines of the output. The first four lines show you your existing remotes and what service they are configured with. In the example above, you can see I have a remote of type google drive. In this example, we will configure a Google Drive remote, but feel free to use other types to experiment.\nPress n followed by the Enter key to create a new remote. The first prompt will be a name. This is just a name you assign to your remote so you can identify it later when doing a command such as rclone listremotes to view a list of all remotes in your config file. The name can be anything, just make sure it doesn\u0026rsquo;t have any spaces. For example, if you want to add two Dropbox accounts, one for personal use and another one for business, you could create two remotes called DropboxPersonal or DropboxBusiness. I\u0026rsquo;ll name mine aibanezDrive.\nThe next prompt will ask you for the Storage type.\n1 / A stackable unification remote, which can appear to merge the contents of several remotes \\ \u0026#34;union\u0026#34; 2 / Alias for an existing remote \\ \u0026#34;alias\u0026#34; 3 / Amazon Drive \\ \u0026#34;amazon cloud drive\u0026#34; 4 / Amazon S3 Compliant Storage Provider (AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, etc) \\ \u0026#34;s3\u0026#34; 5 / Backblaze B2 \\ \u0026#34;b2\u0026#34; 6 / Box \\ \u0026#34;box\u0026#34; 7 / Cache a remote \\ \u0026#34;cache\u0026#34; 8 / Dropbox \\ \u0026#34;dropbox\u0026#34; 9 / Encrypt/Decrypt a remote \\ \u0026#34;crypt\u0026#34; 10 / FTP Connection \\ \u0026#34;ftp\u0026#34; 11 / Google Cloud Storage (this is not Google Drive) \\ \u0026#34;google cloud storage\u0026#34; 12 / Google Drive \\ \u0026#34;drive\u0026#34; 13 / Hubic \\ \u0026#34;hubic\u0026#34; 14 / JottaCloud \\ \u0026#34;jottacloud\u0026#34; 15 / Koofr \\ \u0026#34;koofr\u0026#34; 16 / Local Disk \\ \u0026#34;local\u0026#34; 17 / Mega \\ \u0026#34;mega\u0026#34; 18 / Microsoft Azure Blob Storage \\ \u0026#34;azureblob\u0026#34; 19 / Microsoft OneDrive \\ \u0026#34;onedrive\u0026#34; 20 / OpenDrive \\ \u0026#34;opendrive\u0026#34; 21 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \\ \u0026#34;swift\u0026#34; 22 / Pcloud \\ \u0026#34;pcloud\u0026#34; 23 / QingCloud Object Storage \\ \u0026#34;qingstor\u0026#34; 24 / SSH/SFTP Connection \\ \u0026#34;sftp\u0026#34; 25 / Webdav \\ \u0026#34;webdav\u0026#34; 26 / Yandex Disk \\ \u0026#34;yandex\u0026#34; 27 / http Connection \\ \u0026#34;http\u0026#34; Since we are configuring Google Drive, write in 12 and press Enter.\nImportant Note!\nAt the time this article was written, the current rclone version was 1.48. You can check your rclone version by running:\nrclone version Andys-iMac-2:andyibanez andyibanez$ rclone version rclone v1.48.0 - os/arch: darwin/amd64 - go version: go1.12.6 There\u0026rsquo;s generally no changes with how rclone commands work in each release, but it\u0026rsquo;s very common for each update to add new cloud storage providers. In this current version, Google Drive is option 12, but if you follow this article in a newer version, it\u0026rsquo;s possible that the number assigned to Google Drive has changed. In fact, the initial version of this article which I wrote two years ago back in 2017, had Google Drive on number 7! So be wary of that if you are reading this article and following it step by step.\nMany providers will prompt you for a client_id and a client_secret. You don‚Äôt need these most of the time. In general, if you are having any problems with rclone using specific remotes, the community will recommend you to use these parameters and how they should be used. If you are familiar with how web APIs work for services like Google Drive, then you know how to use these parameters and in that case I recommend you set them - but in case you don\u0026rsquo;t the defaults should work fine, at least for the purposes of this article.\nFor now, press Enter when it prompts you for each to leave them blank. But if you are inclined to fill these values (which is recommended for long term usage anyway), you can go here to find instructions on how to get your client ID and client secret.\nThe output will look like this:\nGoogle Application Client Id Setting your own is recommended. See https://rclone.org/drive/#making-your-own-client-id for how to create your own. If you leave this blank, it will use an internal key which is low performance. Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). client_id\u0026gt; Google Application Client Secret Setting your own is recommended. Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). client_secret\u0026gt; You will then be asked for the scope. This configuration is specific to Google Drive. This setting allows you choose what \u0026ldquo;space\u0026rdquo; it will have in your Google Drive folder. The first option will grant rclone access to every single folder and file in your drive, with the exception of App Data. App Data is a special folder. Generally mobile applications that interact with Google Drive can store their data here and have it inaccessible to anyone outside. Think of WhatsApp for Google Drive - it\u0026rsquo;s backups are stored in the App Data folder and it\u0026rsquo;s not visible even to you. You can choose this folder to give rclone a special container to store files in. This will prevent your main Google Drive view from being polluted with encrypted files that you can\u0026rsquo;t view without rclone itself, which is handy if you use the web client. I personally use this option for my backups, but know that if you use this option, it\u0026rsquo;s really recommended you backup your config file.\nAll other scopes but the first one are outside the scope of this article, so write 1 followed by the Enter key. This will grant rclone standard access to the root of your Google Drive account and it will be able to see all your files and folders.\nScope that rclone should use when requesting access from drive. Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). Choose a number from below, or type in your own value 1 / Full access all files, excluding Application Data Folder. \\ \u0026#34;drive\u0026#34; 2 / Read-only access to file metadata and file contents. \\ \u0026#34;drive.readonly\u0026#34; / Access to files created by rclone only. 3 | These are visible in the drive website. | File authorization is revoked when the user deauthorizes the app. \\ \u0026#34;drive.file\u0026#34; / Allows read and write access to the Application Data folder. 4 | This is not visible in the drive website. \\ \u0026#34;drive.appfolder\u0026#34; / Allows read-only access to file metadata but 5 | does not allow any access to read or download file content. \\ \u0026#34;drive.metadata.readonly\u0026#34; scope\u0026gt; 1 Next you will be asked to put in a root_folder_id. This is an interesting option, but not one we will be using in this article. It allows you restrict rclone to certain folders, even the Computers folders the Backup and Sync program uses to store files in. For now leave it blank and press Enter.\nID of the root folder Leave blank normally. Fill in to access \u0026#34;Computers\u0026#34; folders. (see docs). Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). root_folder_id\u0026gt; You will now be asked for the path to a JSON file (service_account_file). This allows you to change the authentication method with Google Drive. We definitely don\u0026rsquo;t want this now, so leave it blank and press Enter.\nService Account Credentials JSON file path Leave blank normally. Needed only if you want use SA instead of interactive login. Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). service_account_file\u0026gt; After that you will be asked if you want to use advanced configurations. We aren\u0026rsquo;t, so press n followed by Enter.\nEdit advanced config? (y/n) y) Yes n) No y/n\u0026gt; n Finally, you will be asked if you want to use auto config. If you configure rclone in your Mac, or Windows, or in another system with a GUI, you can say \u0026ldquo;yes\u0026rdquo; to this. If you were configuring rclone in a headless system (like SSHing into a Linux system with no GUI), you need to say \u0026ldquo;no\u0026rdquo; to this.\nSince you are working on a Mac, Windows, or Linux with a GUI, press y followed by Enter.\nRemote config Use auto config? * Say Y if not sure * Say N if you are working on a remote or headless machine y) Yes n) No This will launch your default browser with a Google Drive authorization page.\nOnce you are done authorizing your account, you will see another page with this in it:\nIf you are asked if you want to configure it as a team drive, press n followed by Enter:\nConfigure this as a team drive? y) Yes n) No y/n\u0026gt; n rclone will print something like this in the console at the end, showing you information about your newly created remote. It may look differently depending on how and what parameters you have configured.\n[aibanezDrive] client_id = client_secret = token = {...} Press y followed by Enter. Your new remote has been created, and you are finally read to use it.\nInteracting With Your First Remote Before we do anything, run:\nrclone listremotes To view a list of all your remotes. Your newly created remote should look like this:\naibanezDrive: As you configure more remotes, they will show up in that list.\nWe will create a list of files and directories and upload them to our Google Drive account using rclone. I need to remind you that we are currently playing with a non encrypted remote, so don‚Äôt choose any files you wouldn‚Äôt store unencrypted in the cloud. We will create the encrypted remote later.\nGo to your desktop and create a few files there. I created a directory called ~/Desktop/Cards and I created this directory structure with files:\nCards - Sakura - The Mirror - The Fly - The Sword - The Arrow - Shaoran - The Time - The Storm - The Return - The Freeze - None.txt Where Sakura and Shaoran are directories, and everything starting with The is a file. If you want to use this same directory structure, you can run this small bash script to create the files in the same location as mine:\nmkdir ~/Desktop/Cards \u0026amp;\u0026amp; cd ~/Desktop/Cards mkdir Sakura Shaoran touch Sakura/The\\ Mirror touch Sakura/The\\ Fly touch Sakura/The\\ Sword touch Sakura/The\\ Return touch Shaoran/The\\ Time touch Shaoran/The\\ Storm touch Shaoran/The\\ Return touch Shaoran/The\\ Freeze touch None.txt Copying the Local Directory to Your Newly Created Google Drive Remote The command to copy files and directories is very straight forward.\nrclone copy LOCAL_DIRECTORY_OR_FILE REMOTE_DIRECTORY This will copy LOCAL_DIRECTORY_OR_FILE to REMOTE_DIRECTORY. Fun little feature here is that rclone will skip everything that already exists in REMOTE_DIRECTORY by default, so you can use this command to do a very primitive version of incremental backups. For backups, I recommend you use the sync command instead, as it will mirror the LOCAL_DIRECTORY_OR_FILE exactly as it is on REMOTE_DIRECTORY. When you add files they will be added to the destination; when you change files they will be changed in the destination as well; when you delete files, they will also be deleted from the destination. Covering sync is outside the scope of this article, but keep in mind if you are interested in doing backups.\nYou can copy entire directories or single files only. rclone is very flexible in that aspect.\nWhen you want to copy something to a remote, you write your remote name, followed by a :, and finally the path where you want to copy to.\nGoing back to the example we are building, rewrite the last command like this:\nrclone copy ~/Desktop/Cards aibanezDrive:/Cards Depending on your internet connection, it could take a while, but they are all small files so hopefully that\u0026rsquo;s not the case.\nAfter running the command, rclone will give you a nice little report of how everything went.\nTransferred: 0 Bytes (0 Bytes/s) Errors: 0 Checks: 0 Transferred: 9 Elapsed time: 28.9s Always check these stats after running rclone to ensure your destination is not missing any data. When rclone detects the same files on the destination as in the origin already, it will run a Check instead of uploading it directly. This will ensure that, if the files are the same, they are skipped. If the files are different, they will be overridden in the destination.\nLogin to your Google Drive account using your web browser. You will see the Cards directory at the root of your account.\nAnd if you go inside that directory, you will find your other directories and files.\nBack on your terminal or console, you can type rclone lsd aibanezDrive:/Cards. This will list all the contents inside the Cards directory. If you do rclone ls aibanezDrive:/Cards instead, it will list all the contents instead. Be careful with this, because if you have a lot of data, ls can take a very long time to complete, as it will try to list every single file inside the specified path. You should prefer lsd over ls unless you understand how they are used.\nCopying Files From Your Remotes to Your Local Filesystem In the last section we copied local files to our remote. This time we will do it the other way around. Doing this is as easy as switching the source and destination around.\nGo ahead and upload any file to your Google Drive account. I uploaded a file called \u0026ldquo;IMG_1434.JPG\u0026rdquo; and I uploaded it the root of my account. If I wanted to copy this file from my Drive account to my Local computer, inside the ~/Desktop/Cards directory using rclone, I‚Äôd use this command:\nrclone copy aibanezDrive:/IMG_1434.JPG ~/Desktop/Cards And don\u0026rsquo;t forget that you can use this to download single files or entire directories if you please.\nAdditional Commands It\u0026rsquo;s beyond the scope of this article to talk about every single command and flag, but I thought I should mention a few of the most used ones.\nrclone Supports a whole lot of commands as listed in their Documentation. Some useful ones are sync (it keeps a remote directory in sync with a local one), move, delete (remove the contents of a path), purge (remove a path and all its contents), ls (List all the objects in the specified path), lsd (list all the directories under the path), mkdir, and rmdir.\nSome interesting flags you can use with your commands include but are not limited to --bwlimit, to limit the amount of bandwidth rclone will use, and --transfers to limit the amount of files that get transferred in batch.\nImportant Note!\nIt‚Äôs important to note that some commands and flags may not work or may behave differently based on what kind of remote you are using. The Storage Systems Overview page has a helpful table and a few notes for how commands may behave. There‚Äôs also a page for every supported remote that lists their quirks, features, and possible different behaviors for common commands.\nSetting up Encryption with rclone When we discussed what a remote means earlier, I said that a remote is a cloud account added to rclone. This is not strictly true, as there two notable exceptions to this.\nThere\u0026rsquo;s two remote types that don\u0026rsquo;t act as a cloud account. Instead, they sit \u0026ldquo;on top\u0026rdquo; of a normal remote to do their job. Said remotes are crypt and cache, and I just call them \u0026ldquo;special\u0026rdquo; remotes. We will only cover crypt in this article.\nThe crypt remote takes another remote name as part of its configuration. The crypt remote itself never touches the cloud directly. Instead, when you are uploading something, it encrypts the data, hands it over to the underlying remote, and this underlying remote will do the uploading on its behalf. Likewise, when you download something, crypt just requests the encrypted data to the underlying remote, which in turns gives the encrypted blobs to crypt, who will decrypt them. Everything crypt does is to encrypt and decrypt data, and the underlying remote does the actual downloading and uploading.\nIn this section, I will show you how the aibanezDrive remote we created earlier acts as the underlying remote for a new crypt remote we are about to create. Note that once you configure a crypt remote on top of a normal remote, you can still use both remotes normally, so be careful you choose the right remote when uploading, otherwise you might upload something sensitive unencrypted by default.\nCreating a Crypt Remote Before we create the new remote, delete the /Cards folder from your Google Drive (if you created it), as we will be using this same directory to show how crypt works.\nWe need to run rclone config again. Press n followed by Enter to create a new remote.\nOne thing I don‚Äôt like about rclone is that, when listing your remotes, you can‚Äôt see what underlying remote a crypt remote is using, so when prompted for the name, I recommend you choose one that can help you identify both the crypt and the underlying remote. I will be naming mine aibanezDrive_Crypt.\nAfter the name, you will be asked for the Storage type. Choose 9 which is the crypt type.\nYou will now be prompted for the underlying remote. Remember, this is the remote that will do the actual uploading and downloading, so write the name of the remote where you want to store your encrypted data. In this case it\u0026rsquo;s aibanezDrive.\nRemote to encrypt/decrypt. Normally should contain a \u0026#39;:\u0026#39; and a path, eg \u0026#34;myremote:path/to/dir\u0026#34;, \u0026#34;myremote:bucket\u0026#34; or maybe \u0026#34;myremote:\u0026#34; (not recommended). Enter a string value. Press Enter for the default (\u0026#34;\u0026#34;). remote\u0026gt; aibanezDrive:/Cards A small discussion is in order here. First, the remote\u0026gt; we are using contains both the remote and a path (aibanezDrive:/Cards). A crypt remote can store it\u0026rsquo;s data in just a folder somewhere in the underlying remote, or it can use the entirety of it. You should configure a special folder to store the encrypted data in, because rclone will have problems dealing with the contents of a remote that has both encrypted and unencrypted data. In the example above, the underlying remote is aibanezDrive:, and the root folder for crypt is /Cards inside of it. This means that the crypt remote will not be able to write or read outside the /Cards directory. When you use Google Drive through the drive client, you will see the /Cards directory, but everything inside of it will be gibberish.\nNext you will be asked if you want to encrypt the file names. Rclone can upload the filenames with their original names while encrypting their content. The choice is up to you, but I prefer to encrypt the file names. So write 2 followed by Enter.\nHow to encrypt the filenames. Enter a string value. Press Enter for the default (\u0026#34;standard\u0026#34;). Choose a number from below, or type in your own value 1 / Don\u0026#39;t encrypt the file names. Adds a \u0026#34;.bin\u0026#34; extension only. \\ \u0026#34;off\u0026#34; 2 / Encrypt the filenames see the docs for the details. \\ \u0026#34;standard\u0026#34; 3 / Very simple filename obfuscation. \\ \u0026#34;obfuscate\u0026#34; Important Note!\nSome remote types can\u0026rsquo;t deal with very long file names or paths. Encrypting the files will make the file names longer as rclone stores metadata within the encrypted filename.\nAs a personal anecdote, when I used the Amazon Drive remote, there was a limitation to file length and I couldn\u0026rsquo;t nest my files very deeply because of it. I haven\u0026rsquo;t had any similar issues with Google Drive yet, but your mileage may very.\nIn general, if your file names are below 156 characters, you should be fine on all providers. Please refer to the crypt documentation to see if you can find any limitations with the file paths lengths with the remote types you intend on using.\nYou will now be asked if you want to encrypt directory names. Just like file names, you can leave them unencrypted. I prefer to encrypt them, but keep in mind that directory names are also longer when encrypted.\nPress 1 followed by Enter.\nOption to either encrypt directory names or leave them intact. Enter a boolean value (true or false). Press Enter for the default (\u0026#34;true\u0026#34;). Choose a number from below, or type in your own value 1 / Encrypt directory names. \\ \u0026#34;true\u0026#34; 2 / Don\u0026#39;t encrypt directory names, leave them intact. \\ \u0026#34;false\u0026#34; directory_name_encryption\u0026gt; 1 Next you will be asked if you want to provide your own encryption password or have one generated by rclone. This is where you need to be careful. The password will be stored in a secure manner inside your config file. It\u0026rsquo;s very hard to retrieve the password from the config file later. Once the crypt remote has a password, you never have to worry about writing it down again as rclone will handle all that for you. For this reason, if you choose yes, you have to make sure you will never lose your password. If you choose generate, you have to be responsible and backup your rclone config file. You should always backup your config file regardless of what you choose, but if you chose y and you remember your password, you can recreate the remote and access your data in case you lose the original config. If you choose g and you lose your config file, you will never have access to the encrypted data ever again. So be careful here, and remember, backup, backup, backup!\nChoose y to write your own password for now.\nPassword or pass phrase for encryption. y) Yes type in my own password g) Generate random password n) No leave this optional password blank y/g/n\u0026gt; y You will be prompted twice for your password.\nTo complicate things a bit, you are given the option to generate a second password. The options are the same as above, as are the implications of each. I always choose y because I generate and keep this data stored in my password manager.\nPassword or pass phrase for salt. Optional but recommended. Should be different to the previous password. y) Yes type in my own password g) Generate random password n) No leave this optional password blank y/g/n\u0026gt; y Next you will be prompted if you want to use advanced config. Press n followed by Enter.\nFinally rclone will print your newly created crypt remote info.\n[aibanezDrive_Crypt] type = crypt remote = aibanezDrive:/Cards filename_encryption = standard directory_name_encryption = true password = *** ENCRYPTED *** password2 = *** ENCRYPTED *** We are ready to use our new shiny remote.\nUsing a Crypt Remote The nice thing about rclone is that once you have used a remote type, you have used them all. The syntax for the common commands such as copy does not change at all, whether you are using a Dropbox remote or a crypt remote. Run the following to upload the ~/Desktop/Cards directory once again, but this time with your crypt remote:\nrclone copy ~/Desktop/Cards aibanezDrive_Crypt:/ Now, open Google Drive in the web client and open the /Cards directory. You will see the right amount of folders and files, but their filenames are complete gibberish and even their contents are encrypted.\nNow the only way to access these files is with rclone. rclone knows how to do the right thing. List the remote\u0026rsquo;s contents:\nrclone ls aibanezDrive_Crypt:/ Andys-iMac:Cards andyibanez$ rclone ls aibanezDrive_Crypt:/ 358768 IMG_1434.JPG 0 None.txt 0 Shaoran/The Freeze 0 Shaoran/The Return 0 Shaoran/The Storm 0 Shaoran/The Time 0 Sakura/The Sword 0 Sakura/The Mirror 0 Sakura/The Return 0 Sakura/The Fly And rclone will show you the decrypted filenames for you.\nIf you use copy to copy from the crypt remote to your computer, rclone will decrypt the files and their names. rclone\u0026rsquo;s encryption method is really transparent, and you never have to concern yourself with the details of how it\u0026rsquo;s done.\nrclone copy aibanezDrive_Crypt:/Sakura ~/Desktop/restored Conclusion rclone is a great tool to interact with cloud storage services from the command line. It\u0026rsquo;s encryption support is transparent and very easy to use. As long as you keep a backup of your rclone.conf file, you will never lose access to your encrypted files.\nWhere to Go From Here Once you are familiar with rclone, I recommend you explore the Official Site of the project so you can learn more advanced tasks you can do. Take some time to explore the documentation to learn how to use other commands, as well as how to use certain flags with certain commands. A particular command I use a lot is sync with the --log-file and --backup-dir flags. This allows me to check that all files were synced properly to the remote, and to move the ones that were different or deleted someplace else instead of outright removing them (for incremental backups). But there\u0026rsquo;s much more you can do, and the only way to learn all the power of rclone is to browse the documentation and play around with it. In the future, I may share my backup strategies with rclone to give you ideas how you can use this amazing tool.\n","tags":["rclone","linux","command line"]},{"id":"ac55a323c126ab157d760a592406e5eb","title":"Next Anime Episode Privacy Policy","link":"/privacy-policies/nae1/","content":"NOTE This app has been transferred to Alon Waller, effective Feb 11, 2021. This privacy policy no longer applies.\nAndy Ibanez K built the Next Anime Episode app as a Commercial app. This SERVICE is provided by Andy Ibanez K and is intended for use as is.\nThis page is used to inform visitors regarding my policies with the collection, use, and disclosure of Personal Information if anyone decided to use my Service.\nIf you choose to use my Service, then you agree to the collection and use of information in relation to this policy. The Personal Information that I collect is used for providing and improving the Service. I will not use or share your information with anyone except as described in this Privacy Policy.\nThe terms used in this Privacy Policy have the same meanings as in our Terms and Conditions, which is accessible at Next Anime Episode unless otherwise defined in this Privacy Policy. Information Collection and Use For a better experience, while using our Service, I may require you to provide us with certain personally identifiable information. The information that I request will be retained on your device and is not collected by me in any way.\nI want to inform you that whenever you use my Service, in a case of an error in the app I collect data and information (through third party products) on your phone called Log Data. This Log Data may include information such as your device Internet Protocol (‚ÄúIP‚Äù) address, device name, operating system version, the configuration of the app when utilizing my Service, the time and date of your use of the Service, and other statistics.\nCookies\nCookies are files with a small amount of data that are commonly used as anonymous unique identifiers. These are sent to your browser from the websites that you visit and are stored on your device‚Äôs internal memory.\nThis Service does not use these ‚Äúcookies‚Äù explicitly. However, the app may use third party code and libraries that use ‚Äúcookies‚Äù to collect information and improve their services. You have the option to either accept or refuse these cookies and know when a cookie is being sent to your device. If you choose to refuse our cookies, you may not be able to use some portions of this Service.\nService Providers\nI may employ third-party companies and individuals due to the following reasons:\nTo facilitate our Service;\nTo provide the Service on our behalf;\nTo perform Service-related services; or\nTo assist us in analyzing how our Service is used.\nI want to inform users of this Service that these third parties have access to your Personal Information. The reason is to perform the tasks assigned to them on our behalf. However, they are obligated not to disclose or use the information for any other purpose.\nSecurity\nI value your trust in providing us your Personal Information, thus we are striving to use commercially acceptable means of protecting it. But remember that no method of transmission over the internet, or method of electronic storage is 100% secure and reliable, and I cannot guarantee its absolute security.\nLinks to Other Sites\nThis Service may contain links to other sites. If you click on a third-party link, you will be directed to that site. Note that these external sites are not operated by me. Therefore, I strongly advise you to review the Privacy Policy of these websites. I have no control over and assume no responsibility for the content, privacy policies, or practices of any third-party sites or services.\nChildren‚Äôs Privacy\nThese Services do not address anyone under the age of 13. I do not knowingly collect personally identifiable information from children under 13. In the case I discover that a child under 13 has provided me with personal information, I immediately delete this from our servers. If you are a parent or guardian and you are aware that your child has provided us with personal information, please contact me so that I will be able to do necessary actions.\nChanges to This Privacy Policy\nI may update our Privacy Policy from time to time. Thus, you are advised to review this page periodically for any changes. I will notify you of any changes by posting the new Privacy Policy on this page. These changes are effective immediately after they are posted on this page.\nContact Us\nIf you have any questions or suggestions about my Privacy Policy, do not hesitate to contact me.\n‚Äî- Friendly version ‚Äî-\nThis app by itself does not collect any kind of information from your information at all. Not personal information, not analytics, or anything. However, the app uses the Anilist.co service to retrieve anime. Your device does standard HTTP requests to this server. The information sent on HTTP requests usually include some information including IP address, user agents, and others. By using Next Anime Episode, you agree that some information pertaining to HTTP requests will be sent to Anilist.co‚Äôs servers, and therefore you agree with their privacy policy. I am not associated with Anilist in any way.\n","tags":null},{"id":"e9de30d0e5961d7dca9dadf9af65a463","title":"Silvianna for Anilist - Privacy Policy","link":"/privacy-policies/privacy_policy_silvianna/","content":"The Privacy Policy for Silvianna can be resumed in one sentence:\nSilvianna will not store your information, personal or otherwise, in any third-party servers not owned by Anilist.co, Apple, RevenueCat, or GitHub.\nSilvianna is a client for https://anilist.co (hereafter simply called \u0026ldquo;Anilist\u0026rdquo;), the popular anime and manga database service. As such, Silvianna will interact with Anilist in order to do any work at all. With Silvianna, you can view information stored on Anilist, and that includes any personal information you may have provided to them.\nThe only networking interaction occurs between the App and Anilist, the App and Apple\u0026rsquo;s Servers, the App and RevenueCat\u0026rsquo;s servers, and the App and GitHub\u0026rsquo;s servers.\nSilvianna will not not send any information stored in the service to a third party server that is not owned by Anilist or RevenueCat.\nThe following points highlight how the app is used, and what information may be available to you through this app.\nSilvianna uses the official Anilist API. This is the bare minimum in order to offer any kind of functionality.\nBecause Silvianna interacts with Anilist, you should be aware of the Privacy Policy currently effective on Anilist.co. Silvianna will perform HTTP requests against Anilist\u0026rsquo;s servers, but you are responsible for knowing what they may store on you when you create an account, use their website, or use their API.\nSilvianna will (willingly) only interact with servers hosted by the following entities directly. Please ensure you agree with their own Privacy Policies in order to use Silvianna:\nhttps://anilist.co, in order to provide functionality. Anilist\u0026rsquo;s Privacy Policy\nApple\u0026rsquo;s servers, in order to provide In-App Purchase information. Apple\u0026rsquo;s Privacy Policy\nRevenueCat\u0026rsquo;s services, in order to provide facilities for dealing with In-App Purchases. RevenueCat may collect anonymous information regarding your in-app purchases for the purpose of aggregating IAP data. RevenueCat\u0026rsquo;s Privacy Policy\nGitHub. There are some plain JSON files stored there that Silvianna needs in order to provide some functionality. As an example, the list of IAPs is stored and loaded dynamically from there.\nWhen you authorize the app to access your Anilist account, at the login step, the app will never receive your login information such as E-mail and Password. Instead, you will authenticate to Anilist.co directly via a webview, and when the website determines your credentials are fine and you allow Silvianna to access your account, Anilist will give the app an unique token that can be used to access your account. This token allows us to access your Anilist account and retrieve information such as your username, and your avatar, as well as your Anilist lists for anime and manga. Please understand this is necessary in order for the app to work. We also use this token to update your lists on Anilist when perform actions such as adding and removing media, or editing existing ones. The information we can retrieve with your authorization token will never be sent to a third party. Your Anilist username may be shared with RevenueCat. The access token is received on your device, and it will never leave your device.\nSilvianna does not currently make use of any third-party analytics or benchmarking frameworks.\n","tags":null},{"id":"4a696b0484e5a62a7edf162a0e628d9e","title":"Next Anime Episode","link":"/projects/nextanimeepisode1/","content":"IMPORTANT NOTE While I am the original developer of this app, it has since been transferred to Alon Waller, so I can no longer offer support for the app.\nDownload on the App Store | Privacy Policy\nNext Anime Episode does one job: To help you keep track of airing anime and when they will have a new episode available in Japan.\nGenerally, sub based simulcast streaming services have the newest episodes available within one hour after they air in Japan.\nSimply browse the currently airing chart, select which anime you are interested in, and you will receive a notification when a new episode for your selected series is available. It‚Äôs that easy! You can also monitors what will be airing next, as Next Anime Episode will show you your anime series sorted by the closest episode first.\nFeatures: Instant push notifications when a new episode airs. Easy access to view all the anime that is airing this season in Japan, to let you easily pick which ones you are interested in. The Notifications are highlighted with a badge to help you keep track of what you are interested in but haven‚Äôt watched yet. You can mark Episodes as ‚ÄúWatched‚Äù anytime. Doing so also decreases the notification count. Monitor what episodes will air next, as they are displayed in order of closest next episode in the Watching tab. Notes: The data is provided by an external source (Anilist). This app should be used as a reference only and it might not be 100% accurate. Anime characters, titles, and posters that show up in the screenshots are copyright of their respective owners and are used for reference only. This app DOES NOT make any media available to you. Once you know an episode has aired, you are free to navigate to your favorite Simulcast service and watch the episode there. ","tags":["ios","app store"]},{"id":"1bac627ea127e085b33fd699cb344ddb","title":"Fsduplicates","link":"/projects/fsduplicates/","content":"\nDiscontinued project. Developed in 2016\nCommand line tool to detect duplicate songs in OS X/macOS based on their Audio Fingerprints.\nfsduplicates helps you find song duplicates recursively in any specific directory and output its findings in a different directory. With the generated results you can later analyse and take action on duplicate songs. The results are in plain text files, which you can analyse using any tool, like Unix standard commands, or fsduplicates‚Äô tools.\nfsduplicates works by contacting AcoustID (acoustid.org) for each song generating a unique ID for each song. If two songs have the same ID, they are the same song. Internally, fsduplicates uses fpcalc, a command line tool developed by Chromaprint to generate fingerprints.\nAvailable source code (Warning - it\u0026rsquo;s bad): Github\n","tags":["macos","open source"]},{"id":"631b7e0f945781c829dc8fb097fb0c10","title":"Mignori Box","link":"/projects/mignoribox/","content":"\nDiscontinued project. Developed in 2014.\nMignori Box was a service to download your Mignori 1 collections to your computer.\nThe website was built using the classic web technologies. Twitter Bootstrap and jQuery for the front-end, PHP and even Bash for the backend. The site was hosted in a VPS provided by DigitalOcean.\n","tags":["web","php"]},{"id":"35af692ff9eace9fa03c7011a55bd6e3","title":"Mignori 1","link":"/projects/mignori1/","content":"\nDiscontinued project, but a new version is in the works. Developed in 2014.\nMignori is a mobile client to use with -booru or -booru based sites (Gelbooru and Danbooru, to name a few).\nA -booru imageboard is simply a board where people post pictures and tag with them relevant attributes. This allows other users to search for images in these boards and find images with the qualities they‚Äôre looking for.\nExample of tags you can search for in Mignori:\nnaruto card_captor_sakura red_hair sakura_kinomoto Mignori comes with Safebooru as a working server so you can start browsing images right away! You can also add any -booru based site to browse their servers.\nFeatures: Collections. The collections feature allows you to save images to the app and to categorize as you wish. You can create collections for Anime series, characters, favorite tags, the sky is the limit! To prevent Mignori for using a lot of space, Mignori will not store actual images in your device by default: By creating a collection, you are creating a ‚Äúlist of posts‚Äù you like. You can easily access your collections, and if the images aren‚Äôt cached, Mignori will simply download them again. This behavior can be changed in settings and you can force Mignori to permanently store images, in case your data plan is limited and you cannot redownload images every time you want to see them in your collections. Due note that if you use Mignori a lot this can cause the app to use a kit of your phone‚Äôs space. Save images to camera roll. Neat tags integration. You can view all the tags an image has, and then favorite them or search for images with those tags without having to type them manually. Favorite tags. If you find tags you want to store so that you can remember or access them later. Blacklist tags. Mignori works as a web browser in terms of content, so it can‚Äôt control what images you see from external servers other than the one included by default. Blacklisting tags will prevent images with said tags to show up in your search results. Filters. You can create ‚Äúfilters‚Äù to quickly manage your collections the moment you want to save an image. Filters allow you to specify a criteria for posts you want to add to your collections. Posts that match that criteria will then be managed by the action specified in the Filter. For example, you can create a filter to store all images that have the tags ‚Äúbrown_hair, green_eyes‚Äù to a collection called ‚ÄúFavorite Images‚Äù. You can also save to nested collections. Finally, you can create a filter that will save images to a specified album in your camera roll instead of in your collections. You can create up to two filters with the free version of Mignori. Pro Features: Nested Collections: The free version of Mignori cannot nest collections. With this feature you can do even more relevant groupings. For example, you can create collections for your favorite anime series, and then sub collections for characters. /Card Captor Sakura/Sakura Kinomoto /Card Captor Sakura/Shaoran Li Search for more than two tags at a time. For the casual users, searching for two tags at most a time may be enough but if you‚Äôre a frequent user, you can buy Mignori pro and search for images that match as many tags as you want. Export and import data. Exporting your data will create a backup of your servers, collections, tags, and filters. Unlimited filters. Passlock Screen. Unlimited servers. Dropbox Sync. If you have more than one iOS device, you can keep all your instances of Mignori in sync via Dropbox. This also creates a backup of Mignori in the cloud so even if you don‚Äôt have more than one iOS device, you can recover your collections if you lose your only phone. ","tags":["ios","app store"]},{"id":"ede360376016acbba87e1ea1adca4d43","title":"Leopaster","link":"/projects/leopaster/","content":"\nDiscontinued project. Developed in 2015\nQuick Status Bar Menu on OS X that allows you to quickly paste code on @DHowett‚Äôs ghostbin.com.\nghostbin.com is a simple pasteboard service that allows people to paste code or any other text and to quickly share a link to them. These services allow developers to share code snippets faster to either request help with an specific piece of code, or to help others with theirs (Other uses may apply).\nUsage\nLeopaster is a simple status bar app on your Mac. When you click it, you will see all it‚Äôs features and Ghostbin‚Äôs supported languages.\nCopy the code you want to send to Ghostbin to your clipboard (aka right click -\u0026gt; copy, or cmd+c). Then click the Leopaster item and select an expiration time. By default, the expiration time is set to ‚ÄúUndefined‚Äù, which doesn‚Äôt send any expiration data to Ghostbin so it‚Äôs kept indefinitely. Changing the expiry time will use that expiry data on all further pastes (it‚Äôs not necessary to choose a different expiry time everytime you want to use Leopaster as it will remember your last used setting).\nSimply clicking on the language will send your code in your clipboard to Ghostbin. When your paste is ready, you will receive a notification on OS X telling your your paste is ready, and it will place the link your clipboard, so you can paste it (aka right-click -\u0026gt; paste, or cmd+v) anywhere you want, hassle free.\nNotes and Credits\nThanks to @DHowett for very quickly giving me a link to Ghostbin‚Äôs API usage. Finding the API URL is a bit complicated unless you ask, so I will put it here for those interested:\nhttps://ghostbin.com/paste/p3qcy\nAnd finally thanks to anyone who is planning on using this.\nAvailable source code (Warning - it\u0026rsquo;s bad): Github\n","tags":["macos","open source"]},{"id":"458fa05be764c3be5c38cce1a46c7290","title":"Cecrecy","link":"/projects/cecrecy/","content":"\nDiscontinued project. Developed in 2013.\nIf you want to protect app data from your friends or family that are constantly asking for your iDevice, there are a couple of things you can do: You can tell them not to enter certain apps, empowering their curiosity and therefore exposing your private data, or you can passcode-lock certain apps, which if they see, they will just wonder what you‚Äôre hiding that they can‚Äôt see.\nAre those two options really good? I didn‚Äôt think so, so I decided to give you another way to protect your app privacy a bit more.\nCecrecy is like a passcode protect tweak, but it does a little bit more: Instead of passcode-locking apps, it will hide them altogether! Yep. It will hide them from both SpringBoard and Spotlight. Poof, gone. If your apps aren‚Äôt there, people will simply assume they don‚Äôt exist on your device.\nThis can be really handy. If you have kids, you may have games for them in your phone. But your phone may also have those ‚Äúprivate‚Äù apps you share with your wife. When you lend your phone to your kids, you can completely hide the apps you use with your wife. In that way, your kids will not see what you really have.\nOr you may be a student who constantly have people ask for your phone, so other people can read your messages. You can hide the Messages.app from your SpringBoard and everywhere else. Everything with a toggle. When things are safe again, you can show all the icons you hid, automatically and painlessly.\nAvailable source code (Warning - it\u0026rsquo;s bad): Github\nAdditionally, the tweak had a SBSettings toggle to enable it faster (Warning - it\u0026rsquo;s bad): Github\n","tags":["ios","cydia","jailbreak","open source"]},{"id":"b7746bd9576968633862c70363741b0a","title":"Maulencer","link":"/projects/maulencer/","content":"\nDiscontinued project. Developed in 2013.\nA friend of mine had his hardware ringer of his phone die on him. Because of that, toggling the ringer on and off was quite a chore for him. Without installing SBSettings or anything equivalent to that, he had to go to the settings app and toggle the ringer on and off there.\nSo he asked me to write an icon on SpringBoard that would toggle the ringer. And here it is. It‚Äôs a really, really simple tweak. In developer circles it probably isn‚Äôt worth anyone‚Äôs time. But anyway, I decided to release to the public and here it is.\nSimply download the tweak and install it. After that, manually respring your phone. The app icon is the Andy Ibanez logo. To toggle it, it is as easy as tapping it.\nThis tweak was made for people whose hardware switches have stopped working, but of course, if yours work and just want an alternate way to toggle the ringer, feel free to install it. This tweak will not blow your phone up.\nAnd as a final note, the tweak is fully compatible with Sideswitch Toggles. Maulencer is really just a software replacement for the hardware ringer, so it works exactly the same way, and that means Sideswitch Toggles fully works with it.\nAvailable source code (Warning - it\u0026rsquo;s bad): Github\n","tags":["ios","cydia","jailbreak","open source"]},{"id":"075b535f91a0980ca6ed19df5be52ec4","title":"Sideswitch Toggles","link":"/projects/sideswitch-toggles/","content":"\nDiscontinued project. Developed in 2012.\nSideswitch Toggles is a MobileSubstrate tweak that gives you full control over your iPhone‚Äôs Ringer (and as such, it isn‚Äôt available for the iPod Touch). The tweak simply modifies the action that happens when you toggle the ringer on and off.\nBy default, Sideswitch Toggles comes with the ability to toggle Bluetooth, Wi-Fi, Airplane Mode, and Do Not Disturb. The capabilities of Sideswitch can be easily extended by other developers.\nOnce installed, the tweak will install a simple preferences page in the Settings.app. In this page you can select what to do when the phone ringer is toggled on and off.\nWhen you choose a new toggle, please push the ‚ÄúRespring‚Äù button so your changes can take place. There is a technical limitation that doesn‚Äôt allow me to circumvent this action.\nIf you find a new Sideswitch Toggle you want to install, simply install it and it will show up immediately in the sources list. You don‚Äôt need to do anything else to get new toggles up and working unless specified otherwise by the developer of the toggle.\nAvailable source code (Warning - it\u0026rsquo;s bad): Github\n","tags":["ios","cydia","jailbreak","open source"]},{"id":"77d63e250b2b5be7cff1bd6292318ddc","title":"Silight","link":"/projects/silight/","content":"\nDiscontinued project. Developed in 2011\nSiLight is a small AssistantExtension that allows Siri to turn on your phone‚Äôs torch to use it as a flashlight. SiLight is a real quick flashlight, since commands work in the Lockscreen too. SiLight was programmed having natural speech in mind, instead of talking to her like a robot (‚Äúflashlight on‚Äù) you can ask her as you would ask anyone (‚ÄúI need a flashlight‚Äù, ‚ÄúSiri, there‚Äôs a blackout‚Äù). It also features some hidden surprises for geeks.\nAvailable source code (Warning - it\u0026rsquo;s bad): Github\n","tags":["ios","cydia","jailbreak","open source"]},{"id":"50a959fc3a00b5cb38c92bc10353aff4","title":"Combox","link":"/projects/combox/","content":"\nDiscontinued project. Developed in 2012.\nCombox is a third-party client for Dropbox.\nDo you love Dropbox? Dropbox is a very nifty service that allows you to store your files in the cloud. With Dropbox, you can upload and download your documents and photos anywhere, any time.\nWhy a third-party client? This app was made with Dropbox lovers and Power Users in mind. It offers many features that no other Dropbox clients for iOS offer.\nFeatures: Full Dropbox navigator. You can access any Dropbox folder you have in your Dropbox account. Do you have documents in your Dropbox account that can‚Äôt be opened by Combox itself? No problem! The app features a ‚ÄúOpen With‚Ä¶‚Äù feature that will detect all the apps in your device that can open a given file. For example, this app cannot open Microsoft Word files, but if you have an app installed that can, you can ‚ÄúOpen With‚Ä¶‚Äù that app and Combox will send the file to it, and you can edit it there. Create folders anywhere. This is one of the few Dropbox apps that actually allows you to create folders anywhere and easily. You will no longer need to log in into your Dropbox account with your computer to create simple folders! Combox includes a simple text editor for those notes you want to have with you anywhere and can‚Äôt risk to lose them. Support to create, edit, and read plain text (.txt) files. Revisions explorer. If you work with revisions you can restore any file revision from the app itself. Basic picture viewer. view your pictures without having to download them, and save them to your device if you wish. Bulk-upload pictures. Get the shareable link of any file and folder in your Dropbox account and e-mail them or copy them to your clipboard with ease. Wonderful and simple for those people who constantly find themselves sharing their documents with many people at once. Easily delete any files and folders. Easily move and copy files and folders to new locations. If you have any suggestions, please feel free to peek at my website so you can send suggestions directly to me!\n(If you get an error after authentication, don‚Äôt worry; the app will still work fine, it just won‚Äôt fetch your personal information until you relaunch the app).\nChangelog: 1.0 Initial release. Available source code (Warning - it\u0026rsquo;s bad): Github\n","tags":["ios","app store","open source"]},{"id":"d8e2639b7831e99dba7067f70f26adc4","title":"SBConverter","link":"/projects/sb-converter/","content":"\nDiscontinued project. Developed in 2011.\nA very complete base number converter for programmers and computer science students. Super Base Converter (SBConverter) is a very powerful base number conversion tool. It offers a simple and intuitive user interface free of distractions to allow users to quickly convert from one number base to another.\nFeatures: Convert any number back and forth in any base from base 2 (binary) to base 16 (hexadecimal). Convert any number base up to base 64 (no support to convert numbers in base 17 or longer to any other base, sorry! But you can convert any number to these high bases). Fast and slick user interface: Transform any number to any base as you type it instead of tapping a ‚Äúconvert‚Äù button. Change number bases easily. Changelog: 1.0 Initial Release. ","tags":["ios","app store"]},{"id":"6d99026b9e19e4fa43d5aadf147c7176","title":"Contact Me","link":"/contact/","content":"Thank you for your interest in contacting me. Select the best category from the dropdown. If you expect a reply, it might take me a few days to get back to you.\nPlease note that due to personal policy, I do not reply back to emails asking for help with code or projects for free. If you need help, please select the \u0026ldquo;Contracting\u0026rdquo; option below. You will receive a response back with my rates before continuing.\nContact Me Got a question or want to work together? Just fill out the form below.\nName Email Type of Inquiry Contracting Sponsorship Something Else Message Send Message ","tags":null}]