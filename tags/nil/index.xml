<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nil on Andy Ibanez</title><link>https://www.andyibanez.com/tags/nil/</link><description>Recent content in Nil on Andy Ibanez</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 03 Feb 2021 07:00:00 -0400</lastBuildDate><atom:link href="https://www.andyibanez.com/tags/nil/index.xml" rel="self" type="application/rss+xml"/><item><title>nil-null-mess in Objective-C and Swift</title><link>https://www.andyibanez.com/posts/nil-null-mess-objective-c-and-swift/</link><pubDate>Wed, 03 Feb 2021 07:00:00 -0400</pubDate><guid>https://www.andyibanez.com/posts/nil-null-mess-objective-c-and-swift/</guid><description>&lt;p>All programmers are familiar with the concept of &lt;code>nullability&lt;/code>. Whether something exists or not. Whether something is there or not.&lt;/p>
&lt;p>Objective-C is very dynamic when it comes to dealing with nullability. All Objective-C programmers are familiar with this phrase:&lt;/p>
&lt;blockquote>
&lt;p>messages can be sent to nil.&lt;/p>&lt;/blockquote>
&lt;p>Which means that &lt;code>nil&lt;/code> itself can call methods, safely enough, without crashing.&lt;/p>
&lt;p>In Swift, we have a bit more safety. We can send &amp;ldquo;messages&amp;rdquo; to &lt;code>nil&lt;/code>, but only if they are the result of a chained optional. &lt;code>nil&lt;/code> can only be a thing when we are working with optionals.&lt;/p></description></item></channel></rss>