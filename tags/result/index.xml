<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Result on Andy Ibanez</title><link>https://www.andyibanez.com/tags/result/</link><description>Recent content in Result on Andy Ibanez</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 11 Sep 2019 07:00:00 -0400</lastBuildDate><atom:link href="https://www.andyibanez.com/tags/result/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding the Result Type in Swift</title><link>https://www.andyibanez.com/posts/swift-result-type/</link><pubDate>Wed, 11 Sep 2019 07:00:00 -0400</pubDate><guid>https://www.andyibanez.com/posts/swift-result-type/</guid><description>&lt;p>Error handling when expecting a result out of an operation is a very common thing to do. For this reason, various high-level programming languages have introduced a &lt;code>Result&lt;/code> type into their libraries, on top of their existing error-handling features. This feature was implemented in Swift 5.&lt;/p>
&lt;p>A &lt;code>Result&lt;/code> wraps a success or a failure. It is essentially an &lt;code>enum&lt;/code> with two possible cases: &lt;code>.success&lt;/code> and &lt;code>.failure&lt;/code>. The &lt;code>.success&lt;/code> case wraps the correct result of an operation, whereas a &lt;code>.failure&lt;/code> wraps an &lt;code>Error&lt;/code>. Its implementation uses generics, so you always know what you are going to get back.&lt;/p></description></item></channel></rss>